//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import * as moment from 'moment';

export const MARITZA_API_URL = new InjectionToken<string>('MARITZA_API_URL');

@Injectable()
export class AnalysisApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getlist(): Observable<AnalysisModel[]> {
        let url_ = this.baseUrl + "/api/contents/analysis/getlist";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetlist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AnalysisModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AnalysisModel[]>;
        }));
    }

    protected processGetlist(response: HttpResponseBase): Observable<AnalysisModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AnalysisModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AnalysisModel[]>(null as any);
    }
}

@Injectable()
export class AssetsApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getbyid(id: number | undefined): Observable<AssetModel> {
        let url_ = this.baseUrl + "/api/finance/assets/getbyid?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AssetModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AssetModel>;
        }));
    }

    protected processGetbyid(response: HttpResponseBase): Observable<AssetModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssetModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssetModel>(null as any);
    }

    /**
     * @return Success
     */
    getwallet(): Observable<AssetModel[]> {
        let url_ = this.baseUrl + "/api/finance/assets/getwallet";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetwallet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetwallet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AssetModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AssetModel[]>;
        }));
    }

    protected processGetwallet(response: HttpResponseBase): Observable<AssetModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AssetModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssetModel[]>(null as any);
    }
}

@Injectable()
export class AuthApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    login(body: LoginModel | undefined): Observable<AuthenticatorModel> {
        let url_ = this.baseUrl + "/api/auth/auth/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AuthenticatorModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AuthenticatorModel>;
        }));
    }

    protected processLogin(response: HttpResponseBase): Observable<AuthenticatorModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthenticatorModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData400)) {
                result400 = [] as any;
                for (let item of resultData400)
                    result400!.push(ErrorDto.fromJS(item));
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthenticatorModel>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    verify(body: VerifyModel | undefined): Observable<TokenModel> {
        let url_ = this.baseUrl + "/api/auth/auth/verify";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerify(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerify(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TokenModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TokenModel>;
        }));
    }

    protected processVerify(response: HttpResponseBase): Observable<TokenModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TokenModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData400)) {
                result400 = [] as any;
                for (let item of resultData400)
                    result400!.push(ErrorDto.fromJS(item));
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TokenModel>(null as any);
    }

    /**
     * @param token (optional) 
     * @param key (optional) 
     * @return Success
     */
    refreshtoken(token: string | undefined, key: string | undefined): Observable<TokenModel> {
        let url_ = this.baseUrl + "/api/auth/auth/refreshtoken?";
        if (token === null)
            throw new Error("The parameter 'token' cannot be null.");
        else if (token !== undefined)
            url_ += "token=" + encodeURIComponent("" + token) + "&";
        if (key === null)
            throw new Error("The parameter 'key' cannot be null.");
        else if (key !== undefined)
            url_ += "key=" + encodeURIComponent("" + key) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRefreshtoken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRefreshtoken(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TokenModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TokenModel>;
        }));
    }

    protected processRefreshtoken(response: HttpResponseBase): Observable<TokenModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TokenModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData400)) {
                result400 = [] as any;
                for (let item of resultData400)
                    result400!.push(ErrorDto.fromJS(item));
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TokenModel>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    forgot(body: ForgotModel | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/auth/auth/forgot";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processForgot(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processForgot(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processForgot(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData400)) {
                result400 = [] as any;
                for (let item of resultData400)
                    result400!.push(ErrorDto.fromJS(item));
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendotp(body: ForgotModel | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/auth/auth/sendotp";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendotp(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendotp(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSendotp(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData400)) {
                result400 = [] as any;
                for (let item of resultData400)
                    result400!.push(ErrorDto.fromJS(item));
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param phoneNumber (optional) 
     * @return Success
     */
    checkphonenumber(phoneNumber: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/auth/auth/checkphonenumber?";
        if (phoneNumber === null)
            throw new Error("The parameter 'phoneNumber' cannot be null.");
        else if (phoneNumber !== undefined)
            url_ += "phoneNumber=" + encodeURIComponent("" + phoneNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckphonenumber(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckphonenumber(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCheckphonenumber(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData400)) {
                result400 = [] as any;
                for (let item of resultData400)
                    result400!.push(ErrorDto.fromJS(item));
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param identityNo (optional) 
     * @return Success
     */
    checkemail(identityNo: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/auth/auth/checkemail?";
        if (identityNo === null)
            throw new Error("The parameter 'identityNo' cannot be null.");
        else if (identityNo !== undefined)
            url_ += "identityNo=" + encodeURIComponent("" + identityNo) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckemail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckemail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCheckemail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData400)) {
                result400 = [] as any;
                for (let item of resultData400)
                    result400!.push(ErrorDto.fromJS(item));
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param identityNo (optional) 
     * @return Success
     */
    checkidentityno(identityNo: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/auth/auth/checkidentityno?";
        if (identityNo === null)
            throw new Error("The parameter 'identityNo' cannot be null.");
        else if (identityNo !== undefined)
            url_ += "identityNo=" + encodeURIComponent("" + identityNo) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckidentityno(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckidentityno(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCheckidentityno(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData400)) {
                result400 = [] as any;
                for (let item of resultData400)
                    result400!.push(ErrorDto.fromJS(item));
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    register(body: RegisterModel | undefined): Observable<TokenModel> {
        let url_ = this.baseUrl + "/api/auth/auth/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TokenModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TokenModel>;
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<TokenModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TokenModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData400)) {
                result400 = [] as any;
                for (let item of resultData400)
                    result400!.push(ErrorDto.fromJS(item));
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TokenModel>(null as any);
    }
}

@Injectable()
export class BankApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getlist(): Observable<BankModel[]> {
        let url_ = this.baseUrl + "/api/settings/core/bank/getlist";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetlist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BankModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BankModel[]>;
        }));
    }

    protected processGetlist(response: HttpResponseBase): Observable<BankModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(BankModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BankModel[]>(null as any);
    }
}

@Injectable()
export class BankaccountApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getaccount(id: number | undefined): Observable<UserBankAccountModel> {
        let url_ = this.baseUrl + "/api/auth/bankaccount/getaccount?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetaccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetaccount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserBankAccountModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserBankAccountModel>;
        }));
    }

    protected processGetaccount(response: HttpResponseBase): Observable<UserBankAccountModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserBankAccountModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserBankAccountModel>(null as any);
    }

    /**
     * @return Success
     */
    getaccounts(): Observable<UserBankAccountModel[]> {
        let url_ = this.baseUrl + "/api/auth/bankaccount/getaccounts";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetaccounts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetaccounts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserBankAccountModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserBankAccountModel[]>;
        }));
    }

    protected processGetaccounts(response: HttpResponseBase): Observable<UserBankAccountModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserBankAccountModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserBankAccountModel[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveaccount(body: UserBankAccountModel | undefined): Observable<UserBankAccountModel> {
        let url_ = this.baseUrl + "/api/auth/bankaccount/saveaccount";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveaccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveaccount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserBankAccountModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserBankAccountModel>;
        }));
    }

    protected processSaveaccount(response: HttpResponseBase): Observable<UserBankAccountModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserBankAccountModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData400)) {
                result400 = [] as any;
                for (let item of resultData400)
                    result400!.push(ErrorDto.fromJS(item));
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserBankAccountModel>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateaccount(body: UserBankAccountModel | undefined): Observable<UserBankAccountModel> {
        let url_ = this.baseUrl + "/api/auth/bankaccount/updateaccount";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateaccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateaccount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserBankAccountModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserBankAccountModel>;
        }));
    }

    protected processUpdateaccount(response: HttpResponseBase): Observable<UserBankAccountModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserBankAccountModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData400)) {
                result400 = [] as any;
                for (let item of resultData400)
                    result400!.push(ErrorDto.fromJS(item));
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserBankAccountModel>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deleteaccount(body: UserBankAccountModel | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/auth/bankaccount/deleteaccount";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteaccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteaccount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteaccount(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData400)) {
                result400 = [] as any;
                for (let item of resultData400)
                    result400!.push(ErrorDto.fromJS(item));
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class CardApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param cardId (optional) 
     * @return Success
     */
    getcard(cardId: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/auth/card/getcard?";
        if (cardId === null)
            throw new Error("The parameter 'cardId' cannot be null.");
        else if (cardId !== undefined)
            url_ += "cardId=" + encodeURIComponent("" + cardId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetcard(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetcard(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetcard(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData400)) {
                result400 = [] as any;
                for (let item of resultData400)
                    result400!.push(ErrorDto.fromJS(item));
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getcards(): Observable<any[]> {
        let url_ = this.baseUrl + "/api/auth/card/getcards";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetcards(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetcards(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any[]>;
        }));
    }

    protected processGetcards(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData400)) {
                result400 = [] as any;
                for (let item of resultData400)
                    result400!.push(ErrorDto.fromJS(item));
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    savecard(body: any | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/auth/card/savecard";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSavecard(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSavecard(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSavecard(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData400)) {
                result400 = [] as any;
                for (let item of resultData400)
                    result400!.push(ErrorDto.fromJS(item));
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param cardId (optional) 
     * @return Success
     */
    deletecard(cardId: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/auth/card/deletecard?";
        if (cardId === null)
            throw new Error("The parameter 'cardId' cannot be null.");
        else if (cardId !== undefined)
            url_ += "cardId=" + encodeURIComponent("" + cardId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletecard(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletecard(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeletecard(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData400)) {
                result400 = [] as any;
                for (let item of resultData400)
                    result400!.push(ErrorDto.fromJS(item));
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class CommissionApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getlist(): Observable<CommissionModel[]> {
        let url_ = this.baseUrl + "/api/settings/finance/commission/getlist";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetlist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CommissionModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CommissionModel[]>;
        }));
    }

    protected processGetlist(response: HttpResponseBase): Observable<CommissionModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CommissionModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommissionModel[]>(null as any);
    }
}

@Injectable()
export class CorporateApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    add(body: CorporateModel | undefined): Observable<CorporateModel> {
        let url_ = this.baseUrl + "/api/auth/corporate/add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CorporateModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CorporateModel>;
        }));
    }

    protected processAdd(response: HttpResponseBase): Observable<CorporateModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CorporateModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CorporateModel>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getbyid(id: number | undefined): Observable<CorporateModel> {
        let url_ = this.baseUrl + "/api/auth/corporate/getbyid?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CorporateModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CorporateModel>;
        }));
    }

    protected processGetbyid(response: HttpResponseBase): Observable<CorporateModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CorporateModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CorporateModel>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: CorporateModel | undefined): Observable<CorporateModel> {
        let url_ = this.baseUrl + "/api/auth/corporate/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CorporateModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CorporateModel>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<CorporateModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CorporateModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CorporateModel>(null as any);
    }
}

@Injectable()
export class ReadApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getcorporatelist(): Observable<CorporateModel[]> {
        let url_ = this.baseUrl + "/api/auth/corporate/read/getcorporatelist";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetcorporatelist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetcorporatelist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CorporateModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CorporateModel[]>;
        }));
    }

    protected processGetcorporatelist(response: HttpResponseBase): Observable<CorporateModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CorporateModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CorporateModel[]>(null as any);
    }
}

@Injectable()
export class CountryApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getlist(): Observable<CountryModel[]> {
        let url_ = this.baseUrl + "/api/settings/place/country/getlist";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetlist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CountryModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CountryModel[]>;
        }));
    }

    protected processGetlist(response: HttpResponseBase): Observable<CountryModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CountryModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CountryModel[]>(null as any);
    }
}

@Injectable()
export class CreditcardpaymentApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    paywithcard(body: CreditCardPaymentRequestModel | undefined): Observable<CreditCardPaymentSummaryModel> {
        let url_ = this.baseUrl + "/api/finance/creditcardpayment/paywithcard";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPaywithcard(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPaywithcard(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreditCardPaymentSummaryModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreditCardPaymentSummaryModel>;
        }));
    }

    protected processPaywithcard(response: HttpResponseBase): Observable<CreditCardPaymentSummaryModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreditCardPaymentSummaryModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreditCardPaymentSummaryModel>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    paywithstoredcard(body: CreditCardMemberPaymentRequestModel | undefined): Observable<CreditCardPaymentSummaryModel> {
        let url_ = this.baseUrl + "/api/finance/creditcardpayment/paywithstoredcard";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPaywithstoredcard(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPaywithstoredcard(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreditCardPaymentSummaryModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreditCardPaymentSummaryModel>;
        }));
    }

    protected processPaywithstoredcard(response: HttpResponseBase): Observable<CreditCardPaymentSummaryModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreditCardPaymentSummaryModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreditCardPaymentSummaryModel>(null as any);
    }

    /**
     * @param transactionId (optional) 
     * @return Success
     */
    getpaymentstatus(transactionId: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/finance/creditcardpayment/getpaymentstatus?";
        if (transactionId === null)
            throw new Error("The parameter 'transactionId' cannot be null.");
        else if (transactionId !== undefined)
            url_ += "transactionId=" + encodeURIComponent("" + transactionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetpaymentstatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetpaymentstatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetpaymentstatus(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }
}

@Injectable()
export class DepositsApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addphysical(body: RequestModel | undefined): Observable<RequestModel> {
        let url_ = this.baseUrl + "/api/finance/deposits/addphysical";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddphysical(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddphysical(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RequestModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RequestModel>;
        }));
    }

    protected processAddphysical(response: HttpResponseBase): Observable<RequestModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RequestModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RequestModel>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    adddigital(body: RequestModel | undefined): Observable<RequestModel> {
        let url_ = this.baseUrl + "/api/finance/deposits/adddigital";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdddigital(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdddigital(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RequestModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RequestModel>;
        }));
    }

    protected processAdddigital(response: HttpResponseBase): Observable<RequestModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RequestModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RequestModel>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getbyid(id: number | undefined): Observable<RequestModel> {
        let url_ = this.baseUrl + "/api/finance/deposits/getbyid?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RequestModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RequestModel>;
        }));
    }

    protected processGetbyid(response: HttpResponseBase): Observable<RequestModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RequestModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RequestModel>(null as any);
    }

    getdetailbyid(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/finance/deposits/getdetailbyid?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetdetailbyid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetdetailbyid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetdetailbyid(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    getdigitalrequestlist(userId: number | undefined): Observable<RequestModel[]> {
        let url_ = this.baseUrl + "/api/finance/deposits/getdigitalrequestlist?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetdigitalrequestlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetdigitalrequestlist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RequestModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RequestModel[]>;
        }));
    }

    protected processGetdigitalrequestlist(response: HttpResponseBase): Observable<RequestModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RequestModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RequestModel[]>(null as any);
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    getphysicalrequestlist(userId: number | undefined): Observable<RequestModel[]> {
        let url_ = this.baseUrl + "/api/finance/deposits/getphysicalrequestlist?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetphysicalrequestlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetphysicalrequestlist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RequestModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RequestModel[]>;
        }));
    }

    protected processGetphysicalrequestlist(response: HttpResponseBase): Observable<RequestModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RequestModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RequestModel[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: RequestModel | undefined): Observable<RequestModel> {
        let url_ = this.baseUrl + "/api/finance/deposits/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RequestModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RequestModel>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<RequestModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RequestModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RequestModel>(null as any);
    }
}

@Injectable()
export class KnowledgebaseApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getlist(): Observable<KnowledgeBaseModel[]> {
        let url_ = this.baseUrl + "/api/contents/knowledgebase/getlist";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetlist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<KnowledgeBaseModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<KnowledgeBaseModel[]>;
        }));
    }

    protected processGetlist(response: HttpResponseBase): Observable<KnowledgeBaseModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(KnowledgeBaseModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<KnowledgeBaseModel[]>(null as any);
    }
}

@Injectable()
export class MatriksApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getturkeydebenturedata(body: string[] | undefined): Observable<DebentureModel> {
        let url_ = this.baseUrl + "/api/proxy/matriks/getturkeydebenturedata";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetturkeydebenturedata(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetturkeydebenturedata(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DebentureModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DebentureModel>;
        }));
    }

    protected processGetturkeydebenturedata(response: HttpResponseBase): Observable<DebentureModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DebentureModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DebentureModel>(null as any);
    }

    /**
     * @param graphic (optional) 
     * @param symbol (optional) 
     * @return Success
     */
    getgraphdata(graphic: MatriksGraphType | undefined, symbol: string | undefined): Observable<GraphicDataModel> {
        let url_ = this.baseUrl + "/api/proxy/matriks/getgraphdata?";
        if (graphic === null)
            throw new Error("The parameter 'graphic' cannot be null.");
        else if (graphic !== undefined)
            url_ += "graphic=" + encodeURIComponent("" + graphic) + "&";
        if (symbol === null)
            throw new Error("The parameter 'symbol' cannot be null.");
        else if (symbol !== undefined)
            url_ += "symbol=" + encodeURIComponent("" + symbol) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetgraphdata(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetgraphdata(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GraphicDataModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GraphicDataModel>;
        }));
    }

    protected processGetgraphdata(response: HttpResponseBase): Observable<GraphicDataModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GraphicDataModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GraphicDataModel>(null as any);
    }

    /**
     * @return Success
     */
    getmatriksnewsdata(): Observable<MatriksNewsModel> {
        let url_ = this.baseUrl + "/api/proxy/matriks/getmatriksnewsdata";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetmatriksnewsdata(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetmatriksnewsdata(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MatriksNewsModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MatriksNewsModel>;
        }));
    }

    protected processGetmatriksnewsdata(response: HttpResponseBase): Observable<MatriksNewsModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MatriksNewsModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MatriksNewsModel>(null as any);
    }

    /**
     * @param newsId (optional) 
     * @return Success
     */
    getmatriksnewsdetaildata(newsId: string | undefined): Observable<MatriksNewsModel> {
        let url_ = this.baseUrl + "/api/proxy/matriks/getmatriksnewsdetaildata?";
        if (newsId === null)
            throw new Error("The parameter 'newsId' cannot be null.");
        else if (newsId !== undefined)
            url_ += "newsId=" + encodeURIComponent("" + newsId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetmatriksnewsdetaildata(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetmatriksnewsdetaildata(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MatriksNewsModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MatriksNewsModel>;
        }));
    }

    protected processGetmatriksnewsdetaildata(response: HttpResponseBase): Observable<MatriksNewsModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MatriksNewsModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MatriksNewsModel>(null as any);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    getmatrikseconomynewsdata(startDate: moment.Moment | undefined, endDate: moment.Moment | undefined): Observable<MatriksEconomyNewsModel> {
        let url_ = this.baseUrl + "/api/proxy/matriks/getmatrikseconomynewsdata?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetmatrikseconomynewsdata(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetmatrikseconomynewsdata(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MatriksEconomyNewsModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MatriksEconomyNewsModel>;
        }));
    }

    protected processGetmatrikseconomynewsdata(response: HttpResponseBase): Observable<MatriksEconomyNewsModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MatriksEconomyNewsModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MatriksEconomyNewsModel>(null as any);
    }

    /**
     * @return Success
     */
    getmatriksmarketmodeldata(): Observable<MarketModel> {
        let url_ = this.baseUrl + "/api/proxy/matriks/getmatriksmarketmodeldata";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetmatriksmarketmodeldata(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetmatriksmarketmodeldata(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MarketModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MarketModel>;
        }));
    }

    protected processGetmatriksmarketmodeldata(response: HttpResponseBase): Observable<MarketModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MarketModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MarketModel>(null as any);
    }
}

@Injectable()
export class NotificationApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    getnotifications(userId: number | undefined): Observable<NotificationModel[]> {
        let url_ = this.baseUrl + "/api/contents/notification/getnotifications?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetnotifications(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetnotifications(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NotificationModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NotificationModel[]>;
        }));
    }

    protected processGetnotifications(response: HttpResponseBase): Observable<NotificationModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NotificationModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NotificationModel[]>(null as any);
    }

    /**
     * @param notificationId (optional) 
     * @return Success
     */
    deletenotification(notificationId: number | undefined): Observable<NotificationModel> {
        let url_ = this.baseUrl + "/api/contents/notification/deletenotification?";
        if (notificationId === null)
            throw new Error("The parameter 'notificationId' cannot be null.");
        else if (notificationId !== undefined)
            url_ += "notificationId=" + encodeURIComponent("" + notificationId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletenotification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletenotification(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NotificationModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NotificationModel>;
        }));
    }

    protected processDeletenotification(response: HttpResponseBase): Observable<NotificationModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NotificationModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NotificationModel>(null as any);
    }
}

@Injectable()
export class OrderApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    adddigitalorder(body: RequestCompleteDigitalOrderModel | undefined): Observable<RequestCompleteDigitalOrderModel> {
        let url_ = this.baseUrl + "/api/commerce/order/adddigitalorder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdddigitalorder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdddigitalorder(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RequestCompleteDigitalOrderModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RequestCompleteDigitalOrderModel>;
        }));
    }

    protected processAdddigitalorder(response: HttpResponseBase): Observable<RequestCompleteDigitalOrderModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RequestCompleteDigitalOrderModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RequestCompleteDigitalOrderModel>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addphysicalorder(body: RequestPhysicalOrderModel | undefined): Observable<ResponsePhysicalOrderModel> {
        let url_ = this.baseUrl + "/api/commerce/order/addphysicalorder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddphysicalorder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddphysicalorder(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponsePhysicalOrderModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponsePhysicalOrderModel>;
        }));
    }

    protected processAddphysicalorder(response: HttpResponseBase): Observable<ResponsePhysicalOrderModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponsePhysicalOrderModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponsePhysicalOrderModel>(null as any);
    }

    /**
     * @param orderId (optional) 
     * @return Success
     */
    canceldigitalorder(orderId: number | undefined): Observable<ResponseDigitalOrderModel> {
        let url_ = this.baseUrl + "/api/commerce/order/canceldigitalorder?";
        if (orderId === null)
            throw new Error("The parameter 'orderId' cannot be null.");
        else if (orderId !== undefined)
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCanceldigitalorder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCanceldigitalorder(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseDigitalOrderModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseDigitalOrderModel>;
        }));
    }

    protected processCanceldigitalorder(response: HttpResponseBase): Observable<ResponseDigitalOrderModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseDigitalOrderModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseDigitalOrderModel>(null as any);
    }

    /**
     * @param orderId (optional) 
     * @return Success
     */
    cancelphysicalorder(orderId: number | undefined): Observable<ResponsePhysicalOrderModel> {
        let url_ = this.baseUrl + "/api/commerce/order/cancelphysicalorder?";
        if (orderId === null)
            throw new Error("The parameter 'orderId' cannot be null.");
        else if (orderId !== undefined)
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancelphysicalorder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelphysicalorder(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponsePhysicalOrderModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponsePhysicalOrderModel>;
        }));
    }

    protected processCancelphysicalorder(response: HttpResponseBase): Observable<ResponsePhysicalOrderModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponsePhysicalOrderModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponsePhysicalOrderModel>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    completedigitalorder(body: CompleDigitalOrderModel | undefined): Observable<ResponseDigitalOrderModel> {
        let url_ = this.baseUrl + "/api/commerce/order/completedigitalorder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCompletedigitalorder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCompletedigitalorder(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseDigitalOrderModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseDigitalOrderModel>;
        }));
    }

    protected processCompletedigitalorder(response: HttpResponseBase): Observable<ResponseDigitalOrderModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseDigitalOrderModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseDigitalOrderModel>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    completephysicalorder(body: ComplePhysicalOrderModel | undefined): Observable<ResponsePhysicalOrderModel> {
        let url_ = this.baseUrl + "/api/commerce/order/completephysicalorder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCompletephysicalorder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCompletephysicalorder(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponsePhysicalOrderModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponsePhysicalOrderModel>;
        }));
    }

    protected processCompletephysicalorder(response: HttpResponseBase): Observable<ResponsePhysicalOrderModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponsePhysicalOrderModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponsePhysicalOrderModel>(null as any);
    }

    /**
     * @param orderId (optional) 
     * @return Success
     */
    getdigitalorderbyid(orderId: number | undefined): Observable<ResponseDigitalOrderModel> {
        let url_ = this.baseUrl + "/api/commerce/order/getdigitalorderbyid?";
        if (orderId === null)
            throw new Error("The parameter 'orderId' cannot be null.");
        else if (orderId !== undefined)
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetdigitalorderbyid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetdigitalorderbyid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseDigitalOrderModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseDigitalOrderModel>;
        }));
    }

    protected processGetdigitalorderbyid(response: HttpResponseBase): Observable<ResponseDigitalOrderModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseDigitalOrderModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseDigitalOrderModel>(null as any);
    }

    /**
     * @param orderId (optional) 
     * @return Success
     */
    getphysicalorderbyid(orderId: number | undefined): Observable<RequestPhysicalOrderModel> {
        let url_ = this.baseUrl + "/api/commerce/order/getphysicalorderbyid?";
        if (orderId === null)
            throw new Error("The parameter 'orderId' cannot be null.");
        else if (orderId !== undefined)
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetphysicalorderbyid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetphysicalorderbyid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RequestPhysicalOrderModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RequestPhysicalOrderModel>;
        }));
    }

    protected processGetphysicalorderbyid(response: HttpResponseBase): Observable<RequestPhysicalOrderModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RequestPhysicalOrderModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RequestPhysicalOrderModel>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updatedigitalorder(body: ResponseDigitalOrderModel | undefined): Observable<ResponseDigitalOrderModel> {
        let url_ = this.baseUrl + "/api/commerce/order/updatedigitalorder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatedigitalorder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatedigitalorder(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseDigitalOrderModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseDigitalOrderModel>;
        }));
    }

    protected processUpdatedigitalorder(response: HttpResponseBase): Observable<ResponseDigitalOrderModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseDigitalOrderModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseDigitalOrderModel>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updatephysicalorder(body: ResponsePhysicalOrderModel | undefined): Observable<ResponsePhysicalOrderModel> {
        let url_ = this.baseUrl + "/api/commerce/order/updatephysicalorder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatephysicalorder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatephysicalorder(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponsePhysicalOrderModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponsePhysicalOrderModel>;
        }));
    }

    protected processUpdatephysicalorder(response: HttpResponseBase): Observable<ResponsePhysicalOrderModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponsePhysicalOrderModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponsePhysicalOrderModel>(null as any);
    }
}

@Injectable()
export class PostApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getlist(): Observable<PostModel[]> {
        let url_ = this.baseUrl + "/api/contents/post/getlist";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetlist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PostModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PostModel[]>;
        }));
    }

    protected processGetlist(response: HttpResponseBase): Observable<PostModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PostModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PostModel[]>(null as any);
    }
}

@Injectable()
export class ProvinceApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getlist(): Observable<ProvinceModel[]> {
        let url_ = this.baseUrl + "/api/settings/place/province/getlist";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetlist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProvinceModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProvinceModel[]>;
        }));
    }

    protected processGetlist(response: HttpResponseBase): Observable<ProvinceModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProvinceModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProvinceModel[]>(null as any);
    }
}

@Injectable()
export class RetailApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    add(body: Retail | undefined): Observable<RetailModel> {
        let url_ = this.baseUrl + "/api/auth/retail/add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RetailModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RetailModel>;
        }));
    }

    protected processAdd(response: HttpResponseBase): Observable<RetailModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RetailModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RetailModel>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getbyid(id: number | undefined): Observable<RetailModel> {
        let url_ = this.baseUrl + "/api/auth/retail/getbyid?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RetailModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RetailModel>;
        }));
    }

    protected processGetbyid(response: HttpResponseBase): Observable<RetailModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RetailModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RetailModel>(null as any);
    }

    /**
     * @return Success
     */
    read(): Observable<RetailModel[]> {
        let url_ = this.baseUrl + "/api/auth/retail/read";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRead(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RetailModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RetailModel[]>;
        }));
    }

    protected processRead(response: HttpResponseBase): Observable<RetailModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RetailModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RetailModel[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: Retail | undefined): Observable<RetailModel> {
        let url_ = this.baseUrl + "/api/auth/retail/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RetailModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RetailModel>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<RetailModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RetailModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RetailModel>(null as any);
    }
}

@Injectable()
export class RssfeedApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getlist(): Observable<RssFeedModel[]> {
        let url_ = this.baseUrl + "/api/contents/rssfeed/getlist";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetlist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RssFeedModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RssFeedModel[]>;
        }));
    }

    protected processGetlist(response: HttpResponseBase): Observable<RssFeedModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RssFeedModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RssFeedModel[]>(null as any);
    }
}

@Injectable()
export class SettingApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getlist(): Observable<SettingModel[]> {
        let url_ = this.baseUrl + "/api/settings/core/setting/getlist";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetlist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SettingModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SettingModel[]>;
        }));
    }

    protected processGetlist(response: HttpResponseBase): Observable<SettingModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SettingModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SettingModel[]>(null as any);
    }
}

@Injectable()
export class SlideApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param slideTypeId (optional) 
     * @return Success
     */
    getslides(slideTypeId: number | undefined): Observable<SlideModel[]> {
        let url_ = this.baseUrl + "/api/contents/slide/getslides?";
        if (slideTypeId === null)
            throw new Error("The parameter 'slideTypeId' cannot be null.");
        else if (slideTypeId !== undefined)
            url_ += "slideTypeId=" + encodeURIComponent("" + slideTypeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetslides(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetslides(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SlideModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SlideModel[]>;
        }));
    }

    protected processGetslides(response: HttpResponseBase): Observable<SlideModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SlideModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SlideModel[]>(null as any);
    }
}

@Injectable()
export class StaticpageApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getlist(): Observable<StaticPageModel[]> {
        let url_ = this.baseUrl + "/api/contents/staticpage/getlist";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetlist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StaticPageModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StaticPageModel[]>;
        }));
    }

    protected processGetlist(response: HttpResponseBase): Observable<StaticPageModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(StaticPageModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StaticPageModel[]>(null as any);
    }
}

@Injectable()
export class SymbolsApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getsymbollist(): Observable<SymbolModel[]> {
        let url_ = this.baseUrl + "/api/finance/symbols/getsymbollist";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetsymbollist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetsymbollist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SymbolModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SymbolModel[]>;
        }));
    }

    protected processGetsymbollist(response: HttpResponseBase): Observable<SymbolModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SymbolModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SymbolModel[]>(null as any);
    }

    /**
     * @return Success
     */
    getsymbolrates(): Observable<SymbolRateModel[]> {
        let url_ = this.baseUrl + "/api/finance/symbols/getsymbolrates";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetsymbolrates(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetsymbolrates(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SymbolRateModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SymbolRateModel[]>;
        }));
    }

    protected processGetsymbolrates(response: HttpResponseBase): Observable<SymbolRateModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SymbolRateModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SymbolRateModel[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addsymbolalarm(body: SymbolAlarmModel | undefined): Observable<SymbolAlarmModel> {
        let url_ = this.baseUrl + "/api/finance/symbols/addsymbolalarm";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddsymbolalarm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddsymbolalarm(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SymbolAlarmModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SymbolAlarmModel>;
        }));
    }

    protected processAddsymbolalarm(response: HttpResponseBase): Observable<SymbolAlarmModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SymbolAlarmModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SymbolAlarmModel>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deletesymbolalarm(body: SymbolAlarmModel | undefined): Observable<SymbolAlarmModel> {
        let url_ = this.baseUrl + "/api/finance/symbols/deletesymbolalarm";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletesymbolalarm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletesymbolalarm(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SymbolAlarmModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SymbolAlarmModel>;
        }));
    }

    protected processDeletesymbolalarm(response: HttpResponseBase): Observable<SymbolAlarmModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SymbolAlarmModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SymbolAlarmModel>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    togglesymbolvote(body: SymbolVoteRequestModel | undefined): Observable<SymbolVoteSummaryModel> {
        let url_ = this.baseUrl + "/api/finance/symbols/togglesymbolvote";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTogglesymbolvote(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTogglesymbolvote(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SymbolVoteSummaryModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SymbolVoteSummaryModel>;
        }));
    }

    protected processTogglesymbolvote(response: HttpResponseBase): Observable<SymbolVoteSummaryModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SymbolVoteSummaryModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SymbolVoteSummaryModel>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getsymbolvotesummary(body: SymbolVoteRequestModel | undefined): Observable<SymbolVoteSummaryModel> {
        let url_ = this.baseUrl + "/api/finance/symbols/getsymbolvotesummary";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetsymbolvotesummary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetsymbolvotesummary(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SymbolVoteSummaryModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SymbolVoteSummaryModel>;
        }));
    }

    protected processGetsymbolvotesummary(response: HttpResponseBase): Observable<SymbolVoteSummaryModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SymbolVoteSummaryModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SymbolVoteSummaryModel>(null as any);
    }
}

@Injectable()
export class TradingviewApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    advancedchart(): Observable<void> {
        let url_ = this.baseUrl + "/api/proxy/tradingview/advancedchart";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdvancedchart(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdvancedchart(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAdvancedchart(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    technicalanalysis(): Observable<void> {
        let url_ = this.baseUrl + "/api/proxy/tradingview/technicalanalysis";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTechnicalanalysis(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTechnicalanalysis(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTechnicalanalysis(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class TransactionsApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    gettransactionhistory(body: TransactionRequestModel | undefined): Observable<TransactionModel[]> {
        let url_ = this.baseUrl + "/api/finance/transactions/gettransactionhistory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGettransactionhistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGettransactionhistory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TransactionModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TransactionModel[]>;
        }));
    }

    protected processGettransactionhistory(response: HttpResponseBase): Observable<TransactionModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TransactionModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransactionModel[]>(null as any);
    }
}

@Injectable()
export class UserdocumentApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    add(body: UserDocument | undefined): Observable<UserDocumentModel> {
        let url_ = this.baseUrl + "/api/auth/userdocument/add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDocumentModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDocumentModel>;
        }));
    }

    protected processAdd(response: HttpResponseBase): Observable<UserDocumentModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDocumentModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDocumentModel>(null as any);
    }

    /**
     * @return Success
     */
    list(): Observable<UserDocumentModel[]> {
        let url_ = this.baseUrl + "/api/auth/userdocument/list";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDocumentModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDocumentModel[]>;
        }));
    }

    protected processList(response: HttpResponseBase): Observable<UserDocumentModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserDocumentModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDocumentModel[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UserDocument | undefined): Observable<UserDocumentModel> {
        let url_ = this.baseUrl + "/api/auth/userdocument/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDocumentModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDocumentModel>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UserDocumentModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDocumentModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDocumentModel>(null as any);
    }

    /**
     * @param file (optional) 
     * @return Success
     */
    uploaddocument(file: FileParameter | undefined): Observable<Media> {
        let url_ = this.baseUrl + "/api/auth/userdocument/uploaddocument";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploaddocument(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploaddocument(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Media>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Media>;
        }));
    }

    protected processUploaddocument(response: HttpResponseBase): Observable<Media> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Media.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Media>(null as any);
    }
}

@Injectable()
export class WithdrawalsApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    preparedigital(body: RequestModel | undefined): Observable<RequestModel> {
        let url_ = this.baseUrl + "/api/finance/withdrawals/preparedigital";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPreparedigital(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPreparedigital(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RequestModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RequestModel>;
        }));
    }

    protected processPreparedigital(response: HttpResponseBase): Observable<RequestModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RequestModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RequestModel>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addphysical(body: RequestModel | undefined): Observable<RequestModel> {
        let url_ = this.baseUrl + "/api/finance/withdrawals/addphysical";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddphysical(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddphysical(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RequestModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RequestModel>;
        }));
    }

    protected processAddphysical(response: HttpResponseBase): Observable<RequestModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RequestModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RequestModel>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    adddigital(body: RequestModel | undefined): Observable<RequestModel> {
        let url_ = this.baseUrl + "/api/finance/withdrawals/adddigital";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdddigital(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdddigital(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RequestModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RequestModel>;
        }));
    }

    protected processAdddigital(response: HttpResponseBase): Observable<RequestModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RequestModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RequestModel>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getbyid(id: number | undefined): Observable<RequestModel> {
        let url_ = this.baseUrl + "/api/finance/withdrawals/getbyid?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RequestModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RequestModel>;
        }));
    }

    protected processGetbyid(response: HttpResponseBase): Observable<RequestModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RequestModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RequestModel>(null as any);
    }

    getdetailbyid(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/finance/withdrawals/getdetailbyid?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetdetailbyid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetdetailbyid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetdetailbyid(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    getdigitalrequestlist(userId: number | undefined): Observable<RequestModel[]> {
        let url_ = this.baseUrl + "/api/finance/withdrawals/getdigitalrequestlist?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetdigitalrequestlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetdigitalrequestlist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RequestModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RequestModel[]>;
        }));
    }

    protected processGetdigitalrequestlist(response: HttpResponseBase): Observable<RequestModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RequestModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RequestModel[]>(null as any);
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    getphysicalrequestlist(userId: number | undefined): Observable<RequestModel[]> {
        let url_ = this.baseUrl + "/api/finance/withdrawals/getphysicalrequestlist?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetphysicalrequestlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetphysicalrequestlist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RequestModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RequestModel[]>;
        }));
    }

    protected processGetphysicalrequestlist(response: HttpResponseBase): Observable<RequestModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RequestModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RequestModel[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: Request | undefined): Observable<RequestModel> {
        let url_ = this.baseUrl + "/api/finance/withdrawals/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RequestModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RequestModel>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<RequestModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RequestModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RequestModel>(null as any);
    }
}

export class Address implements IAddress {
    id?: number;
    name?: string | undefined;
    contactName?: string | undefined;
    phone?: string | undefined;
    addressLine?: string | undefined;
    directions?: string | undefined;
    latitude?: number;
    longitude?: number;
    neighborhoodId?: number | undefined;
    neighborhood?: Neighborhood;
    districtId?: number | undefined;
    district?: District;
    provinceId?: number;
    province?: Province;
    countryId?: string | undefined;
    country?: Country;

    constructor(data?: IAddress) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.name = _data["Name"];
            this.contactName = _data["ContactName"];
            this.phone = _data["Phone"];
            this.addressLine = _data["AddressLine"];
            this.directions = _data["Directions"];
            this.latitude = _data["Latitude"];
            this.longitude = _data["Longitude"];
            this.neighborhoodId = _data["NeighborhoodId"];
            this.neighborhood = _data["Neighborhood"] ? Neighborhood.fromJS(_data["Neighborhood"]) : <any>undefined;
            this.districtId = _data["DistrictId"];
            this.district = _data["District"] ? District.fromJS(_data["District"]) : <any>undefined;
            this.provinceId = _data["ProvinceId"];
            this.province = _data["Province"] ? Province.fromJS(_data["Province"]) : <any>undefined;
            this.countryId = _data["CountryId"];
            this.country = _data["Country"] ? Country.fromJS(_data["Country"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Address {
        data = typeof data === 'object' ? data : {};
        let result = new Address();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Name"] = this.name;
        data["ContactName"] = this.contactName;
        data["Phone"] = this.phone;
        data["AddressLine"] = this.addressLine;
        data["Directions"] = this.directions;
        data["Latitude"] = this.latitude;
        data["Longitude"] = this.longitude;
        data["NeighborhoodId"] = this.neighborhoodId;
        data["Neighborhood"] = this.neighborhood ? this.neighborhood.toJSON() : <any>undefined;
        data["DistrictId"] = this.districtId;
        data["District"] = this.district ? this.district.toJSON() : <any>undefined;
        data["ProvinceId"] = this.provinceId;
        data["Province"] = this.province ? this.province.toJSON() : <any>undefined;
        data["CountryId"] = this.countryId;
        data["Country"] = this.country ? this.country.toJSON() : <any>undefined;
        return data;
    }
}

export interface IAddress {
    id?: number;
    name?: string | undefined;
    contactName?: string | undefined;
    phone?: string | undefined;
    addressLine?: string | undefined;
    directions?: string | undefined;
    latitude?: number;
    longitude?: number;
    neighborhoodId?: number | undefined;
    neighborhood?: Neighborhood;
    districtId?: number | undefined;
    district?: District;
    provinceId?: number;
    province?: Province;
    countryId?: string | undefined;
    country?: Country;
}

export class AnalysisModel implements IAnalysisModel {
    title!: string;
    subTitle?: string | undefined;
    slug?: string | undefined;
    metaKeywords?: string | undefined;
    metaDescription?: string | undefined;
    body?: string | undefined;
    mediaId?: number | undefined;
    media?: MediaModel;
    isPublished?: boolean;
    publishedOn?: moment.Moment | undefined;
    publishedTill?: moment.Moment | undefined;
    symbolId?: number | undefined;
    symbol?: SymbolModel;

    constructor(data?: IAnalysisModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["Title"];
            this.subTitle = _data["SubTitle"];
            this.slug = _data["Slug"];
            this.metaKeywords = _data["MetaKeywords"];
            this.metaDescription = _data["MetaDescription"];
            this.body = _data["Body"];
            this.mediaId = _data["MediaId"];
            this.media = _data["Media"] ? MediaModel.fromJS(_data["Media"]) : <any>undefined;
            this.isPublished = _data["IsPublished"];
            this.publishedOn = _data["PublishedOn"] ? moment(_data["PublishedOn"].toString()) : <any>undefined;
            this.publishedTill = _data["PublishedTill"] ? moment(_data["PublishedTill"].toString()) : <any>undefined;
            this.symbolId = _data["SymbolId"];
            this.symbol = _data["Symbol"] ? SymbolModel.fromJS(_data["Symbol"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AnalysisModel {
        data = typeof data === 'object' ? data : {};
        let result = new AnalysisModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Title"] = this.title;
        data["SubTitle"] = this.subTitle;
        data["Slug"] = this.slug;
        data["MetaKeywords"] = this.metaKeywords;
        data["MetaDescription"] = this.metaDescription;
        data["Body"] = this.body;
        data["MediaId"] = this.mediaId;
        data["Media"] = this.media ? this.media.toJSON() : <any>undefined;
        data["IsPublished"] = this.isPublished;
        data["PublishedOn"] = this.publishedOn ? this.publishedOn.toISOString() : <any>undefined;
        data["PublishedTill"] = this.publishedTill ? this.publishedTill.toISOString() : <any>undefined;
        data["SymbolId"] = this.symbolId;
        data["Symbol"] = this.symbol ? this.symbol.toJSON() : <any>undefined;
        return data;
    }
}

export interface IAnalysisModel {
    title: string;
    subTitle?: string | undefined;
    slug?: string | undefined;
    metaKeywords?: string | undefined;
    metaDescription?: string | undefined;
    body?: string | undefined;
    mediaId?: number | undefined;
    media?: MediaModel;
    isPublished?: boolean;
    publishedOn?: moment.Moment | undefined;
    publishedTill?: moment.Moment | undefined;
    symbolId?: number | undefined;
    symbol?: SymbolModel;
}

export class Asset implements IAsset {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    isDeleted?: boolean;
    userId?: number;
    user?: User;
    symbolId?: number;
    symbol?: Symbol;
    quantity?: number;
    price?: number;

    constructor(data?: IAsset) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.createdOn = _data["CreatedOn"] ? moment(_data["CreatedOn"].toString()) : <any>undefined;
            this.createdById = _data["CreatedById"];
            this.updatedOn = _data["UpdatedOn"] ? moment(_data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedById = _data["UpdatedById"];
            this.deletedOn = _data["DeletedOn"] ? moment(_data["DeletedOn"].toString()) : <any>undefined;
            this.deletedById = _data["DeletedById"];
            this.isDeleted = _data["IsDeleted"];
            this.userId = _data["UserId"];
            this.user = _data["User"] ? User.fromJS(_data["User"]) : <any>undefined;
            this.symbolId = _data["SymbolId"];
            this.symbol = _data["Symbol"] ? Symbol.fromJS(_data["Symbol"]) : <any>undefined;
            this.quantity = _data["Quantity"];
            this.price = _data["Price"];
        }
    }

    static fromJS(data: any): Asset {
        data = typeof data === 'object' ? data : {};
        let result = new Asset();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedById"] = this.createdById;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["DeletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        data["DeletedById"] = this.deletedById;
        data["IsDeleted"] = this.isDeleted;
        data["UserId"] = this.userId;
        data["User"] = this.user ? this.user.toJSON() : <any>undefined;
        data["SymbolId"] = this.symbolId;
        data["Symbol"] = this.symbol ? this.symbol.toJSON() : <any>undefined;
        data["Quantity"] = this.quantity;
        data["Price"] = this.price;
        return data;
    }
}

export interface IAsset {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    isDeleted?: boolean;
    userId?: number;
    user?: User;
    symbolId?: number;
    symbol?: Symbol;
    quantity?: number;
    price?: number;
}

export class AssetModel implements IAssetModel {
    id?: number;
    userId?: number;
    user?: UserModel;
    symbolId?: number;
    symbol?: SymbolModel;
    quantity?: number;
    price?: number;

    constructor(data?: IAssetModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.userId = _data["UserId"];
            this.user = _data["User"] ? UserModel.fromJS(_data["User"]) : <any>undefined;
            this.symbolId = _data["SymbolId"];
            this.symbol = _data["Symbol"] ? SymbolModel.fromJS(_data["Symbol"]) : <any>undefined;
            this.quantity = _data["Quantity"];
            this.price = _data["Price"];
        }
    }

    static fromJS(data: any): AssetModel {
        data = typeof data === 'object' ? data : {};
        let result = new AssetModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["UserId"] = this.userId;
        data["User"] = this.user ? this.user.toJSON() : <any>undefined;
        data["SymbolId"] = this.symbolId;
        data["Symbol"] = this.symbol ? this.symbol.toJSON() : <any>undefined;
        data["Quantity"] = this.quantity;
        data["Price"] = this.price;
        return data;
    }
}

export interface IAssetModel {
    id?: number;
    userId?: number;
    user?: UserModel;
    symbolId?: number;
    symbol?: SymbolModel;
    quantity?: number;
    price?: number;
}

export class AuthenticatorModel implements IAuthenticatorModel {
    authenticatorKey?: string | undefined;

    constructor(data?: IAuthenticatorModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.authenticatorKey = _data["AuthenticatorKey"];
        }
    }

    static fromJS(data: any): AuthenticatorModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticatorModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["AuthenticatorKey"] = this.authenticatorKey;
        return data;
    }
}

export interface IAuthenticatorModel {
    authenticatorKey?: string | undefined;
}

export class Bank implements IBank {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    isDeleted?: boolean;
    name!: string;
    logoId?: number | undefined;
    logo?: Media;
    description?: string | undefined;
    isActive?: boolean;

    constructor(data?: IBank) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.createdOn = _data["CreatedOn"] ? moment(_data["CreatedOn"].toString()) : <any>undefined;
            this.createdById = _data["CreatedById"];
            this.updatedOn = _data["UpdatedOn"] ? moment(_data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedById = _data["UpdatedById"];
            this.deletedOn = _data["DeletedOn"] ? moment(_data["DeletedOn"].toString()) : <any>undefined;
            this.deletedById = _data["DeletedById"];
            this.isDeleted = _data["IsDeleted"];
            this.name = _data["Name"];
            this.logoId = _data["LogoId"];
            this.logo = _data["Logo"] ? Media.fromJS(_data["Logo"]) : <any>undefined;
            this.description = _data["Description"];
            this.isActive = _data["IsActive"];
        }
    }

    static fromJS(data: any): Bank {
        data = typeof data === 'object' ? data : {};
        let result = new Bank();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedById"] = this.createdById;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["DeletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        data["DeletedById"] = this.deletedById;
        data["IsDeleted"] = this.isDeleted;
        data["Name"] = this.name;
        data["LogoId"] = this.logoId;
        data["Logo"] = this.logo ? this.logo.toJSON() : <any>undefined;
        data["Description"] = this.description;
        data["IsActive"] = this.isActive;
        return data;
    }
}

export interface IBank {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    isDeleted?: boolean;
    name: string;
    logoId?: number | undefined;
    logo?: Media;
    description?: string | undefined;
    isActive?: boolean;
}

export class BankModel implements IBankModel {
    id?: number;
    name?: string | undefined;
    description?: string | undefined;
    isActive?: boolean;

    constructor(data?: IBankModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.name = _data["Name"];
            this.description = _data["Description"];
            this.isActive = _data["IsActive"];
        }
    }

    static fromJS(data: any): BankModel {
        data = typeof data === 'object' ? data : {};
        let result = new BankModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Name"] = this.name;
        data["Description"] = this.description;
        data["IsActive"] = this.isActive;
        return data;
    }
}

export interface IBankModel {
    id?: number;
    name?: string | undefined;
    description?: string | undefined;
    isActive?: boolean;
}

export enum BloodType {
    OPositive = "OPositive",
    APositive = "APositive",
    BPositive = "BPositive",
    ABPositive = "ABPositive",
    ABNegative = "ABNegative",
    ANegative = "ANegative",
    BNegative = "BNegative",
    ONegative = "ONegative",
}

export class Bonus implements IBonus {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    isDeleted?: boolean;
    userId?: number;
    user?: User;
    symbolId?: number;
    symbol?: Symbol;
    quantity?: number;
    price?: number;
    isUsed?: boolean;
    isActive?: boolean;

    constructor(data?: IBonus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.createdOn = _data["CreatedOn"] ? moment(_data["CreatedOn"].toString()) : <any>undefined;
            this.createdById = _data["CreatedById"];
            this.updatedOn = _data["UpdatedOn"] ? moment(_data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedById = _data["UpdatedById"];
            this.deletedOn = _data["DeletedOn"] ? moment(_data["DeletedOn"].toString()) : <any>undefined;
            this.deletedById = _data["DeletedById"];
            this.isDeleted = _data["IsDeleted"];
            this.userId = _data["UserId"];
            this.user = _data["User"] ? User.fromJS(_data["User"]) : <any>undefined;
            this.symbolId = _data["SymbolId"];
            this.symbol = _data["Symbol"] ? Symbol.fromJS(_data["Symbol"]) : <any>undefined;
            this.quantity = _data["Quantity"];
            this.price = _data["Price"];
            this.isUsed = _data["IsUsed"];
            this.isActive = _data["IsActive"];
        }
    }

    static fromJS(data: any): Bonus {
        data = typeof data === 'object' ? data : {};
        let result = new Bonus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedById"] = this.createdById;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["DeletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        data["DeletedById"] = this.deletedById;
        data["IsDeleted"] = this.isDeleted;
        data["UserId"] = this.userId;
        data["User"] = this.user ? this.user.toJSON() : <any>undefined;
        data["SymbolId"] = this.symbolId;
        data["Symbol"] = this.symbol ? this.symbol.toJSON() : <any>undefined;
        data["Quantity"] = this.quantity;
        data["Price"] = this.price;
        data["IsUsed"] = this.isUsed;
        data["IsActive"] = this.isActive;
        return data;
    }
}

export interface IBonus {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    isDeleted?: boolean;
    userId?: number;
    user?: User;
    symbolId?: number;
    symbol?: Symbol;
    quantity?: number;
    price?: number;
    isUsed?: boolean;
    isActive?: boolean;
}

export class Category implements ICategory {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    isDeleted?: boolean;
    name?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isPublished?: boolean;
    mediaId?: number | undefined;
    media?: Media;
    parentId?: number | undefined;
    parent?: Category;
    yatirimimId?: number | undefined;
    readonly children?: Category[] | undefined;
    readonly productCategories?: ProductCategory[] | undefined;

    constructor(data?: ICategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.createdOn = _data["CreatedOn"] ? moment(_data["CreatedOn"].toString()) : <any>undefined;
            this.createdById = _data["CreatedById"];
            this.updatedOn = _data["UpdatedOn"] ? moment(_data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedById = _data["UpdatedById"];
            this.deletedOn = _data["DeletedOn"] ? moment(_data["DeletedOn"].toString()) : <any>undefined;
            this.deletedById = _data["DeletedById"];
            this.isDeleted = _data["IsDeleted"];
            this.name = _data["Name"];
            this.description = _data["Description"];
            this.displayOrder = _data["DisplayOrder"];
            this.isPublished = _data["IsPublished"];
            this.mediaId = _data["MediaId"];
            this.media = _data["Media"] ? Media.fromJS(_data["Media"]) : <any>undefined;
            this.parentId = _data["ParentId"];
            this.parent = _data["Parent"] ? Category.fromJS(_data["Parent"]) : <any>undefined;
            this.yatirimimId = _data["YatirimimId"];
            if (Array.isArray(_data["Children"])) {
                (<any>this).children = [] as any;
                for (let item of _data["Children"])
                    (<any>this).children!.push(Category.fromJS(item));
            }
            if (Array.isArray(_data["ProductCategories"])) {
                (<any>this).productCategories = [] as any;
                for (let item of _data["ProductCategories"])
                    (<any>this).productCategories!.push(ProductCategory.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Category {
        data = typeof data === 'object' ? data : {};
        let result = new Category();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedById"] = this.createdById;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["DeletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        data["DeletedById"] = this.deletedById;
        data["IsDeleted"] = this.isDeleted;
        data["Name"] = this.name;
        data["Description"] = this.description;
        data["DisplayOrder"] = this.displayOrder;
        data["IsPublished"] = this.isPublished;
        data["MediaId"] = this.mediaId;
        data["Media"] = this.media ? this.media.toJSON() : <any>undefined;
        data["ParentId"] = this.parentId;
        data["Parent"] = this.parent ? this.parent.toJSON() : <any>undefined;
        data["YatirimimId"] = this.yatirimimId;
        if (Array.isArray(this.children)) {
            data["Children"] = [];
            for (let item of this.children)
                data["Children"].push(item.toJSON());
        }
        if (Array.isArray(this.productCategories)) {
            data["ProductCategories"] = [];
            for (let item of this.productCategories)
                data["ProductCategories"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICategory {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    isDeleted?: boolean;
    name?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isPublished?: boolean;
    mediaId?: number | undefined;
    media?: Media;
    parentId?: number | undefined;
    parent?: Category;
    yatirimimId?: number | undefined;
    children?: Category[] | undefined;
    productCategories?: ProductCategory[] | undefined;
}

export class CommissionModel implements ICommissionModel {
    id?: number;
    name?: string | undefined;
    symbolId?: number;
    symbol?: SymbolModel;
    commissionType?: CommissionType;
    commissionRate?: number;
    commissionValue?: number;

    constructor(data?: ICommissionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.name = _data["Name"];
            this.symbolId = _data["SymbolId"];
            this.symbol = _data["Symbol"] ? SymbolModel.fromJS(_data["Symbol"]) : <any>undefined;
            this.commissionType = _data["CommissionType"];
            this.commissionRate = _data["CommissionRate"];
            this.commissionValue = _data["CommissionValue"];
        }
    }

    static fromJS(data: any): CommissionModel {
        data = typeof data === 'object' ? data : {};
        let result = new CommissionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Name"] = this.name;
        data["SymbolId"] = this.symbolId;
        data["Symbol"] = this.symbol ? this.symbol.toJSON() : <any>undefined;
        data["CommissionType"] = this.commissionType;
        data["CommissionRate"] = this.commissionRate;
        data["CommissionValue"] = this.commissionValue;
        return data;
    }
}

export interface ICommissionModel {
    id?: number;
    name?: string | undefined;
    symbolId?: number;
    symbol?: SymbolModel;
    commissionType?: CommissionType;
    commissionRate?: number;
    commissionValue?: number;
}

export enum CommissionType {
    Buy = "Buy",
    Sell = "Sell",
}

export class CompleDigitalOrderModel implements ICompleDigitalOrderModel {
    orderId?: number;
    paymentType?: PaymentType;
    sourceAssetId?: number;
    targetAssetId?: number;

    constructor(data?: ICompleDigitalOrderModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.orderId = _data["OrderId"];
            this.paymentType = _data["PaymentType"];
            this.sourceAssetId = _data["SourceAssetId"];
            this.targetAssetId = _data["TargetAssetId"];
        }
    }

    static fromJS(data: any): CompleDigitalOrderModel {
        data = typeof data === 'object' ? data : {};
        let result = new CompleDigitalOrderModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["OrderId"] = this.orderId;
        data["PaymentType"] = this.paymentType;
        data["SourceAssetId"] = this.sourceAssetId;
        data["TargetAssetId"] = this.targetAssetId;
        return data;
    }
}

export interface ICompleDigitalOrderModel {
    orderId?: number;
    paymentType?: PaymentType;
    sourceAssetId?: number;
    targetAssetId?: number;
}

export class ComplePhysicalOrderModel implements IComplePhysicalOrderModel {
    orderId?: number;
    paymentType?: PaymentType;
    sourceAssetId?: number;

    constructor(data?: IComplePhysicalOrderModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.orderId = _data["OrderId"];
            this.paymentType = _data["PaymentType"];
            this.sourceAssetId = _data["SourceAssetId"];
        }
    }

    static fromJS(data: any): ComplePhysicalOrderModel {
        data = typeof data === 'object' ? data : {};
        let result = new ComplePhysicalOrderModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["OrderId"] = this.orderId;
        data["PaymentType"] = this.paymentType;
        data["SourceAssetId"] = this.sourceAssetId;
        return data;
    }
}

export interface IComplePhysicalOrderModel {
    orderId?: number;
    paymentType?: PaymentType;
    sourceAssetId?: number;
}

export enum ContactType {
    MailPrimary = "MailPrimary",
    MailWork = "MailWork",
    PhonePrimary = "PhonePrimary",
    PhoneWork = "PhoneWork",
    Website = "Website",
    Facebook = "Facebook",
    Instagram = "Instagram",
    Twitter = "Twitter",
}

export class Corporate implements ICorporate {
    id?: number;
    user?: User;
    name!: string;
    phoneNumber?: string | undefined;
    email?: string | undefined;
    logoId?: number | undefined;
    logo?: Media;
    taxNo?: string | undefined;
    taxOffice?: string | undefined;
    description?: string | undefined;
    isActive?: boolean;

    constructor(data?: ICorporate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.isActive = true;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.user = _data["User"] ? User.fromJS(_data["User"]) : <any>undefined;
            this.name = _data["Name"];
            this.phoneNumber = _data["PhoneNumber"];
            this.email = _data["Email"];
            this.logoId = _data["LogoId"];
            this.logo = _data["Logo"] ? Media.fromJS(_data["Logo"]) : <any>undefined;
            this.taxNo = _data["TaxNo"];
            this.taxOffice = _data["TaxOffice"];
            this.description = _data["Description"];
            this.isActive = _data["IsActive"] !== undefined ? _data["IsActive"] : true;
        }
    }

    static fromJS(data: any): Corporate {
        data = typeof data === 'object' ? data : {};
        let result = new Corporate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["User"] = this.user ? this.user.toJSON() : <any>undefined;
        data["Name"] = this.name;
        data["PhoneNumber"] = this.phoneNumber;
        data["Email"] = this.email;
        data["LogoId"] = this.logoId;
        data["Logo"] = this.logo ? this.logo.toJSON() : <any>undefined;
        data["TaxNo"] = this.taxNo;
        data["TaxOffice"] = this.taxOffice;
        data["Description"] = this.description;
        data["IsActive"] = this.isActive;
        return data;
    }
}

export interface ICorporate {
    id?: number;
    user?: User;
    name: string;
    phoneNumber?: string | undefined;
    email?: string | undefined;
    logoId?: number | undefined;
    logo?: Media;
    taxNo?: string | undefined;
    taxOffice?: string | undefined;
    description?: string | undefined;
    isActive?: boolean;
}

export class CorporateModel implements ICorporateModel {
    id?: number;
    name?: string | undefined;
    user?: UserModel;

    constructor(data?: ICorporateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.name = _data["Name"];
            this.user = _data["User"] ? UserModel.fromJS(_data["User"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CorporateModel {
        data = typeof data === 'object' ? data : {};
        let result = new CorporateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Name"] = this.name;
        data["User"] = this.user ? this.user.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICorporateModel {
    id?: number;
    name?: string | undefined;
    user?: UserModel;
}

export class Country implements ICountry {
    id?: string | undefined;
    code!: string;
    name!: string;
    nationality?: string | undefined;

    constructor(data?: ICountry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.code = _data["Code"];
            this.name = _data["Name"];
            this.nationality = _data["Nationality"];
        }
    }

    static fromJS(data: any): Country {
        data = typeof data === 'object' ? data : {};
        let result = new Country();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Code"] = this.code;
        data["Name"] = this.name;
        data["Nationality"] = this.nationality;
        return data;
    }
}

export interface ICountry {
    id?: string | undefined;
    code: string;
    name: string;
    nationality?: string | undefined;
}

export class CountryModel implements ICountryModel {
    id?: number;
    code!: string;
    name!: string;
    nationality?: string | undefined;

    constructor(data?: ICountryModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.code = _data["Code"];
            this.name = _data["Name"];
            this.nationality = _data["Nationality"];
        }
    }

    static fromJS(data: any): CountryModel {
        data = typeof data === 'object' ? data : {};
        let result = new CountryModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Code"] = this.code;
        data["Name"] = this.name;
        data["Nationality"] = this.nationality;
        return data;
    }
}

export interface ICountryModel {
    id?: number;
    code: string;
    name: string;
    nationality?: string | undefined;
}

export class Coupon implements ICoupon {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    isDeleted?: boolean;
    userId?: number;
    user?: User;
    code?: string | undefined;
    createDate?: moment.Moment;
    expireDate?: moment.Moment;

    constructor(data?: ICoupon) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.createdOn = _data["CreatedOn"] ? moment(_data["CreatedOn"].toString()) : <any>undefined;
            this.createdById = _data["CreatedById"];
            this.updatedOn = _data["UpdatedOn"] ? moment(_data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedById = _data["UpdatedById"];
            this.deletedOn = _data["DeletedOn"] ? moment(_data["DeletedOn"].toString()) : <any>undefined;
            this.deletedById = _data["DeletedById"];
            this.isDeleted = _data["IsDeleted"];
            this.userId = _data["UserId"];
            this.user = _data["User"] ? User.fromJS(_data["User"]) : <any>undefined;
            this.code = _data["Code"];
            this.createDate = _data["CreateDate"] ? moment(_data["CreateDate"].toString()) : <any>undefined;
            this.expireDate = _data["ExpireDate"] ? moment(_data["ExpireDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Coupon {
        data = typeof data === 'object' ? data : {};
        let result = new Coupon();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedById"] = this.createdById;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["DeletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        data["DeletedById"] = this.deletedById;
        data["IsDeleted"] = this.isDeleted;
        data["UserId"] = this.userId;
        data["User"] = this.user ? this.user.toJSON() : <any>undefined;
        data["Code"] = this.code;
        data["CreateDate"] = this.createDate ? this.createDate.toISOString() : <any>undefined;
        data["ExpireDate"] = this.expireDate ? this.expireDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface ICoupon {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    isDeleted?: boolean;
    userId?: number;
    user?: User;
    code?: string | undefined;
    createDate?: moment.Moment;
    expireDate?: moment.Moment;
}

export class CreditCardMemberPaymentRequestModel implements ICreditCardMemberPaymentRequestModel {
    storedCardId?: string | undefined;
    transactionAmountTRY?: number;

    constructor(data?: ICreditCardMemberPaymentRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.storedCardId = _data["StoredCardId"];
            this.transactionAmountTRY = _data["TransactionAmountTRY"];
        }
    }

    static fromJS(data: any): CreditCardMemberPaymentRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new CreditCardMemberPaymentRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["StoredCardId"] = this.storedCardId;
        data["TransactionAmountTRY"] = this.transactionAmountTRY;
        return data;
    }
}

export interface ICreditCardMemberPaymentRequestModel {
    storedCardId?: string | undefined;
    transactionAmountTRY?: number;
}

export class CreditCardPaymentRequestModel implements ICreditCardPaymentRequestModel {
    transactionAmountTRY?: number;
    creditCardHolder?: string | undefined;
    creditCardPAN?: string | undefined;
    creditCardExpiryMonth?: string | undefined;
    creditCardExpiryYear?: string | undefined;
    creditCardCVC?: string | undefined;

    constructor(data?: ICreditCardPaymentRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.transactionAmountTRY = _data["TransactionAmountTRY"];
            this.creditCardHolder = _data["CreditCardHolder"];
            this.creditCardPAN = _data["CreditCardPAN"];
            this.creditCardExpiryMonth = _data["CreditCardExpiryMonth"];
            this.creditCardExpiryYear = _data["CreditCardExpiryYear"];
            this.creditCardCVC = _data["CreditCardCVC"];
        }
    }

    static fromJS(data: any): CreditCardPaymentRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new CreditCardPaymentRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["TransactionAmountTRY"] = this.transactionAmountTRY;
        data["CreditCardHolder"] = this.creditCardHolder;
        data["CreditCardPAN"] = this.creditCardPAN;
        data["CreditCardExpiryMonth"] = this.creditCardExpiryMonth;
        data["CreditCardExpiryYear"] = this.creditCardExpiryYear;
        data["CreditCardCVC"] = this.creditCardCVC;
        return data;
    }
}

export interface ICreditCardPaymentRequestModel {
    transactionAmountTRY?: number;
    creditCardHolder?: string | undefined;
    creditCardPAN?: string | undefined;
    creditCardExpiryMonth?: string | undefined;
    creditCardExpiryYear?: string | undefined;
    creditCardCVC?: string | undefined;
}

export class CreditCardPaymentSummaryModel implements ICreditCardPaymentSummaryModel {

    constructor(data?: ICreditCardPaymentSummaryModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): CreditCardPaymentSummaryModel {
        data = typeof data === 'object' ? data : {};
        let result = new CreditCardPaymentSummaryModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface ICreditCardPaymentSummaryModel {
}

export class Data implements IData {
    day?: Day;

    constructor(data?: IData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.day = _data["Day"] ? Day.fromJS(_data["Day"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Data {
        data = typeof data === 'object' ? data : {};
        let result = new Data();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Day"] = this.day ? this.day.toJSON() : <any>undefined;
        return data;
    }
}

export interface IData {
    day?: Day;
}

export class Datum implements IDatum {
    time?: string | undefined;
    country?: string | undefined;
    indicator?: string | undefined;
    per?: string | undefined;
    priority?: string | undefined;
    actual?: string | undefined;
    consensus?: string | undefined;
    previous?: string | undefined;
    id?: string | undefined;

    constructor(data?: IDatum) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.time = _data["Time"];
            this.country = _data["Country"];
            this.indicator = _data["Indicator"];
            this.per = _data["Per"];
            this.priority = _data["Priority"];
            this.actual = _data["Actual"];
            this.consensus = _data["Consensus"];
            this.previous = _data["Previous"];
            this.id = _data["Id"];
        }
    }

    static fromJS(data: any): Datum {
        data = typeof data === 'object' ? data : {};
        let result = new Datum();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Time"] = this.time;
        data["Country"] = this.country;
        data["Indicator"] = this.indicator;
        data["Per"] = this.per;
        data["Priority"] = this.priority;
        data["Actual"] = this.actual;
        data["Consensus"] = this.consensus;
        data["Previous"] = this.previous;
        data["Id"] = this.id;
        return data;
    }
}

export interface IDatum {
    time?: string | undefined;
    country?: string | undefined;
    indicator?: string | undefined;
    per?: string | undefined;
    priority?: string | undefined;
    actual?: string | undefined;
    consensus?: string | undefined;
    previous?: string | undefined;
    id?: string | undefined;
}

export class Day implements IDay {
    datum?: Datum[] | undefined;
    date?: string | undefined;

    constructor(data?: IDay) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["Datum"])) {
                this.datum = [] as any;
                for (let item of _data["Datum"])
                    this.datum!.push(Datum.fromJS(item));
            }
            this.date = _data["Date"];
        }
    }

    static fromJS(data: any): Day {
        data = typeof data === 'object' ? data : {};
        let result = new Day();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.datum)) {
            data["Datum"] = [];
            for (let item of this.datum)
                data["Datum"].push(item.toJSON());
        }
        data["Date"] = this.date;
        return data;
    }
}

export interface IDay {
    datum?: Datum[] | undefined;
    date?: string | undefined;
}

export class DebentureModel implements IDebentureModel {
    data?: DebentureModelData[] | undefined;

    constructor(data?: IDebentureModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["Data"])) {
                this.data = [] as any;
                for (let item of _data["Data"])
                    this.data!.push(DebentureModelData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DebentureModel {
        data = typeof data === 'object' ? data : {};
        let result = new DebentureModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["Data"] = [];
            for (let item of this.data)
                data["Data"].push(item.toJSON());
        }
        return data;
    }
}

export interface IDebentureModel {
    data?: DebentureModelData[] | undefined;
}

export class DebentureModelData implements IDebentureModelData {
    sembol?: string | undefined;
    aciklama?: string | undefined;
    alis?: string | undefined;
    satis?: string | undefined;
    gunlukyuzde?: string | undefined;
    dunkukapanis?: string | undefined;
    piydeg?: string | undefined;
    fark?: string | undefined;
    tarih?: string | undefined;
    son?: string | undefined;
    simge?: string | undefined;
    vobSayi?: string | undefined;
    hacimtl?: string | undefined;
    hacimlot?: string | undefined;
    acilis?: string | undefined;
    dusuk?: string | undefined;
    yuksek?: string | undefined;
    tip?: string | undefined;
    sembolId?: string | undefined;
    yilYuksek?: string | undefined;
    yilDusuk?: string | undefined;
    sermaye?: string | undefined;

    constructor(data?: IDebentureModelData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sembol = _data["Sembol"];
            this.aciklama = _data["Aciklama"];
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
            this.dunkukapanis = _data["Dunkukapanis"];
            this.piydeg = _data["Piydeg"];
            this.fark = _data["Fark"];
            this.tarih = _data["Tarih"];
            this.son = _data["Son"];
            this.simge = _data["Simge"];
            this.vobSayi = _data["VobSayi"];
            this.hacimtl = _data["Hacimtl"];
            this.hacimlot = _data["Hacimlot"];
            this.acilis = _data["Acilis"];
            this.dusuk = _data["Dusuk"];
            this.yuksek = _data["Yuksek"];
            this.tip = _data["Tip"];
            this.sembolId = _data["SembolId"];
            this.yilYuksek = _data["YilYuksek"];
            this.yilDusuk = _data["YilDusuk"];
            this.sermaye = _data["Sermaye"];
        }
    }

    static fromJS(data: any): DebentureModelData {
        data = typeof data === 'object' ? data : {};
        let result = new DebentureModelData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Sembol"] = this.sembol;
        data["Aciklama"] = this.aciklama;
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        data["Dunkukapanis"] = this.dunkukapanis;
        data["Piydeg"] = this.piydeg;
        data["Fark"] = this.fark;
        data["Tarih"] = this.tarih;
        data["Son"] = this.son;
        data["Simge"] = this.simge;
        data["VobSayi"] = this.vobSayi;
        data["Hacimtl"] = this.hacimtl;
        data["Hacimlot"] = this.hacimlot;
        data["Acilis"] = this.acilis;
        data["Dusuk"] = this.dusuk;
        data["Yuksek"] = this.yuksek;
        data["Tip"] = this.tip;
        data["SembolId"] = this.sembolId;
        data["YilYuksek"] = this.yilYuksek;
        data["YilDusuk"] = this.yilDusuk;
        data["Sermaye"] = this.sermaye;
        return data;
    }
}

export interface IDebentureModelData {
    sembol?: string | undefined;
    aciklama?: string | undefined;
    alis?: string | undefined;
    satis?: string | undefined;
    gunlukyuzde?: string | undefined;
    dunkukapanis?: string | undefined;
    piydeg?: string | undefined;
    fark?: string | undefined;
    tarih?: string | undefined;
    son?: string | undefined;
    simge?: string | undefined;
    vobSayi?: string | undefined;
    hacimtl?: string | undefined;
    hacimlot?: string | undefined;
    acilis?: string | undefined;
    dusuk?: string | undefined;
    yuksek?: string | undefined;
    tip?: string | undefined;
    sembolId?: string | undefined;
    yilYuksek?: string | undefined;
    yilDusuk?: string | undefined;
    sermaye?: string | undefined;
}

export enum DemandType {
    Digital = "Digital",
    Physical = "Physical",
}

export class District implements IDistrict {
    id?: number;
    provinceId?: number;
    province?: Province;
    name!: string;
    type?: string | undefined;
    location?: string | undefined;

    constructor(data?: IDistrict) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.provinceId = _data["ProvinceId"];
            this.province = _data["Province"] ? Province.fromJS(_data["Province"]) : <any>undefined;
            this.name = _data["Name"];
            this.type = _data["Type"];
            this.location = _data["Location"];
        }
    }

    static fromJS(data: any): District {
        data = typeof data === 'object' ? data : {};
        let result = new District();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["ProvinceId"] = this.provinceId;
        data["Province"] = this.province ? this.province.toJSON() : <any>undefined;
        data["Name"] = this.name;
        data["Type"] = this.type;
        data["Location"] = this.location;
        return data;
    }
}

export interface IDistrict {
    id?: number;
    provinceId?: number;
    province?: Province;
    name: string;
    type?: string | undefined;
    location?: string | undefined;
}

export enum DocumentType {
    IdCard = "IdCard",
    Passport = "Passport",
    DrivingLicence = "DrivingLicence",
    UtilityBill = "UtilityBill",
    BankStatement = "BankStatement",
    ResidencyLetter = "ResidencyLetter",
    AuthoriizedSignatory = "AuthoriizedSignatory",
    TaxSignboard = "TaxSignboard",
    RegistryNewspaper = "RegistryNewspaper",
    CertificateOfActivity = "CertificateOfActivity",
}

export class ErrorDto implements IErrorDto {
    code?: number;
    key?: string | undefined;
    message?: string | undefined;

    constructor(data?: IErrorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["Code"];
            this.key = _data["Key"];
            this.message = _data["Message"];
        }
    }

    static fromJS(data: any): ErrorDto {
        data = typeof data === 'object' ? data : {};
        let result = new ErrorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Code"] = this.code;
        data["Key"] = this.key;
        data["Message"] = this.message;
        return data;
    }
}

export interface IErrorDto {
    code?: number;
    key?: string | undefined;
    message?: string | undefined;
}

export class ForgotModel implements IForgotModel {
    email?: string | undefined;
    phoneNumber?: string | undefined;

    constructor(data?: IForgotModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["Email"];
            this.phoneNumber = _data["PhoneNumber"];
        }
    }

    static fromJS(data: any): ForgotModel {
        data = typeof data === 'object' ? data : {};
        let result = new ForgotModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Email"] = this.email;
        data["PhoneNumber"] = this.phoneNumber;
        return data;
    }
}

export interface IForgotModel {
    email?: string | undefined;
    phoneNumber?: string | undefined;
}

export enum Gender {
    Unknown = "Unknown",
    Female = "Female",
    Male = "Male",
    Other = "Other",
}

export class GraphicData implements IGraphicData {
    symbol?: string | undefined;
    date?: string | undefined;
    openString?: string | undefined;
    closeString?: string | undefined;
    highString?: string | undefined;
    lowString?: string | undefined;
    volumeString?: string | undefined;
    weightAverageString?: string | undefined;
    changeString?: string | undefined;
    readonly open?: number;
    readonly close?: number;
    readonly high?: number;
    readonly low?: number;
    readonly volume?: number;
    readonly weightAverage?: number;
    readonly change?: number;

    constructor(data?: IGraphicData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.symbol = _data["Symbol"];
            this.date = _data["Date"];
            this.openString = _data["OpenString"];
            this.closeString = _data["CloseString"];
            this.highString = _data["HighString"];
            this.lowString = _data["LowString"];
            this.volumeString = _data["VolumeString"];
            this.weightAverageString = _data["WeightAverageString"];
            this.changeString = _data["ChangeString"];
            (<any>this).open = _data["Open"];
            (<any>this).close = _data["Close"];
            (<any>this).high = _data["High"];
            (<any>this).low = _data["Low"];
            (<any>this).volume = _data["Volume"];
            (<any>this).weightAverage = _data["WeightAverage"];
            (<any>this).change = _data["Change"];
        }
    }

    static fromJS(data: any): GraphicData {
        data = typeof data === 'object' ? data : {};
        let result = new GraphicData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Symbol"] = this.symbol;
        data["Date"] = this.date;
        data["OpenString"] = this.openString;
        data["CloseString"] = this.closeString;
        data["HighString"] = this.highString;
        data["LowString"] = this.lowString;
        data["VolumeString"] = this.volumeString;
        data["WeightAverageString"] = this.weightAverageString;
        data["ChangeString"] = this.changeString;
        data["Open"] = this.open;
        data["Close"] = this.close;
        data["High"] = this.high;
        data["Low"] = this.low;
        data["Volume"] = this.volume;
        data["WeightAverage"] = this.weightAverage;
        data["Change"] = this.change;
        return data;
    }
}

export interface IGraphicData {
    symbol?: string | undefined;
    date?: string | undefined;
    openString?: string | undefined;
    closeString?: string | undefined;
    highString?: string | undefined;
    lowString?: string | undefined;
    volumeString?: string | undefined;
    weightAverageString?: string | undefined;
    changeString?: string | undefined;
    open?: number;
    close?: number;
    high?: number;
    low?: number;
    volume?: number;
    weightAverage?: number;
    change?: number;
}

export class GraphicDataModel implements IGraphicDataModel {
    data?: GraphicData[] | undefined;

    constructor(data?: IGraphicDataModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["Data"])) {
                this.data = [] as any;
                for (let item of _data["Data"])
                    this.data!.push(GraphicData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GraphicDataModel {
        data = typeof data === 'object' ? data : {};
        let result = new GraphicDataModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["Data"] = [];
            for (let item of this.data)
                data["Data"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGraphicDataModel {
    data?: GraphicData[] | undefined;
}

export class Group implements IGroup {
    id?: number;
    name!: string;
    description?: string | undefined;
    isDeleted?: boolean;

    constructor(data?: IGroup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.name = _data["Name"];
            this.description = _data["Description"];
            this.isDeleted = _data["IsDeleted"];
        }
    }

    static fromJS(data: any): Group {
        data = typeof data === 'object' ? data : {};
        let result = new Group();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Name"] = this.name;
        data["Description"] = this.description;
        data["IsDeleted"] = this.isDeleted;
        return data;
    }
}

export interface IGroup {
    id?: number;
    name: string;
    description?: string | undefined;
    isDeleted?: boolean;
}

export class GroupModel implements IGroupModel {
    id?: number;
    name?: string | undefined;
    description?: string | undefined;

    constructor(data?: IGroupModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.name = _data["Name"];
            this.description = _data["Description"];
        }
    }

    static fromJS(data: any): GroupModel {
        data = typeof data === 'object' ? data : {};
        let result = new GroupModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Name"] = this.name;
        data["Description"] = this.description;
        return data;
    }
}

export interface IGroupModel {
    id?: number;
    name?: string | undefined;
    description?: string | undefined;
}

export class KnowledgeBaseCategoryModel implements IKnowledgeBaseCategoryModel {
    id?: number;
    name?: string | undefined;
    mediaId?: number | undefined;
    media?: MediaModel;

    constructor(data?: IKnowledgeBaseCategoryModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.name = _data["Name"];
            this.mediaId = _data["MediaId"];
            this.media = _data["Media"] ? MediaModel.fromJS(_data["Media"]) : <any>undefined;
        }
    }

    static fromJS(data: any): KnowledgeBaseCategoryModel {
        data = typeof data === 'object' ? data : {};
        let result = new KnowledgeBaseCategoryModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Name"] = this.name;
        data["MediaId"] = this.mediaId;
        data["Media"] = this.media ? this.media.toJSON() : <any>undefined;
        return data;
    }
}

export interface IKnowledgeBaseCategoryModel {
    id?: number;
    name?: string | undefined;
    mediaId?: number | undefined;
    media?: MediaModel;
}

export class KnowledgeBaseModel implements IKnowledgeBaseModel {
    title!: string;
    subTitle?: string | undefined;
    slug?: string | undefined;
    metaKeywords?: string | undefined;
    metaDescription?: string | undefined;
    body?: string | undefined;
    mediaId?: number | undefined;
    media?: MediaModel;
    isPublished?: boolean;
    publishedOn?: moment.Moment | undefined;
    publishedTill?: moment.Moment | undefined;
    categoryId?: number | undefined;
    category?: KnowledgeBaseCategoryModel;

    constructor(data?: IKnowledgeBaseModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["Title"];
            this.subTitle = _data["SubTitle"];
            this.slug = _data["Slug"];
            this.metaKeywords = _data["MetaKeywords"];
            this.metaDescription = _data["MetaDescription"];
            this.body = _data["Body"];
            this.mediaId = _data["MediaId"];
            this.media = _data["Media"] ? MediaModel.fromJS(_data["Media"]) : <any>undefined;
            this.isPublished = _data["IsPublished"];
            this.publishedOn = _data["PublishedOn"] ? moment(_data["PublishedOn"].toString()) : <any>undefined;
            this.publishedTill = _data["PublishedTill"] ? moment(_data["PublishedTill"].toString()) : <any>undefined;
            this.categoryId = _data["CategoryId"];
            this.category = _data["Category"] ? KnowledgeBaseCategoryModel.fromJS(_data["Category"]) : <any>undefined;
        }
    }

    static fromJS(data: any): KnowledgeBaseModel {
        data = typeof data === 'object' ? data : {};
        let result = new KnowledgeBaseModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Title"] = this.title;
        data["SubTitle"] = this.subTitle;
        data["Slug"] = this.slug;
        data["MetaKeywords"] = this.metaKeywords;
        data["MetaDescription"] = this.metaDescription;
        data["Body"] = this.body;
        data["MediaId"] = this.mediaId;
        data["Media"] = this.media ? this.media.toJSON() : <any>undefined;
        data["IsPublished"] = this.isPublished;
        data["PublishedOn"] = this.publishedOn ? this.publishedOn.toISOString() : <any>undefined;
        data["PublishedTill"] = this.publishedTill ? this.publishedTill.toISOString() : <any>undefined;
        data["CategoryId"] = this.categoryId;
        data["Category"] = this.category ? this.category.toJSON() : <any>undefined;
        return data;
    }
}

export interface IKnowledgeBaseModel {
    title: string;
    subTitle?: string | undefined;
    slug?: string | undefined;
    metaKeywords?: string | undefined;
    metaDescription?: string | undefined;
    body?: string | undefined;
    mediaId?: number | undefined;
    media?: MediaModel;
    isPublished?: boolean;
    publishedOn?: moment.Moment | undefined;
    publishedTill?: moment.Moment | undefined;
    categoryId?: number | undefined;
    category?: KnowledgeBaseCategoryModel;
}

export class LoginModel implements ILoginModel {
    phoneNumber?: string | undefined;
    password?: string | undefined;
    isVerified?: boolean;

    constructor(data?: ILoginModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.phoneNumber = _data["PhoneNumber"];
            this.password = _data["Password"];
            this.isVerified = _data["IsVerified"];
        }
    }

    static fromJS(data: any): LoginModel {
        data = typeof data === 'object' ? data : {};
        let result = new LoginModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["PhoneNumber"] = this.phoneNumber;
        data["Password"] = this.password;
        data["IsVerified"] = this.isVerified;
        return data;
    }
}

export interface ILoginModel {
    phoneNumber?: string | undefined;
    password?: string | undefined;
    isVerified?: boolean;
}

export class MarketItemModel implements IMarketItemModel {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IMarketItemModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): MarketItemModel {
        data = typeof data === 'object' ? data : {};
        let result = new MarketItemModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IMarketItemModel {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class MarketModel implements IMarketModel {
    altin?: MarketItemModel;
    altingr?: MarketItemModel;
    altinkgtl?: MarketItemModel;
    altinkgusd?: MarketItemModel;
    ons?: MarketItemModel;
    gumusserbest?: MarketItemModel;
    gumususd?: MarketItemModel;
    gumuseur?: MarketItemModel;
    gumus?: MarketItemModel;
    altinusd?: MarketItemModel;
    altincum?: MarketItemModel;
    altingldt?: MarketItemModel;
    altingldy?: MarketItemModel;
    altingldc?: MarketItemModel;
    altinres?: MarketItemModel;
    altinresk?: MarketItemModel;
    usd?: MarketItemModel;
    euro?: MarketItemModel;
    eurtry?: MarketItemModel;
    gbp?: MarketItemModel;
    jpy?: MarketItemModel;
    cad?: MarketItemModel;
    aud?: MarketItemModel;
    nok?: MarketItemModel;
    dkk?: MarketItemModel;
    sek?: MarketItemModel;
    sar?: MarketItemModel;
    chf?: MarketItemModel;
    platin?: MarketItemModel;
    paladyum?: MarketItemModel;
    cyp?: MarketItemModel;
    gumusfix?: MarketItemModel;
    altinfixUsdAm?: MarketItemModel;
    altinfixUsdPm?: MarketItemModel;
    altinfixEurAm?: MarketItemModel;
    altinfixEurPm?: MarketItemModel;
    altinfixGbpAm?: MarketItemModel;
    altinfixGbpPm?: MarketItemModel;
    platinfixAm?: MarketItemModel;
    platinfixPm?: MarketItemModel;
    paladyumfixAm?: MarketItemModel;
    paladyumfixPm?: MarketItemModel;
    rodyumfix?: MarketItemModel;
    iko01?: MarketItemModel;
    iko02?: MarketItemModel;
    iko03?: MarketItemModel;
    iko04?: MarketItemModel;
    iko05?: MarketItemModel;
    iko06?: MarketItemModel;
    iko07?: MarketItemModel;
    iko08?: MarketItemModel;
    iko09?: MarketItemModel;
    iko10?: MarketItemModel;
    iko11?: MarketItemModel;
    iko12?: MarketItemModel;

    constructor(data?: IMarketModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.altin = _data["Altin"] ? MarketItemModel.fromJS(_data["Altin"]) : <any>undefined;
            this.altingr = _data["Altingr"] ? MarketItemModel.fromJS(_data["Altingr"]) : <any>undefined;
            this.altinkgtl = _data["Altinkgtl"] ? MarketItemModel.fromJS(_data["Altinkgtl"]) : <any>undefined;
            this.altinkgusd = _data["Altinkgusd"] ? MarketItemModel.fromJS(_data["Altinkgusd"]) : <any>undefined;
            this.ons = _data["Ons"] ? MarketItemModel.fromJS(_data["Ons"]) : <any>undefined;
            this.gumusserbest = _data["Gumusserbest"] ? MarketItemModel.fromJS(_data["Gumusserbest"]) : <any>undefined;
            this.gumususd = _data["Gumususd"] ? MarketItemModel.fromJS(_data["Gumususd"]) : <any>undefined;
            this.gumuseur = _data["Gumuseur"] ? MarketItemModel.fromJS(_data["Gumuseur"]) : <any>undefined;
            this.gumus = _data["Gumus"] ? MarketItemModel.fromJS(_data["Gumus"]) : <any>undefined;
            this.altinusd = _data["Altinusd"] ? MarketItemModel.fromJS(_data["Altinusd"]) : <any>undefined;
            this.altincum = _data["Altincum"] ? MarketItemModel.fromJS(_data["Altincum"]) : <any>undefined;
            this.altingldt = _data["Altingldt"] ? MarketItemModel.fromJS(_data["Altingldt"]) : <any>undefined;
            this.altingldy = _data["Altingldy"] ? MarketItemModel.fromJS(_data["Altingldy"]) : <any>undefined;
            this.altingldc = _data["Altingldc"] ? MarketItemModel.fromJS(_data["Altingldc"]) : <any>undefined;
            this.altinres = _data["Altinres"] ? MarketItemModel.fromJS(_data["Altinres"]) : <any>undefined;
            this.altinresk = _data["Altinresk"] ? MarketItemModel.fromJS(_data["Altinresk"]) : <any>undefined;
            this.usd = _data["Usd"] ? MarketItemModel.fromJS(_data["Usd"]) : <any>undefined;
            this.euro = _data["Euro"] ? MarketItemModel.fromJS(_data["Euro"]) : <any>undefined;
            this.eurtry = _data["Eurtry"] ? MarketItemModel.fromJS(_data["Eurtry"]) : <any>undefined;
            this.gbp = _data["Gbp"] ? MarketItemModel.fromJS(_data["Gbp"]) : <any>undefined;
            this.jpy = _data["Jpy"] ? MarketItemModel.fromJS(_data["Jpy"]) : <any>undefined;
            this.cad = _data["Cad"] ? MarketItemModel.fromJS(_data["Cad"]) : <any>undefined;
            this.aud = _data["Aud"] ? MarketItemModel.fromJS(_data["Aud"]) : <any>undefined;
            this.nok = _data["Nok"] ? MarketItemModel.fromJS(_data["Nok"]) : <any>undefined;
            this.dkk = _data["Dkk"] ? MarketItemModel.fromJS(_data["Dkk"]) : <any>undefined;
            this.sek = _data["Sek"] ? MarketItemModel.fromJS(_data["Sek"]) : <any>undefined;
            this.sar = _data["Sar"] ? MarketItemModel.fromJS(_data["Sar"]) : <any>undefined;
            this.chf = _data["Chf"] ? MarketItemModel.fromJS(_data["Chf"]) : <any>undefined;
            this.platin = _data["Platin"] ? MarketItemModel.fromJS(_data["Platin"]) : <any>undefined;
            this.paladyum = _data["Paladyum"] ? MarketItemModel.fromJS(_data["Paladyum"]) : <any>undefined;
            this.cyp = _data["Cyp"] ? MarketItemModel.fromJS(_data["Cyp"]) : <any>undefined;
            this.gumusfix = _data["Gumusfix"] ? MarketItemModel.fromJS(_data["Gumusfix"]) : <any>undefined;
            this.altinfixUsdAm = _data["AltinfixUsdAm"] ? MarketItemModel.fromJS(_data["AltinfixUsdAm"]) : <any>undefined;
            this.altinfixUsdPm = _data["AltinfixUsdPm"] ? MarketItemModel.fromJS(_data["AltinfixUsdPm"]) : <any>undefined;
            this.altinfixEurAm = _data["AltinfixEurAm"] ? MarketItemModel.fromJS(_data["AltinfixEurAm"]) : <any>undefined;
            this.altinfixEurPm = _data["AltinfixEurPm"] ? MarketItemModel.fromJS(_data["AltinfixEurPm"]) : <any>undefined;
            this.altinfixGbpAm = _data["AltinfixGbpAm"] ? MarketItemModel.fromJS(_data["AltinfixGbpAm"]) : <any>undefined;
            this.altinfixGbpPm = _data["AltinfixGbpPm"] ? MarketItemModel.fromJS(_data["AltinfixGbpPm"]) : <any>undefined;
            this.platinfixAm = _data["PlatinfixAm"] ? MarketItemModel.fromJS(_data["PlatinfixAm"]) : <any>undefined;
            this.platinfixPm = _data["PlatinfixPm"] ? MarketItemModel.fromJS(_data["PlatinfixPm"]) : <any>undefined;
            this.paladyumfixAm = _data["PaladyumfixAm"] ? MarketItemModel.fromJS(_data["PaladyumfixAm"]) : <any>undefined;
            this.paladyumfixPm = _data["PaladyumfixPm"] ? MarketItemModel.fromJS(_data["PaladyumfixPm"]) : <any>undefined;
            this.rodyumfix = _data["Rodyumfix"] ? MarketItemModel.fromJS(_data["Rodyumfix"]) : <any>undefined;
            this.iko01 = _data["Iko01"] ? MarketItemModel.fromJS(_data["Iko01"]) : <any>undefined;
            this.iko02 = _data["Iko02"] ? MarketItemModel.fromJS(_data["Iko02"]) : <any>undefined;
            this.iko03 = _data["Iko03"] ? MarketItemModel.fromJS(_data["Iko03"]) : <any>undefined;
            this.iko04 = _data["Iko04"] ? MarketItemModel.fromJS(_data["Iko04"]) : <any>undefined;
            this.iko05 = _data["Iko05"] ? MarketItemModel.fromJS(_data["Iko05"]) : <any>undefined;
            this.iko06 = _data["Iko06"] ? MarketItemModel.fromJS(_data["Iko06"]) : <any>undefined;
            this.iko07 = _data["Iko07"] ? MarketItemModel.fromJS(_data["Iko07"]) : <any>undefined;
            this.iko08 = _data["Iko08"] ? MarketItemModel.fromJS(_data["Iko08"]) : <any>undefined;
            this.iko09 = _data["Iko09"] ? MarketItemModel.fromJS(_data["Iko09"]) : <any>undefined;
            this.iko10 = _data["Iko10"] ? MarketItemModel.fromJS(_data["Iko10"]) : <any>undefined;
            this.iko11 = _data["Iko11"] ? MarketItemModel.fromJS(_data["Iko11"]) : <any>undefined;
            this.iko12 = _data["Iko12"] ? MarketItemModel.fromJS(_data["Iko12"]) : <any>undefined;
        }
    }

    static fromJS(data: any): MarketModel {
        data = typeof data === 'object' ? data : {};
        let result = new MarketModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Altin"] = this.altin ? this.altin.toJSON() : <any>undefined;
        data["Altingr"] = this.altingr ? this.altingr.toJSON() : <any>undefined;
        data["Altinkgtl"] = this.altinkgtl ? this.altinkgtl.toJSON() : <any>undefined;
        data["Altinkgusd"] = this.altinkgusd ? this.altinkgusd.toJSON() : <any>undefined;
        data["Ons"] = this.ons ? this.ons.toJSON() : <any>undefined;
        data["Gumusserbest"] = this.gumusserbest ? this.gumusserbest.toJSON() : <any>undefined;
        data["Gumususd"] = this.gumususd ? this.gumususd.toJSON() : <any>undefined;
        data["Gumuseur"] = this.gumuseur ? this.gumuseur.toJSON() : <any>undefined;
        data["Gumus"] = this.gumus ? this.gumus.toJSON() : <any>undefined;
        data["Altinusd"] = this.altinusd ? this.altinusd.toJSON() : <any>undefined;
        data["Altincum"] = this.altincum ? this.altincum.toJSON() : <any>undefined;
        data["Altingldt"] = this.altingldt ? this.altingldt.toJSON() : <any>undefined;
        data["Altingldy"] = this.altingldy ? this.altingldy.toJSON() : <any>undefined;
        data["Altingldc"] = this.altingldc ? this.altingldc.toJSON() : <any>undefined;
        data["Altinres"] = this.altinres ? this.altinres.toJSON() : <any>undefined;
        data["Altinresk"] = this.altinresk ? this.altinresk.toJSON() : <any>undefined;
        data["Usd"] = this.usd ? this.usd.toJSON() : <any>undefined;
        data["Euro"] = this.euro ? this.euro.toJSON() : <any>undefined;
        data["Eurtry"] = this.eurtry ? this.eurtry.toJSON() : <any>undefined;
        data["Gbp"] = this.gbp ? this.gbp.toJSON() : <any>undefined;
        data["Jpy"] = this.jpy ? this.jpy.toJSON() : <any>undefined;
        data["Cad"] = this.cad ? this.cad.toJSON() : <any>undefined;
        data["Aud"] = this.aud ? this.aud.toJSON() : <any>undefined;
        data["Nok"] = this.nok ? this.nok.toJSON() : <any>undefined;
        data["Dkk"] = this.dkk ? this.dkk.toJSON() : <any>undefined;
        data["Sek"] = this.sek ? this.sek.toJSON() : <any>undefined;
        data["Sar"] = this.sar ? this.sar.toJSON() : <any>undefined;
        data["Chf"] = this.chf ? this.chf.toJSON() : <any>undefined;
        data["Platin"] = this.platin ? this.platin.toJSON() : <any>undefined;
        data["Paladyum"] = this.paladyum ? this.paladyum.toJSON() : <any>undefined;
        data["Cyp"] = this.cyp ? this.cyp.toJSON() : <any>undefined;
        data["Gumusfix"] = this.gumusfix ? this.gumusfix.toJSON() : <any>undefined;
        data["AltinfixUsdAm"] = this.altinfixUsdAm ? this.altinfixUsdAm.toJSON() : <any>undefined;
        data["AltinfixUsdPm"] = this.altinfixUsdPm ? this.altinfixUsdPm.toJSON() : <any>undefined;
        data["AltinfixEurAm"] = this.altinfixEurAm ? this.altinfixEurAm.toJSON() : <any>undefined;
        data["AltinfixEurPm"] = this.altinfixEurPm ? this.altinfixEurPm.toJSON() : <any>undefined;
        data["AltinfixGbpAm"] = this.altinfixGbpAm ? this.altinfixGbpAm.toJSON() : <any>undefined;
        data["AltinfixGbpPm"] = this.altinfixGbpPm ? this.altinfixGbpPm.toJSON() : <any>undefined;
        data["PlatinfixAm"] = this.platinfixAm ? this.platinfixAm.toJSON() : <any>undefined;
        data["PlatinfixPm"] = this.platinfixPm ? this.platinfixPm.toJSON() : <any>undefined;
        data["PaladyumfixAm"] = this.paladyumfixAm ? this.paladyumfixAm.toJSON() : <any>undefined;
        data["PaladyumfixPm"] = this.paladyumfixPm ? this.paladyumfixPm.toJSON() : <any>undefined;
        data["Rodyumfix"] = this.rodyumfix ? this.rodyumfix.toJSON() : <any>undefined;
        data["Iko01"] = this.iko01 ? this.iko01.toJSON() : <any>undefined;
        data["Iko02"] = this.iko02 ? this.iko02.toJSON() : <any>undefined;
        data["Iko03"] = this.iko03 ? this.iko03.toJSON() : <any>undefined;
        data["Iko04"] = this.iko04 ? this.iko04.toJSON() : <any>undefined;
        data["Iko05"] = this.iko05 ? this.iko05.toJSON() : <any>undefined;
        data["Iko06"] = this.iko06 ? this.iko06.toJSON() : <any>undefined;
        data["Iko07"] = this.iko07 ? this.iko07.toJSON() : <any>undefined;
        data["Iko08"] = this.iko08 ? this.iko08.toJSON() : <any>undefined;
        data["Iko09"] = this.iko09 ? this.iko09.toJSON() : <any>undefined;
        data["Iko10"] = this.iko10 ? this.iko10.toJSON() : <any>undefined;
        data["Iko11"] = this.iko11 ? this.iko11.toJSON() : <any>undefined;
        data["Iko12"] = this.iko12 ? this.iko12.toJSON() : <any>undefined;
        return data;
    }
}

export interface IMarketModel {
    altin?: MarketItemModel;
    altingr?: MarketItemModel;
    altinkgtl?: MarketItemModel;
    altinkgusd?: MarketItemModel;
    ons?: MarketItemModel;
    gumusserbest?: MarketItemModel;
    gumususd?: MarketItemModel;
    gumuseur?: MarketItemModel;
    gumus?: MarketItemModel;
    altinusd?: MarketItemModel;
    altincum?: MarketItemModel;
    altingldt?: MarketItemModel;
    altingldy?: MarketItemModel;
    altingldc?: MarketItemModel;
    altinres?: MarketItemModel;
    altinresk?: MarketItemModel;
    usd?: MarketItemModel;
    euro?: MarketItemModel;
    eurtry?: MarketItemModel;
    gbp?: MarketItemModel;
    jpy?: MarketItemModel;
    cad?: MarketItemModel;
    aud?: MarketItemModel;
    nok?: MarketItemModel;
    dkk?: MarketItemModel;
    sek?: MarketItemModel;
    sar?: MarketItemModel;
    chf?: MarketItemModel;
    platin?: MarketItemModel;
    paladyum?: MarketItemModel;
    cyp?: MarketItemModel;
    gumusfix?: MarketItemModel;
    altinfixUsdAm?: MarketItemModel;
    altinfixUsdPm?: MarketItemModel;
    altinfixEurAm?: MarketItemModel;
    altinfixEurPm?: MarketItemModel;
    altinfixGbpAm?: MarketItemModel;
    altinfixGbpPm?: MarketItemModel;
    platinfixAm?: MarketItemModel;
    platinfixPm?: MarketItemModel;
    paladyumfixAm?: MarketItemModel;
    paladyumfixPm?: MarketItemModel;
    rodyumfix?: MarketItemModel;
    iko01?: MarketItemModel;
    iko02?: MarketItemModel;
    iko03?: MarketItemModel;
    iko04?: MarketItemModel;
    iko05?: MarketItemModel;
    iko06?: MarketItemModel;
    iko07?: MarketItemModel;
    iko08?: MarketItemModel;
    iko09?: MarketItemModel;
    iko10?: MarketItemModel;
    iko11?: MarketItemModel;
    iko12?: MarketItemModel;
}

export class MatriksEconomyNewsModel implements IMatriksEconomyNewsModel {
    data?: Data;
    error?: MatriksError;

    constructor(data?: IMatriksEconomyNewsModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["Data"] ? Data.fromJS(_data["Data"]) : <any>undefined;
            this.error = _data["Error"] ? MatriksError.fromJS(_data["Error"]) : <any>undefined;
        }
    }

    static fromJS(data: any): MatriksEconomyNewsModel {
        data = typeof data === 'object' ? data : {};
        let result = new MatriksEconomyNewsModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["Error"] = this.error ? this.error.toJSON() : <any>undefined;
        return data;
    }
}

export interface IMatriksEconomyNewsModel {
    data?: Data;
    error?: MatriksError;
}

export class MatriksError implements IMatriksError {
    flag?: string | undefined;
    type?: string | undefined;
    msg?: string | undefined;

    constructor(data?: IMatriksError) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.flag = _data["Flag"];
            this.type = _data["Type"];
            this.msg = _data["Msg"];
        }
    }

    static fromJS(data: any): MatriksError {
        data = typeof data === 'object' ? data : {};
        let result = new MatriksError();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Flag"] = this.flag;
        data["Type"] = this.type;
        data["Msg"] = this.msg;
        return data;
    }
}

export interface IMatriksError {
    flag?: string | undefined;
    type?: string | undefined;
    msg?: string | undefined;
}

export enum MatriksGraphType {
    Min5 = "Min5",
    Min15 = "Min15",
    Min30 = "Min30",
    Min60 = "Min60",
    Daily = "Daily",
    Weekly = "Weekly",
    Monthly = "Monthly",
    Yearly = "Yearly",
}

export class MatriksNewsModel implements IMatriksNewsModel {
    data?: MatriksNewsModelData[] | undefined;

    constructor(data?: IMatriksNewsModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["Data"])) {
                this.data = [] as any;
                for (let item of _data["Data"])
                    this.data!.push(MatriksNewsModelData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MatriksNewsModel {
        data = typeof data === 'object' ? data : {};
        let result = new MatriksNewsModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["Data"] = [];
            for (let item of this.data)
                data["Data"].push(item.toJSON());
        }
        return data;
    }
}

export interface IMatriksNewsModel {
    data?: MatriksNewsModelData[] | undefined;
}

export class MatriksNewsModelData implements IMatriksNewsModelData {
    id?: string | undefined;
    kaynak?: string | undefined;
    tip?: string | undefined;
    haberno?: string | undefined;
    baslik?: string | undefined;
    icerik?: string | undefined;
    tarih?: string | undefined;
    c?: string | undefined;

    constructor(data?: IMatriksNewsModelData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.kaynak = _data["Kaynak"];
            this.tip = _data["Tip"];
            this.haberno = _data["Haberno"];
            this.baslik = _data["Baslik"];
            this.icerik = _data["Icerik"];
            this.tarih = _data["Tarih"];
            this.c = _data["C"];
        }
    }

    static fromJS(data: any): MatriksNewsModelData {
        data = typeof data === 'object' ? data : {};
        let result = new MatriksNewsModelData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Kaynak"] = this.kaynak;
        data["Tip"] = this.tip;
        data["Haberno"] = this.haberno;
        data["Baslik"] = this.baslik;
        data["Icerik"] = this.icerik;
        data["Tarih"] = this.tarih;
        data["C"] = this.c;
        return data;
    }
}

export interface IMatriksNewsModelData {
    id?: string | undefined;
    kaynak?: string | undefined;
    tip?: string | undefined;
    haberno?: string | undefined;
    baslik?: string | undefined;
    icerik?: string | undefined;
    tarih?: string | undefined;
    c?: string | undefined;
}

export class Media implements IMedia {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    isDeleted?: boolean;
    caption?: string | undefined;
    fileSize?: number;
    fileName?: string | undefined;
    mediaType?: MediaType;

    constructor(data?: IMedia) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.createdOn = _data["CreatedOn"] ? moment(_data["CreatedOn"].toString()) : <any>undefined;
            this.createdById = _data["CreatedById"];
            this.updatedOn = _data["UpdatedOn"] ? moment(_data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedById = _data["UpdatedById"];
            this.deletedOn = _data["DeletedOn"] ? moment(_data["DeletedOn"].toString()) : <any>undefined;
            this.deletedById = _data["DeletedById"];
            this.isDeleted = _data["IsDeleted"];
            this.caption = _data["Caption"];
            this.fileSize = _data["FileSize"];
            this.fileName = _data["FileName"];
            this.mediaType = _data["MediaType"];
        }
    }

    static fromJS(data: any): Media {
        data = typeof data === 'object' ? data : {};
        let result = new Media();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedById"] = this.createdById;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["DeletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        data["DeletedById"] = this.deletedById;
        data["IsDeleted"] = this.isDeleted;
        data["Caption"] = this.caption;
        data["FileSize"] = this.fileSize;
        data["FileName"] = this.fileName;
        data["MediaType"] = this.mediaType;
        return data;
    }
}

export interface IMedia {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    isDeleted?: boolean;
    caption?: string | undefined;
    fileSize?: number;
    fileName?: string | undefined;
    mediaType?: MediaType;
}

export class MediaModel implements IMediaModel {
    url?: string | undefined;
    thumbnailUrl?: string | undefined;

    constructor(data?: IMediaModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.url = _data["Url"];
            this.thumbnailUrl = _data["ThumbnailUrl"];
        }
    }

    static fromJS(data: any): MediaModel {
        data = typeof data === 'object' ? data : {};
        let result = new MediaModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Url"] = this.url;
        data["ThumbnailUrl"] = this.thumbnailUrl;
        return data;
    }
}

export interface IMediaModel {
    url?: string | undefined;
    thumbnailUrl?: string | undefined;
}

export enum MediaType {
    Image = "Image",
    Video = "Video",
    Document = "Document",
    Other = "Other",
}

export class Neighborhood implements INeighborhood {
    id?: number;
    districtId?: number;
    district?: District;
    name?: string | undefined;
    zipCode?: string | undefined;

    constructor(data?: INeighborhood) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.districtId = _data["DistrictId"];
            this.district = _data["District"] ? District.fromJS(_data["District"]) : <any>undefined;
            this.name = _data["Name"];
            this.zipCode = _data["ZipCode"];
        }
    }

    static fromJS(data: any): Neighborhood {
        data = typeof data === 'object' ? data : {};
        let result = new Neighborhood();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["DistrictId"] = this.districtId;
        data["District"] = this.district ? this.district.toJSON() : <any>undefined;
        data["Name"] = this.name;
        data["ZipCode"] = this.zipCode;
        return data;
    }
}

export interface INeighborhood {
    id?: number;
    districtId?: number;
    district?: District;
    name?: string | undefined;
    zipCode?: string | undefined;
}

export class NotificationModel implements INotificationModel {
    id?: number;
    title?: string | undefined;
    body?: string | undefined;
    data?: string | undefined;
    groupId?: number | undefined;
    group?: GroupModel;
    userId?: number | undefined;
    user?: UserModel;
    sendDate?: moment.Moment;
    sendFailCount?: number;
    typeId?: NotificationType;
    isSent?: boolean;
    isDeleted?: boolean;

    constructor(data?: INotificationModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.title = _data["Title"];
            this.body = _data["Body"];
            this.data = _data["Data"];
            this.groupId = _data["GroupId"];
            this.group = _data["Group"] ? GroupModel.fromJS(_data["Group"]) : <any>undefined;
            this.userId = _data["UserId"];
            this.user = _data["User"] ? UserModel.fromJS(_data["User"]) : <any>undefined;
            this.sendDate = _data["SendDate"] ? moment(_data["SendDate"].toString()) : <any>undefined;
            this.sendFailCount = _data["SendFailCount"];
            this.typeId = _data["TypeId"];
            this.isSent = _data["IsSent"];
            this.isDeleted = _data["IsDeleted"];
        }
    }

    static fromJS(data: any): NotificationModel {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Title"] = this.title;
        data["Body"] = this.body;
        data["Data"] = this.data;
        data["GroupId"] = this.groupId;
        data["Group"] = this.group ? this.group.toJSON() : <any>undefined;
        data["UserId"] = this.userId;
        data["User"] = this.user ? this.user.toJSON() : <any>undefined;
        data["SendDate"] = this.sendDate ? this.sendDate.toISOString() : <any>undefined;
        data["SendFailCount"] = this.sendFailCount;
        data["TypeId"] = this.typeId;
        data["IsSent"] = this.isSent;
        data["IsDeleted"] = this.isDeleted;
        return data;
    }
}

export interface INotificationModel {
    id?: number;
    title?: string | undefined;
    body?: string | undefined;
    data?: string | undefined;
    groupId?: number | undefined;
    group?: GroupModel;
    userId?: number | undefined;
    user?: UserModel;
    sendDate?: moment.Moment;
    sendFailCount?: number;
    typeId?: NotificationType;
    isSent?: boolean;
    isDeleted?: boolean;
}

export enum NotificationType {
    System = "System",
    Manual = "Manual",
}

export class Order implements IOrder {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    isDeleted?: boolean;
    userId?: number;
    user?: User;
    deliveryTime?: TimeSpan;
    subTotal?: number;
    total?: number;
    shippingAddressId?: number | undefined;
    shippingAddress?: OrderAddress;
    billingAddressId?: number | undefined;
    billingAddress?: OrderAddress;
    orderStatus?: OrderStatus;
    sourceTransactionId?: number | undefined;
    sourceTransaction?: Transaction;
    targetTransactionId?: number | undefined;
    targetTransaction?: Transaction;
    sourceAssetId?: number;
    sourceAsset?: Asset;
    targetAssetId?: number | undefined;
    targetAsset?: Asset;
    note?: string | undefined;
    isTest?: boolean;
    readonly orderItems?: OrderItem[] | undefined;

    constructor(data?: IOrder) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.createdOn = _data["CreatedOn"] ? moment(_data["CreatedOn"].toString()) : <any>undefined;
            this.createdById = _data["CreatedById"];
            this.updatedOn = _data["UpdatedOn"] ? moment(_data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedById = _data["UpdatedById"];
            this.deletedOn = _data["DeletedOn"] ? moment(_data["DeletedOn"].toString()) : <any>undefined;
            this.deletedById = _data["DeletedById"];
            this.isDeleted = _data["IsDeleted"];
            this.userId = _data["UserId"];
            this.user = _data["User"] ? User.fromJS(_data["User"]) : <any>undefined;
            this.deliveryTime = _data["DeliveryTime"] ? TimeSpan.fromJS(_data["DeliveryTime"]) : <any>undefined;
            this.subTotal = _data["SubTotal"];
            this.total = _data["Total"];
            this.shippingAddressId = _data["ShippingAddressId"];
            this.shippingAddress = _data["ShippingAddress"] ? OrderAddress.fromJS(_data["ShippingAddress"]) : <any>undefined;
            this.billingAddressId = _data["BillingAddressId"];
            this.billingAddress = _data["BillingAddress"] ? OrderAddress.fromJS(_data["BillingAddress"]) : <any>undefined;
            this.orderStatus = _data["OrderStatus"];
            this.sourceTransactionId = _data["SourceTransactionId"];
            this.sourceTransaction = _data["SourceTransaction"] ? Transaction.fromJS(_data["SourceTransaction"]) : <any>undefined;
            this.targetTransactionId = _data["TargetTransactionId"];
            this.targetTransaction = _data["TargetTransaction"] ? Transaction.fromJS(_data["TargetTransaction"]) : <any>undefined;
            this.sourceAssetId = _data["SourceAssetId"];
            this.sourceAsset = _data["SourceAsset"] ? Asset.fromJS(_data["SourceAsset"]) : <any>undefined;
            this.targetAssetId = _data["TargetAssetId"];
            this.targetAsset = _data["TargetAsset"] ? Asset.fromJS(_data["TargetAsset"]) : <any>undefined;
            this.note = _data["Note"];
            this.isTest = _data["IsTest"];
            if (Array.isArray(_data["OrderItems"])) {
                (<any>this).orderItems = [] as any;
                for (let item of _data["OrderItems"])
                    (<any>this).orderItems!.push(OrderItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Order {
        data = typeof data === 'object' ? data : {};
        let result = new Order();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedById"] = this.createdById;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["DeletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        data["DeletedById"] = this.deletedById;
        data["IsDeleted"] = this.isDeleted;
        data["UserId"] = this.userId;
        data["User"] = this.user ? this.user.toJSON() : <any>undefined;
        data["DeliveryTime"] = this.deliveryTime ? this.deliveryTime.toJSON() : <any>undefined;
        data["SubTotal"] = this.subTotal;
        data["Total"] = this.total;
        data["ShippingAddressId"] = this.shippingAddressId;
        data["ShippingAddress"] = this.shippingAddress ? this.shippingAddress.toJSON() : <any>undefined;
        data["BillingAddressId"] = this.billingAddressId;
        data["BillingAddress"] = this.billingAddress ? this.billingAddress.toJSON() : <any>undefined;
        data["OrderStatus"] = this.orderStatus;
        data["SourceTransactionId"] = this.sourceTransactionId;
        data["SourceTransaction"] = this.sourceTransaction ? this.sourceTransaction.toJSON() : <any>undefined;
        data["TargetTransactionId"] = this.targetTransactionId;
        data["TargetTransaction"] = this.targetTransaction ? this.targetTransaction.toJSON() : <any>undefined;
        data["SourceAssetId"] = this.sourceAssetId;
        data["SourceAsset"] = this.sourceAsset ? this.sourceAsset.toJSON() : <any>undefined;
        data["TargetAssetId"] = this.targetAssetId;
        data["TargetAsset"] = this.targetAsset ? this.targetAsset.toJSON() : <any>undefined;
        data["Note"] = this.note;
        data["IsTest"] = this.isTest;
        if (Array.isArray(this.orderItems)) {
            data["OrderItems"] = [];
            for (let item of this.orderItems)
                data["OrderItems"].push(item.toJSON());
        }
        return data;
    }
}

export interface IOrder {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    isDeleted?: boolean;
    userId?: number;
    user?: User;
    deliveryTime?: TimeSpan;
    subTotal?: number;
    total?: number;
    shippingAddressId?: number | undefined;
    shippingAddress?: OrderAddress;
    billingAddressId?: number | undefined;
    billingAddress?: OrderAddress;
    orderStatus?: OrderStatus;
    sourceTransactionId?: number | undefined;
    sourceTransaction?: Transaction;
    targetTransactionId?: number | undefined;
    targetTransaction?: Transaction;
    sourceAssetId?: number;
    sourceAsset?: Asset;
    targetAssetId?: number | undefined;
    targetAsset?: Asset;
    note?: string | undefined;
    isTest?: boolean;
    orderItems?: OrderItem[] | undefined;
}

export class OrderAddress implements IOrderAddress {
    id?: number;
    name?: string | undefined;
    contactName?: string | undefined;
    phone?: string | undefined;
    addressLine?: string | undefined;
    directions?: string | undefined;
    neighborhoodId?: number | undefined;
    neighborhood?: Neighborhood;
    districtId?: number;
    district?: District;
    provinceId?: number;
    province?: Province;
    countryId?: string | undefined;
    country?: Country;

    constructor(data?: IOrderAddress) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.name = _data["Name"];
            this.contactName = _data["ContactName"];
            this.phone = _data["Phone"];
            this.addressLine = _data["AddressLine"];
            this.directions = _data["Directions"];
            this.neighborhoodId = _data["NeighborhoodId"];
            this.neighborhood = _data["Neighborhood"] ? Neighborhood.fromJS(_data["Neighborhood"]) : <any>undefined;
            this.districtId = _data["DistrictId"];
            this.district = _data["District"] ? District.fromJS(_data["District"]) : <any>undefined;
            this.provinceId = _data["ProvinceId"];
            this.province = _data["Province"] ? Province.fromJS(_data["Province"]) : <any>undefined;
            this.countryId = _data["CountryId"];
            this.country = _data["Country"] ? Country.fromJS(_data["Country"]) : <any>undefined;
        }
    }

    static fromJS(data: any): OrderAddress {
        data = typeof data === 'object' ? data : {};
        let result = new OrderAddress();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Name"] = this.name;
        data["ContactName"] = this.contactName;
        data["Phone"] = this.phone;
        data["AddressLine"] = this.addressLine;
        data["Directions"] = this.directions;
        data["NeighborhoodId"] = this.neighborhoodId;
        data["Neighborhood"] = this.neighborhood ? this.neighborhood.toJSON() : <any>undefined;
        data["DistrictId"] = this.districtId;
        data["District"] = this.district ? this.district.toJSON() : <any>undefined;
        data["ProvinceId"] = this.provinceId;
        data["Province"] = this.province ? this.province.toJSON() : <any>undefined;
        data["CountryId"] = this.countryId;
        data["Country"] = this.country ? this.country.toJSON() : <any>undefined;
        return data;
    }
}

export interface IOrderAddress {
    id?: number;
    name?: string | undefined;
    contactName?: string | undefined;
    phone?: string | undefined;
    addressLine?: string | undefined;
    directions?: string | undefined;
    neighborhoodId?: number | undefined;
    neighborhood?: Neighborhood;
    districtId?: number;
    district?: District;
    provinceId?: number;
    province?: Province;
    countryId?: string | undefined;
    country?: Country;
}

export class OrderItem implements IOrderItem {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    isDeleted?: boolean;
    orderId?: number;
    order?: Order;
    productId?: number;
    product?: Product;
    quantity?: number;
    productPrice?: number;
    amount?: number;

    constructor(data?: IOrderItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.createdOn = _data["CreatedOn"] ? moment(_data["CreatedOn"].toString()) : <any>undefined;
            this.createdById = _data["CreatedById"];
            this.updatedOn = _data["UpdatedOn"] ? moment(_data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedById = _data["UpdatedById"];
            this.deletedOn = _data["DeletedOn"] ? moment(_data["DeletedOn"].toString()) : <any>undefined;
            this.deletedById = _data["DeletedById"];
            this.isDeleted = _data["IsDeleted"];
            this.orderId = _data["OrderId"];
            this.order = _data["Order"] ? Order.fromJS(_data["Order"]) : <any>undefined;
            this.productId = _data["ProductId"];
            this.product = _data["Product"] ? Product.fromJS(_data["Product"]) : <any>undefined;
            this.quantity = _data["Quantity"];
            this.productPrice = _data["ProductPrice"];
            this.amount = _data["Amount"];
        }
    }

    static fromJS(data: any): OrderItem {
        data = typeof data === 'object' ? data : {};
        let result = new OrderItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedById"] = this.createdById;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["DeletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        data["DeletedById"] = this.deletedById;
        data["IsDeleted"] = this.isDeleted;
        data["OrderId"] = this.orderId;
        data["Order"] = this.order ? this.order.toJSON() : <any>undefined;
        data["ProductId"] = this.productId;
        data["Product"] = this.product ? this.product.toJSON() : <any>undefined;
        data["Quantity"] = this.quantity;
        data["ProductPrice"] = this.productPrice;
        data["Amount"] = this.amount;
        return data;
    }
}

export interface IOrderItem {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    isDeleted?: boolean;
    orderId?: number;
    order?: Order;
    productId?: number;
    product?: Product;
    quantity?: number;
    productPrice?: number;
    amount?: number;
}

export class OrderItemModel implements IOrderItemModel {
    id?: number;
    orderId?: number;
    productId?: number;
    quantity?: number;
    productPrice?: number;
    amount?: number;

    constructor(data?: IOrderItemModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.orderId = _data["OrderId"];
            this.productId = _data["ProductId"];
            this.quantity = _data["Quantity"];
            this.productPrice = _data["ProductPrice"];
            this.amount = _data["Amount"];
        }
    }

    static fromJS(data: any): OrderItemModel {
        data = typeof data === 'object' ? data : {};
        let result = new OrderItemModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["OrderId"] = this.orderId;
        data["ProductId"] = this.productId;
        data["Quantity"] = this.quantity;
        data["ProductPrice"] = this.productPrice;
        data["Amount"] = this.amount;
        return data;
    }
}

export interface IOrderItemModel {
    id?: number;
    orderId?: number;
    productId?: number;
    quantity?: number;
    productPrice?: number;
    amount?: number;
}

export enum OrderStatus {
    OnHold = "OnHold",
    Pending = "Pending",
    Processing = "Processing",
    Cancelled = "Cancelled",
    Completed = "Completed",
    Refunded = "Refunded",
    Shipped = "Shipped",
}

export enum PaymentType {
    None = "None",
    Cash = "Cash",
    CreditCard = "CreditCard",
    StoredCard = "StoredCard",
    BankTransfer = "BankTransfer",
    SwiftTransfer = "SwiftTransfer",
    Cheque = "Cheque",
    GiftCard = "GiftCard",
    Paypal = "Paypal",
    Crypto = "Crypto",
    Metal = "Metal",
}

export class PostCategoryModel implements IPostCategoryModel {
    id?: number;
    name?: string | undefined;
    mediaId?: number | undefined;
    media?: MediaModel;

    constructor(data?: IPostCategoryModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.name = _data["Name"];
            this.mediaId = _data["MediaId"];
            this.media = _data["Media"] ? MediaModel.fromJS(_data["Media"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PostCategoryModel {
        data = typeof data === 'object' ? data : {};
        let result = new PostCategoryModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Name"] = this.name;
        data["MediaId"] = this.mediaId;
        data["Media"] = this.media ? this.media.toJSON() : <any>undefined;
        return data;
    }
}

export interface IPostCategoryModel {
    id?: number;
    name?: string | undefined;
    mediaId?: number | undefined;
    media?: MediaModel;
}

export class PostModel implements IPostModel {
    title!: string;
    subTitle?: string | undefined;
    slug?: string | undefined;
    metaKeywords?: string | undefined;
    metaDescription?: string | undefined;
    body?: string | undefined;
    mediaId?: number | undefined;
    media?: MediaModel;
    isPublished?: boolean;
    publishedOn?: moment.Moment | undefined;
    publishedTill?: moment.Moment | undefined;
    categoryId?: number | undefined;
    category?: PostCategoryModel;

    constructor(data?: IPostModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["Title"];
            this.subTitle = _data["SubTitle"];
            this.slug = _data["Slug"];
            this.metaKeywords = _data["MetaKeywords"];
            this.metaDescription = _data["MetaDescription"];
            this.body = _data["Body"];
            this.mediaId = _data["MediaId"];
            this.media = _data["Media"] ? MediaModel.fromJS(_data["Media"]) : <any>undefined;
            this.isPublished = _data["IsPublished"];
            this.publishedOn = _data["PublishedOn"] ? moment(_data["PublishedOn"].toString()) : <any>undefined;
            this.publishedTill = _data["PublishedTill"] ? moment(_data["PublishedTill"].toString()) : <any>undefined;
            this.categoryId = _data["CategoryId"];
            this.category = _data["Category"] ? PostCategoryModel.fromJS(_data["Category"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PostModel {
        data = typeof data === 'object' ? data : {};
        let result = new PostModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Title"] = this.title;
        data["SubTitle"] = this.subTitle;
        data["Slug"] = this.slug;
        data["MetaKeywords"] = this.metaKeywords;
        data["MetaDescription"] = this.metaDescription;
        data["Body"] = this.body;
        data["MediaId"] = this.mediaId;
        data["Media"] = this.media ? this.media.toJSON() : <any>undefined;
        data["IsPublished"] = this.isPublished;
        data["PublishedOn"] = this.publishedOn ? this.publishedOn.toISOString() : <any>undefined;
        data["PublishedTill"] = this.publishedTill ? this.publishedTill.toISOString() : <any>undefined;
        data["CategoryId"] = this.categoryId;
        data["Category"] = this.category ? this.category.toJSON() : <any>undefined;
        return data;
    }
}

export interface IPostModel {
    title: string;
    subTitle?: string | undefined;
    slug?: string | undefined;
    metaKeywords?: string | undefined;
    metaDescription?: string | undefined;
    body?: string | undefined;
    mediaId?: number | undefined;
    media?: MediaModel;
    isPublished?: boolean;
    publishedOn?: moment.Moment | undefined;
    publishedTill?: moment.Moment | undefined;
    categoryId?: number | undefined;
    category?: PostCategoryModel;
}

export class Product implements IProduct {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    isDeleted?: boolean;
    code?: string | undefined;
    barcode?: string | undefined;
    name?: string | undefined;
    normalizedName?: string | undefined;
    description?: string | undefined;
    specification?: string | undefined;
    brand?: string | undefined;
    price?: number;
    oldPrice?: number | undefined;
    specialPrice?: number | undefined;
    specialPriceStart?: moment.Moment | undefined;
    specialPriceEnd?: moment.Moment | undefined;
    stockQuantity?: number;
    displayOrder?: number;
    isFeatured?: boolean;
    isPublished?: boolean;
    unitId?: number;
    unit?: ProductUnit;
    productTypeId?: number;
    productType?: ProductType;
    mediaId?: number | undefined;
    media?: Media;
    yatirimimId?: number | undefined;
    readonly categories?: ProductCategory[] | undefined;

    constructor(data?: IProduct) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.createdOn = _data["CreatedOn"] ? moment(_data["CreatedOn"].toString()) : <any>undefined;
            this.createdById = _data["CreatedById"];
            this.updatedOn = _data["UpdatedOn"] ? moment(_data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedById = _data["UpdatedById"];
            this.deletedOn = _data["DeletedOn"] ? moment(_data["DeletedOn"].toString()) : <any>undefined;
            this.deletedById = _data["DeletedById"];
            this.isDeleted = _data["IsDeleted"];
            this.code = _data["Code"];
            this.barcode = _data["Barcode"];
            this.name = _data["Name"];
            this.normalizedName = _data["NormalizedName"];
            this.description = _data["Description"];
            this.specification = _data["Specification"];
            this.brand = _data["Brand"];
            this.price = _data["Price"];
            this.oldPrice = _data["OldPrice"];
            this.specialPrice = _data["SpecialPrice"];
            this.specialPriceStart = _data["SpecialPriceStart"] ? moment(_data["SpecialPriceStart"].toString()) : <any>undefined;
            this.specialPriceEnd = _data["SpecialPriceEnd"] ? moment(_data["SpecialPriceEnd"].toString()) : <any>undefined;
            this.stockQuantity = _data["StockQuantity"];
            this.displayOrder = _data["DisplayOrder"];
            this.isFeatured = _data["IsFeatured"];
            this.isPublished = _data["IsPublished"];
            this.unitId = _data["UnitId"];
            this.unit = _data["Unit"];
            this.productTypeId = _data["ProductTypeId"];
            this.productType = _data["ProductType"];
            this.mediaId = _data["MediaId"];
            this.media = _data["Media"] ? Media.fromJS(_data["Media"]) : <any>undefined;
            this.yatirimimId = _data["YatirimimId"];
            if (Array.isArray(_data["Categories"])) {
                (<any>this).categories = [] as any;
                for (let item of _data["Categories"])
                    (<any>this).categories!.push(ProductCategory.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Product {
        data = typeof data === 'object' ? data : {};
        let result = new Product();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedById"] = this.createdById;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["DeletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        data["DeletedById"] = this.deletedById;
        data["IsDeleted"] = this.isDeleted;
        data["Code"] = this.code;
        data["Barcode"] = this.barcode;
        data["Name"] = this.name;
        data["NormalizedName"] = this.normalizedName;
        data["Description"] = this.description;
        data["Specification"] = this.specification;
        data["Brand"] = this.brand;
        data["Price"] = this.price;
        data["OldPrice"] = this.oldPrice;
        data["SpecialPrice"] = this.specialPrice;
        data["SpecialPriceStart"] = this.specialPriceStart ? this.specialPriceStart.toISOString() : <any>undefined;
        data["SpecialPriceEnd"] = this.specialPriceEnd ? this.specialPriceEnd.toISOString() : <any>undefined;
        data["StockQuantity"] = this.stockQuantity;
        data["DisplayOrder"] = this.displayOrder;
        data["IsFeatured"] = this.isFeatured;
        data["IsPublished"] = this.isPublished;
        data["UnitId"] = this.unitId;
        data["Unit"] = this.unit;
        data["ProductTypeId"] = this.productTypeId;
        data["ProductType"] = this.productType;
        data["MediaId"] = this.mediaId;
        data["Media"] = this.media ? this.media.toJSON() : <any>undefined;
        data["YatirimimId"] = this.yatirimimId;
        if (Array.isArray(this.categories)) {
            data["Categories"] = [];
            for (let item of this.categories)
                data["Categories"].push(item.toJSON());
        }
        return data;
    }
}

export interface IProduct {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    isDeleted?: boolean;
    code?: string | undefined;
    barcode?: string | undefined;
    name?: string | undefined;
    normalizedName?: string | undefined;
    description?: string | undefined;
    specification?: string | undefined;
    brand?: string | undefined;
    price?: number;
    oldPrice?: number | undefined;
    specialPrice?: number | undefined;
    specialPriceStart?: moment.Moment | undefined;
    specialPriceEnd?: moment.Moment | undefined;
    stockQuantity?: number;
    displayOrder?: number;
    isFeatured?: boolean;
    isPublished?: boolean;
    unitId?: number;
    unit?: ProductUnit;
    productTypeId?: number;
    productType?: ProductType;
    mediaId?: number | undefined;
    media?: Media;
    yatirimimId?: number | undefined;
    categories?: ProductCategory[] | undefined;
}

export class ProductCategory implements IProductCategory {
    id?: number;
    productId?: number;
    product?: Product;
    categoryId?: number;
    category?: Category;

    constructor(data?: IProductCategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.productId = _data["ProductId"];
            this.product = _data["Product"] ? Product.fromJS(_data["Product"]) : <any>undefined;
            this.categoryId = _data["CategoryId"];
            this.category = _data["Category"] ? Category.fromJS(_data["Category"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ProductCategory {
        data = typeof data === 'object' ? data : {};
        let result = new ProductCategory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["ProductId"] = this.productId;
        data["Product"] = this.product ? this.product.toJSON() : <any>undefined;
        data["CategoryId"] = this.categoryId;
        data["Category"] = this.category ? this.category.toJSON() : <any>undefined;
        return data;
    }
}

export interface IProductCategory {
    id?: number;
    productId?: number;
    product?: Product;
    categoryId?: number;
    category?: Category;
}

export enum ProductType {
    Basic = "Basic",
    Grouped = "Grouped",
}

export enum ProductUnit {
    Piece = "Piece",
    Milligram = "Milligram",
    Gram = "Gram",
    Kilogram = "Kilogram",
    Millimetre = "Millimetre",
    Metre = "Metre",
}

export class Province implements IProvince {
    id?: number;
    countryId!: string;
    country?: Country;
    name!: string;
    type?: string | undefined;

    constructor(data?: IProvince) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.countryId = _data["CountryId"];
            this.country = _data["Country"] ? Country.fromJS(_data["Country"]) : <any>undefined;
            this.name = _data["Name"];
            this.type = _data["Type"];
        }
    }

    static fromJS(data: any): Province {
        data = typeof data === 'object' ? data : {};
        let result = new Province();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CountryId"] = this.countryId;
        data["Country"] = this.country ? this.country.toJSON() : <any>undefined;
        data["Name"] = this.name;
        data["Type"] = this.type;
        return data;
    }
}

export interface IProvince {
    id?: number;
    countryId: string;
    country?: Country;
    name: string;
    type?: string | undefined;
}

export class ProvinceModel implements IProvinceModel {
    id?: number;
    countryId!: string;
    country?: CountryModel;
    name!: string;
    type?: string | undefined;

    constructor(data?: IProvinceModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.countryId = _data["CountryId"];
            this.country = _data["Country"] ? CountryModel.fromJS(_data["Country"]) : <any>undefined;
            this.name = _data["Name"];
            this.type = _data["Type"];
        }
    }

    static fromJS(data: any): ProvinceModel {
        data = typeof data === 'object' ? data : {};
        let result = new ProvinceModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CountryId"] = this.countryId;
        data["Country"] = this.country ? this.country.toJSON() : <any>undefined;
        data["Name"] = this.name;
        data["Type"] = this.type;
        return data;
    }
}

export interface IProvinceModel {
    id?: number;
    countryId: string;
    country?: CountryModel;
    name: string;
    type?: string | undefined;
}

export class RegisterModel implements IRegisterModel {
    email?: string | undefined;
    phoneNumber?: string | undefined;
    password?: string | undefined;
    taxOffice?: string | undefined;
    taxNumber?: string | undefined;
    corporateName?: string | undefined;
    identityNo?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    isAcceptKvk?: boolean;
    isCorporate?: boolean;
    isAcceptTerms?: boolean;
    isAcceptContact?: boolean;

    constructor(data?: IRegisterModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["Email"];
            this.phoneNumber = _data["PhoneNumber"];
            this.password = _data["Password"];
            this.taxOffice = _data["TaxOffice"];
            this.taxNumber = _data["TaxNumber"];
            this.corporateName = _data["CorporateName"];
            this.identityNo = _data["IdentityNo"];
            this.firstName = _data["FirstName"];
            this.lastName = _data["LastName"];
            this.isAcceptKvk = _data["IsAcceptKvk"];
            this.isCorporate = _data["IsCorporate"];
            this.isAcceptTerms = _data["IsAcceptTerms"];
            this.isAcceptContact = _data["IsAcceptContact"];
        }
    }

    static fromJS(data: any): RegisterModel {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Email"] = this.email;
        data["PhoneNumber"] = this.phoneNumber;
        data["Password"] = this.password;
        data["TaxOffice"] = this.taxOffice;
        data["TaxNumber"] = this.taxNumber;
        data["CorporateName"] = this.corporateName;
        data["IdentityNo"] = this.identityNo;
        data["FirstName"] = this.firstName;
        data["LastName"] = this.lastName;
        data["IsAcceptKvk"] = this.isAcceptKvk;
        data["IsCorporate"] = this.isCorporate;
        data["IsAcceptTerms"] = this.isAcceptTerms;
        data["IsAcceptContact"] = this.isAcceptContact;
        return data;
    }
}

export interface IRegisterModel {
    email?: string | undefined;
    phoneNumber?: string | undefined;
    password?: string | undefined;
    taxOffice?: string | undefined;
    taxNumber?: string | undefined;
    corporateName?: string | undefined;
    identityNo?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    isAcceptKvk?: boolean;
    isCorporate?: boolean;
    isAcceptTerms?: boolean;
    isAcceptContact?: boolean;
}

export class Request implements IRequest {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    isDeleted?: boolean;
    userId?: number;
    user?: User;
    userBankAccountId?: number | undefined;
    userBankAccount?: UserBankAccount;
    requestType?: RequestType;
    demandType?: DemandType;
    requestStatus?: RequestStatus;
    comment?: string | undefined;
    quantity?: number;
    symbolId?: number;
    symbol?: Symbol;
    price?: number;
    kPayTransactionId?: string | undefined;

    constructor(data?: IRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.createdOn = _data["CreatedOn"] ? moment(_data["CreatedOn"].toString()) : <any>undefined;
            this.createdById = _data["CreatedById"];
            this.updatedOn = _data["UpdatedOn"] ? moment(_data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedById = _data["UpdatedById"];
            this.deletedOn = _data["DeletedOn"] ? moment(_data["DeletedOn"].toString()) : <any>undefined;
            this.deletedById = _data["DeletedById"];
            this.isDeleted = _data["IsDeleted"];
            this.userId = _data["UserId"];
            this.user = _data["User"] ? User.fromJS(_data["User"]) : <any>undefined;
            this.userBankAccountId = _data["UserBankAccountId"];
            this.userBankAccount = _data["UserBankAccount"] ? UserBankAccount.fromJS(_data["UserBankAccount"]) : <any>undefined;
            this.requestType = _data["RequestType"];
            this.demandType = _data["DemandType"];
            this.requestStatus = _data["RequestStatus"];
            this.comment = _data["Comment"];
            this.quantity = _data["Quantity"];
            this.symbolId = _data["SymbolId"];
            this.symbol = _data["Symbol"] ? Symbol.fromJS(_data["Symbol"]) : <any>undefined;
            this.price = _data["Price"];
            this.kPayTransactionId = _data["KPayTransactionId"];
        }
    }

    static fromJS(data: any): Request {
        data = typeof data === 'object' ? data : {};
        let result = new Request();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedById"] = this.createdById;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["DeletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        data["DeletedById"] = this.deletedById;
        data["IsDeleted"] = this.isDeleted;
        data["UserId"] = this.userId;
        data["User"] = this.user ? this.user.toJSON() : <any>undefined;
        data["UserBankAccountId"] = this.userBankAccountId;
        data["UserBankAccount"] = this.userBankAccount ? this.userBankAccount.toJSON() : <any>undefined;
        data["RequestType"] = this.requestType;
        data["DemandType"] = this.demandType;
        data["RequestStatus"] = this.requestStatus;
        data["Comment"] = this.comment;
        data["Quantity"] = this.quantity;
        data["SymbolId"] = this.symbolId;
        data["Symbol"] = this.symbol ? this.symbol.toJSON() : <any>undefined;
        data["Price"] = this.price;
        data["KPayTransactionId"] = this.kPayTransactionId;
        return data;
    }
}

export interface IRequest {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    isDeleted?: boolean;
    userId?: number;
    user?: User;
    userBankAccountId?: number | undefined;
    userBankAccount?: UserBankAccount;
    requestType?: RequestType;
    demandType?: DemandType;
    requestStatus?: RequestStatus;
    comment?: string | undefined;
    quantity?: number;
    symbolId?: number;
    symbol?: Symbol;
    price?: number;
    kPayTransactionId?: string | undefined;
}

export class RequestCompleteDigitalOrderModel implements IRequestCompleteDigitalOrderModel {
    userId?: number;
    paymentTypeId?: number;
    sourceAssetId?: number;
    targetAssetId?: number;
    subTotal?: number;
    total?: number;
    shippingAddressId?: number | undefined;
    billingAddressId?: number | undefined;
    readonly orderItems?: OrderItemModel[] | undefined;

    constructor(data?: IRequestCompleteDigitalOrderModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["UserId"];
            this.paymentTypeId = _data["PaymentTypeId"];
            this.sourceAssetId = _data["SourceAssetId"];
            this.targetAssetId = _data["TargetAssetId"];
            this.subTotal = _data["SubTotal"];
            this.total = _data["Total"];
            this.shippingAddressId = _data["ShippingAddressId"];
            this.billingAddressId = _data["BillingAddressId"];
            if (Array.isArray(_data["OrderItems"])) {
                (<any>this).orderItems = [] as any;
                for (let item of _data["OrderItems"])
                    (<any>this).orderItems!.push(OrderItemModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RequestCompleteDigitalOrderModel {
        data = typeof data === 'object' ? data : {};
        let result = new RequestCompleteDigitalOrderModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["UserId"] = this.userId;
        data["PaymentTypeId"] = this.paymentTypeId;
        data["SourceAssetId"] = this.sourceAssetId;
        data["TargetAssetId"] = this.targetAssetId;
        data["SubTotal"] = this.subTotal;
        data["Total"] = this.total;
        data["ShippingAddressId"] = this.shippingAddressId;
        data["BillingAddressId"] = this.billingAddressId;
        if (Array.isArray(this.orderItems)) {
            data["OrderItems"] = [];
            for (let item of this.orderItems)
                data["OrderItems"].push(item.toJSON());
        }
        return data;
    }
}

export interface IRequestCompleteDigitalOrderModel {
    userId?: number;
    paymentTypeId?: number;
    sourceAssetId?: number;
    targetAssetId?: number;
    subTotal?: number;
    total?: number;
    shippingAddressId?: number | undefined;
    billingAddressId?: number | undefined;
    orderItems?: OrderItemModel[] | undefined;
}

export class RequestModel implements IRequestModel {
    id?: number;
    userId?: number;
    user?: UserModel;
    userBankAccountId?: number | undefined;
    userBankAccount?: UserBankAccountModel;
    requestType?: RequestType;
    demandType?: DemandType;
    requestStatus?: RequestStatus;
    comment?: string | undefined;
    quantity?: number;
    symbolId?: number;
    symbol?: SymbolModel;
    price?: number;
    commission?: number;
    transactionAmount?: number;

    constructor(data?: IRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.userId = _data["UserId"];
            this.user = _data["User"] ? UserModel.fromJS(_data["User"]) : <any>undefined;
            this.userBankAccountId = _data["UserBankAccountId"];
            this.userBankAccount = _data["UserBankAccount"] ? UserBankAccountModel.fromJS(_data["UserBankAccount"]) : <any>undefined;
            this.requestType = _data["RequestType"];
            this.demandType = _data["DemandType"];
            this.requestStatus = _data["RequestStatus"];
            this.comment = _data["Comment"];
            this.quantity = _data["Quantity"];
            this.symbolId = _data["SymbolId"];
            this.symbol = _data["Symbol"] ? SymbolModel.fromJS(_data["Symbol"]) : <any>undefined;
            this.price = _data["Price"];
            this.commission = _data["Commission"];
            this.transactionAmount = _data["TransactionAmount"];
        }
    }

    static fromJS(data: any): RequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new RequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["UserId"] = this.userId;
        data["User"] = this.user ? this.user.toJSON() : <any>undefined;
        data["UserBankAccountId"] = this.userBankAccountId;
        data["UserBankAccount"] = this.userBankAccount ? this.userBankAccount.toJSON() : <any>undefined;
        data["RequestType"] = this.requestType;
        data["DemandType"] = this.demandType;
        data["RequestStatus"] = this.requestStatus;
        data["Comment"] = this.comment;
        data["Quantity"] = this.quantity;
        data["SymbolId"] = this.symbolId;
        data["Symbol"] = this.symbol ? this.symbol.toJSON() : <any>undefined;
        data["Price"] = this.price;
        data["Commission"] = this.commission;
        data["TransactionAmount"] = this.transactionAmount;
        return data;
    }
}

export interface IRequestModel {
    id?: number;
    userId?: number;
    user?: UserModel;
    userBankAccountId?: number | undefined;
    userBankAccount?: UserBankAccountModel;
    requestType?: RequestType;
    demandType?: DemandType;
    requestStatus?: RequestStatus;
    comment?: string | undefined;
    quantity?: number;
    symbolId?: number;
    symbol?: SymbolModel;
    price?: number;
    commission?: number;
    transactionAmount?: number;
}

export class RequestPhysicalOrderModel implements IRequestPhysicalOrderModel {
    userId?: number;
    paymnetTypeId?: number;
    sourceAssetId?: number;
    subTotal?: number;
    total?: number;
    shippingAddressId?: number | undefined;
    billingAddressId?: number | undefined;
    readonly orderItems?: OrderItemModel[] | undefined;

    constructor(data?: IRequestPhysicalOrderModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["UserId"];
            this.paymnetTypeId = _data["PaymnetTypeId"];
            this.sourceAssetId = _data["SourceAssetId"];
            this.subTotal = _data["SubTotal"];
            this.total = _data["Total"];
            this.shippingAddressId = _data["ShippingAddressId"];
            this.billingAddressId = _data["BillingAddressId"];
            if (Array.isArray(_data["OrderItems"])) {
                (<any>this).orderItems = [] as any;
                for (let item of _data["OrderItems"])
                    (<any>this).orderItems!.push(OrderItemModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RequestPhysicalOrderModel {
        data = typeof data === 'object' ? data : {};
        let result = new RequestPhysicalOrderModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["UserId"] = this.userId;
        data["PaymnetTypeId"] = this.paymnetTypeId;
        data["SourceAssetId"] = this.sourceAssetId;
        data["SubTotal"] = this.subTotal;
        data["Total"] = this.total;
        data["ShippingAddressId"] = this.shippingAddressId;
        data["BillingAddressId"] = this.billingAddressId;
        if (Array.isArray(this.orderItems)) {
            data["OrderItems"] = [];
            for (let item of this.orderItems)
                data["OrderItems"].push(item.toJSON());
        }
        return data;
    }
}

export interface IRequestPhysicalOrderModel {
    userId?: number;
    paymnetTypeId?: number;
    sourceAssetId?: number;
    subTotal?: number;
    total?: number;
    shippingAddressId?: number | undefined;
    billingAddressId?: number | undefined;
    orderItems?: OrderItemModel[] | undefined;
}

export enum RequestStatus {
    Pending = "Pending",
    Approved = "Approved",
    Reject = "Reject",
}

export enum RequestType {
    Withdrawals = "Withdrawals",
    Deposits = "Deposits",
}

export class ResponseDigitalOrderModel implements IResponseDigitalOrderModel {
    orderId?: number;
    userId?: number;
    paymnetTypeId?: number;
    sourceAssetId?: number;
    targetAssetId?: number;
    subTotal?: number;
    total?: number;
    shippingAddressId?: number | undefined;
    billingAddressId?: number | undefined;
    readonly orderItems?: OrderItemModel[] | undefined;

    constructor(data?: IResponseDigitalOrderModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.orderId = _data["OrderId"];
            this.userId = _data["UserId"];
            this.paymnetTypeId = _data["PaymnetTypeId"];
            this.sourceAssetId = _data["SourceAssetId"];
            this.targetAssetId = _data["TargetAssetId"];
            this.subTotal = _data["SubTotal"];
            this.total = _data["Total"];
            this.shippingAddressId = _data["ShippingAddressId"];
            this.billingAddressId = _data["BillingAddressId"];
            if (Array.isArray(_data["OrderItems"])) {
                (<any>this).orderItems = [] as any;
                for (let item of _data["OrderItems"])
                    (<any>this).orderItems!.push(OrderItemModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ResponseDigitalOrderModel {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseDigitalOrderModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["OrderId"] = this.orderId;
        data["UserId"] = this.userId;
        data["PaymnetTypeId"] = this.paymnetTypeId;
        data["SourceAssetId"] = this.sourceAssetId;
        data["TargetAssetId"] = this.targetAssetId;
        data["SubTotal"] = this.subTotal;
        data["Total"] = this.total;
        data["ShippingAddressId"] = this.shippingAddressId;
        data["BillingAddressId"] = this.billingAddressId;
        if (Array.isArray(this.orderItems)) {
            data["OrderItems"] = [];
            for (let item of this.orderItems)
                data["OrderItems"].push(item.toJSON());
        }
        return data;
    }
}

export interface IResponseDigitalOrderModel {
    orderId?: number;
    userId?: number;
    paymnetTypeId?: number;
    sourceAssetId?: number;
    targetAssetId?: number;
    subTotal?: number;
    total?: number;
    shippingAddressId?: number | undefined;
    billingAddressId?: number | undefined;
    orderItems?: OrderItemModel[] | undefined;
}

export class ResponsePhysicalOrderModel implements IResponsePhysicalOrderModel {
    orderId?: number;
    userId?: number;
    paymnetTypeId?: number;
    sourceAssetId?: number;
    subTotal?: number;
    total?: number;
    shippingAddressId?: number | undefined;
    billingAddressId?: number | undefined;
    readonly orderItems?: OrderItemModel[] | undefined;

    constructor(data?: IResponsePhysicalOrderModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.orderId = _data["OrderId"];
            this.userId = _data["UserId"];
            this.paymnetTypeId = _data["PaymnetTypeId"];
            this.sourceAssetId = _data["SourceAssetId"];
            this.subTotal = _data["SubTotal"];
            this.total = _data["Total"];
            this.shippingAddressId = _data["ShippingAddressId"];
            this.billingAddressId = _data["BillingAddressId"];
            if (Array.isArray(_data["OrderItems"])) {
                (<any>this).orderItems = [] as any;
                for (let item of _data["OrderItems"])
                    (<any>this).orderItems!.push(OrderItemModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ResponsePhysicalOrderModel {
        data = typeof data === 'object' ? data : {};
        let result = new ResponsePhysicalOrderModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["OrderId"] = this.orderId;
        data["UserId"] = this.userId;
        data["PaymnetTypeId"] = this.paymnetTypeId;
        data["SourceAssetId"] = this.sourceAssetId;
        data["SubTotal"] = this.subTotal;
        data["Total"] = this.total;
        data["ShippingAddressId"] = this.shippingAddressId;
        data["BillingAddressId"] = this.billingAddressId;
        if (Array.isArray(this.orderItems)) {
            data["OrderItems"] = [];
            for (let item of this.orderItems)
                data["OrderItems"].push(item.toJSON());
        }
        return data;
    }
}

export interface IResponsePhysicalOrderModel {
    orderId?: number;
    userId?: number;
    paymnetTypeId?: number;
    sourceAssetId?: number;
    subTotal?: number;
    total?: number;
    shippingAddressId?: number | undefined;
    billingAddressId?: number | undefined;
    orderItems?: OrderItemModel[] | undefined;
}

export class Retail implements IRetail {
    id?: number;
    nationalityId?: string | undefined;
    nationality?: Country;
    user?: User;
    identityNo?: string | undefined;
    passportNo?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    normalizedFirstName?: string | undefined;
    normalizedLastName?: string | undefined;
    fatherFirstName?: string | undefined;
    fatherLastName?: string | undefined;
    motherFirstName?: string | undefined;
    motherLastName?: string | undefined;
    gender?: Gender;
    bloodType?: BloodType;
    birthDate?: moment.Moment | undefined;
    birthInCountry?: boolean;
    birthPlaceCountry?: string | undefined;
    birthPlaceProvince?: string | undefined;
    birthPlaceNeighborhood?: string | undefined;
    birthRegisterNumber?: string | undefined;
    livingState?: string | undefined;
    maritalStatus?: string | undefined;
    religion?: string | undefined;
    isCitizen?: boolean;
    sSN?: string | undefined;
    job?: string | undefined;
    notes?: string | undefined;

    constructor(data?: IRetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.nationalityId = _data["NationalityId"];
            this.nationality = _data["Nationality"] ? Country.fromJS(_data["Nationality"]) : <any>undefined;
            this.user = _data["User"] ? User.fromJS(_data["User"]) : <any>undefined;
            this.identityNo = _data["IdentityNo"];
            this.passportNo = _data["PassportNo"];
            this.firstName = _data["FirstName"];
            this.lastName = _data["LastName"];
            this.normalizedFirstName = _data["NormalizedFirstName"];
            this.normalizedLastName = _data["NormalizedLastName"];
            this.fatherFirstName = _data["FatherFirstName"];
            this.fatherLastName = _data["FatherLastName"];
            this.motherFirstName = _data["MotherFirstName"];
            this.motherLastName = _data["MotherLastName"];
            this.gender = _data["Gender"];
            this.bloodType = _data["BloodType"];
            this.birthDate = _data["BirthDate"] ? moment(_data["BirthDate"].toString()) : <any>undefined;
            this.birthInCountry = _data["BirthInCountry"];
            this.birthPlaceCountry = _data["BirthPlaceCountry"];
            this.birthPlaceProvince = _data["BirthPlaceProvince"];
            this.birthPlaceNeighborhood = _data["BirthPlaceNeighborhood"];
            this.birthRegisterNumber = _data["BirthRegisterNumber"];
            this.livingState = _data["LivingState"];
            this.maritalStatus = _data["MaritalStatus"];
            this.religion = _data["Religion"];
            this.isCitizen = _data["IsCitizen"];
            this.sSN = _data["SSN"];
            this.job = _data["Job"];
            this.notes = _data["Notes"];
        }
    }

    static fromJS(data: any): Retail {
        data = typeof data === 'object' ? data : {};
        let result = new Retail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["NationalityId"] = this.nationalityId;
        data["Nationality"] = this.nationality ? this.nationality.toJSON() : <any>undefined;
        data["User"] = this.user ? this.user.toJSON() : <any>undefined;
        data["IdentityNo"] = this.identityNo;
        data["PassportNo"] = this.passportNo;
        data["FirstName"] = this.firstName;
        data["LastName"] = this.lastName;
        data["NormalizedFirstName"] = this.normalizedFirstName;
        data["NormalizedLastName"] = this.normalizedLastName;
        data["FatherFirstName"] = this.fatherFirstName;
        data["FatherLastName"] = this.fatherLastName;
        data["MotherFirstName"] = this.motherFirstName;
        data["MotherLastName"] = this.motherLastName;
        data["Gender"] = this.gender;
        data["BloodType"] = this.bloodType;
        data["BirthDate"] = this.birthDate ? this.birthDate.toISOString() : <any>undefined;
        data["BirthInCountry"] = this.birthInCountry;
        data["BirthPlaceCountry"] = this.birthPlaceCountry;
        data["BirthPlaceProvince"] = this.birthPlaceProvince;
        data["BirthPlaceNeighborhood"] = this.birthPlaceNeighborhood;
        data["BirthRegisterNumber"] = this.birthRegisterNumber;
        data["LivingState"] = this.livingState;
        data["MaritalStatus"] = this.maritalStatus;
        data["Religion"] = this.religion;
        data["IsCitizen"] = this.isCitizen;
        data["SSN"] = this.sSN;
        data["Job"] = this.job;
        data["Notes"] = this.notes;
        return data;
    }
}

export interface IRetail {
    id?: number;
    nationalityId?: string | undefined;
    nationality?: Country;
    user?: User;
    identityNo?: string | undefined;
    passportNo?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    normalizedFirstName?: string | undefined;
    normalizedLastName?: string | undefined;
    fatherFirstName?: string | undefined;
    fatherLastName?: string | undefined;
    motherFirstName?: string | undefined;
    motherLastName?: string | undefined;
    gender?: Gender;
    bloodType?: BloodType;
    birthDate?: moment.Moment | undefined;
    birthInCountry?: boolean;
    birthPlaceCountry?: string | undefined;
    birthPlaceProvince?: string | undefined;
    birthPlaceNeighborhood?: string | undefined;
    birthRegisterNumber?: string | undefined;
    livingState?: string | undefined;
    maritalStatus?: string | undefined;
    religion?: string | undefined;
    isCitizen?: boolean;
    sSN?: string | undefined;
    job?: string | undefined;
    notes?: string | undefined;
}

export class RetailModel implements IRetailModel {
    id?: number;
    nationalityId?: string | undefined;
    nationality?: CountryModel;
    user?: UserModel;
    identityNo?: string | undefined;
    passportNo?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    gender?: Gender;

    constructor(data?: IRetailModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.nationalityId = _data["NationalityId"];
            this.nationality = _data["Nationality"] ? CountryModel.fromJS(_data["Nationality"]) : <any>undefined;
            this.user = _data["User"] ? UserModel.fromJS(_data["User"]) : <any>undefined;
            this.identityNo = _data["IdentityNo"];
            this.passportNo = _data["PassportNo"];
            this.firstName = _data["FirstName"];
            this.lastName = _data["LastName"];
            this.gender = _data["Gender"];
        }
    }

    static fromJS(data: any): RetailModel {
        data = typeof data === 'object' ? data : {};
        let result = new RetailModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["NationalityId"] = this.nationalityId;
        data["Nationality"] = this.nationality ? this.nationality.toJSON() : <any>undefined;
        data["User"] = this.user ? this.user.toJSON() : <any>undefined;
        data["IdentityNo"] = this.identityNo;
        data["PassportNo"] = this.passportNo;
        data["FirstName"] = this.firstName;
        data["LastName"] = this.lastName;
        data["Gender"] = this.gender;
        return data;
    }
}

export interface IRetailModel {
    id?: number;
    nationalityId?: string | undefined;
    nationality?: CountryModel;
    user?: UserModel;
    identityNo?: string | undefined;
    passportNo?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    gender?: Gender;
}

export class Role implements IRole {
    id?: number;
    name?: string | undefined;
    normalizedName?: string | undefined;
    concurrencyStamp?: string | undefined;
    description?: string | undefined;
    userRoles?: UserRole[] | undefined;
    isDeleted?: boolean;

    constructor(data?: IRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.name = _data["Name"];
            this.normalizedName = _data["NormalizedName"];
            this.concurrencyStamp = _data["ConcurrencyStamp"];
            this.description = _data["Description"];
            if (Array.isArray(_data["UserRoles"])) {
                this.userRoles = [] as any;
                for (let item of _data["UserRoles"])
                    this.userRoles!.push(UserRole.fromJS(item));
            }
            this.isDeleted = _data["IsDeleted"];
        }
    }

    static fromJS(data: any): Role {
        data = typeof data === 'object' ? data : {};
        let result = new Role();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Name"] = this.name;
        data["NormalizedName"] = this.normalizedName;
        data["ConcurrencyStamp"] = this.concurrencyStamp;
        data["Description"] = this.description;
        if (Array.isArray(this.userRoles)) {
            data["UserRoles"] = [];
            for (let item of this.userRoles)
                data["UserRoles"].push(item.toJSON());
        }
        data["IsDeleted"] = this.isDeleted;
        return data;
    }
}

export interface IRole {
    id?: number;
    name?: string | undefined;
    normalizedName?: string | undefined;
    concurrencyStamp?: string | undefined;
    description?: string | undefined;
    userRoles?: UserRole[] | undefined;
    isDeleted?: boolean;
}

export class RssFeedModel implements IRssFeedModel {
    id?: number;
    title!: string;
    subTitle?: string | undefined;
    link!: string;

    constructor(data?: IRssFeedModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.title = _data["Title"];
            this.subTitle = _data["SubTitle"];
            this.link = _data["Link"];
        }
    }

    static fromJS(data: any): RssFeedModel {
        data = typeof data === 'object' ? data : {};
        let result = new RssFeedModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Title"] = this.title;
        data["SubTitle"] = this.subTitle;
        data["Link"] = this.link;
        return data;
    }
}

export interface IRssFeedModel {
    id?: number;
    title: string;
    subTitle?: string | undefined;
    link: string;
}

export enum ScanType {
    FrontSide = "FrontSide",
    BackSide = "BackSide",
}

export class SettingModel implements ISettingModel {
    id?: number;
    key?: string | undefined;
    value?: string | undefined;

    constructor(data?: ISettingModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.key = _data["Key"];
            this.value = _data["Value"];
        }
    }

    static fromJS(data: any): SettingModel {
        data = typeof data === 'object' ? data : {};
        let result = new SettingModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Key"] = this.key;
        data["Value"] = this.value;
        return data;
    }
}

export interface ISettingModel {
    id?: number;
    key?: string | undefined;
    value?: string | undefined;
}

export class SlideModel implements ISlideModel {
    id?: number;
    title!: string;
    description!: string;
    darkMediaUrl?: string | undefined;
    lightMediaUrl!: string;
    displayOrder?: number;

    constructor(data?: ISlideModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.title = _data["Title"];
            this.description = _data["Description"];
            this.darkMediaUrl = _data["DarkMediaUrl"];
            this.lightMediaUrl = _data["LightMediaUrl"];
            this.displayOrder = _data["DisplayOrder"];
        }
    }

    static fromJS(data: any): SlideModel {
        data = typeof data === 'object' ? data : {};
        let result = new SlideModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Title"] = this.title;
        data["Description"] = this.description;
        data["DarkMediaUrl"] = this.darkMediaUrl;
        data["LightMediaUrl"] = this.lightMediaUrl;
        data["DisplayOrder"] = this.displayOrder;
        return data;
    }
}

export interface ISlideModel {
    id?: number;
    title: string;
    description: string;
    darkMediaUrl?: string | undefined;
    lightMediaUrl: string;
    displayOrder?: number;
}

export class StaticPageModel implements IStaticPageModel {
    title!: string;
    subTitle?: string | undefined;
    slug?: string | undefined;
    metaKeywords?: string | undefined;
    metaDescription?: string | undefined;
    body?: string | undefined;
    mediaId?: number | undefined;
    media?: MediaModel;
    isPublished?: boolean;
    publishedOn?: moment.Moment | undefined;
    publishedTill?: moment.Moment | undefined;

    constructor(data?: IStaticPageModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["Title"];
            this.subTitle = _data["SubTitle"];
            this.slug = _data["Slug"];
            this.metaKeywords = _data["MetaKeywords"];
            this.metaDescription = _data["MetaDescription"];
            this.body = _data["Body"];
            this.mediaId = _data["MediaId"];
            this.media = _data["Media"] ? MediaModel.fromJS(_data["Media"]) : <any>undefined;
            this.isPublished = _data["IsPublished"];
            this.publishedOn = _data["PublishedOn"] ? moment(_data["PublishedOn"].toString()) : <any>undefined;
            this.publishedTill = _data["PublishedTill"] ? moment(_data["PublishedTill"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): StaticPageModel {
        data = typeof data === 'object' ? data : {};
        let result = new StaticPageModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Title"] = this.title;
        data["SubTitle"] = this.subTitle;
        data["Slug"] = this.slug;
        data["MetaKeywords"] = this.metaKeywords;
        data["MetaDescription"] = this.metaDescription;
        data["Body"] = this.body;
        data["MediaId"] = this.mediaId;
        data["Media"] = this.media ? this.media.toJSON() : <any>undefined;
        data["IsPublished"] = this.isPublished;
        data["PublishedOn"] = this.publishedOn ? this.publishedOn.toISOString() : <any>undefined;
        data["PublishedTill"] = this.publishedTill ? this.publishedTill.toISOString() : <any>undefined;
        return data;
    }
}

export interface IStaticPageModel {
    title: string;
    subTitle?: string | undefined;
    slug?: string | undefined;
    metaKeywords?: string | undefined;
    metaDescription?: string | undefined;
    body?: string | undefined;
    mediaId?: number | undefined;
    media?: MediaModel;
    isPublished?: boolean;
    publishedOn?: moment.Moment | undefined;
    publishedTill?: moment.Moment | undefined;
}

export class Symbol implements ISymbol {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    isDeleted?: boolean;
    countryId?: string | undefined;
    country?: Country;
    symbolType?: SymbolType;
    mediaId?: number | undefined;
    media?: Media;
    baseSymbolId?: number | undefined;
    baseSymbol?: Symbol;
    isoCode?: string | undefined;
    currencySymbol?: string | undefined;
    matriksId?: number;
    matriksCode?: string | undefined;
    name?: string | undefined;
    isActive?: boolean;
    isSyncRateEnabled?: boolean;
    isMainCurrency?: boolean;
    isTradeable?: boolean;
    buyMultiplier?: number;
    buyAddPercent?: number;
    buyAddValue?: number;
    sellAddPercent?: number;
    sellMultiplier?: number;
    sellAddValue?: number;

    constructor(data?: ISymbol) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.createdOn = _data["CreatedOn"] ? moment(_data["CreatedOn"].toString()) : <any>undefined;
            this.createdById = _data["CreatedById"];
            this.updatedOn = _data["UpdatedOn"] ? moment(_data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedById = _data["UpdatedById"];
            this.deletedOn = _data["DeletedOn"] ? moment(_data["DeletedOn"].toString()) : <any>undefined;
            this.deletedById = _data["DeletedById"];
            this.isDeleted = _data["IsDeleted"];
            this.countryId = _data["CountryId"];
            this.country = _data["Country"] ? Country.fromJS(_data["Country"]) : <any>undefined;
            this.symbolType = _data["SymbolType"];
            this.mediaId = _data["MediaId"];
            this.media = _data["Media"] ? Media.fromJS(_data["Media"]) : <any>undefined;
            this.baseSymbolId = _data["BaseSymbolId"];
            this.baseSymbol = _data["BaseSymbol"] ? Symbol.fromJS(_data["BaseSymbol"]) : <any>undefined;
            this.isoCode = _data["IsoCode"];
            this.currencySymbol = _data["CurrencySymbol"];
            this.matriksId = _data["MatriksId"];
            this.matriksCode = _data["MatriksCode"];
            this.name = _data["Name"];
            this.isActive = _data["IsActive"];
            this.isSyncRateEnabled = _data["IsSyncRateEnabled"];
            this.isMainCurrency = _data["IsMainCurrency"];
            this.isTradeable = _data["IsTradeable"];
            this.buyMultiplier = _data["BuyMultiplier"];
            this.buyAddPercent = _data["BuyAddPercent"];
            this.buyAddValue = _data["BuyAddValue"];
            this.sellAddPercent = _data["SellAddPercent"];
            this.sellMultiplier = _data["SellMultiplier"];
            this.sellAddValue = _data["SellAddValue"];
        }
    }

    static fromJS(data: any): Symbol {
        data = typeof data === 'object' ? data : {};
        let result = new Symbol();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedById"] = this.createdById;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["DeletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        data["DeletedById"] = this.deletedById;
        data["IsDeleted"] = this.isDeleted;
        data["CountryId"] = this.countryId;
        data["Country"] = this.country ? this.country.toJSON() : <any>undefined;
        data["SymbolType"] = this.symbolType;
        data["MediaId"] = this.mediaId;
        data["Media"] = this.media ? this.media.toJSON() : <any>undefined;
        data["BaseSymbolId"] = this.baseSymbolId;
        data["BaseSymbol"] = this.baseSymbol ? this.baseSymbol.toJSON() : <any>undefined;
        data["IsoCode"] = this.isoCode;
        data["CurrencySymbol"] = this.currencySymbol;
        data["MatriksId"] = this.matriksId;
        data["MatriksCode"] = this.matriksCode;
        data["Name"] = this.name;
        data["IsActive"] = this.isActive;
        data["IsSyncRateEnabled"] = this.isSyncRateEnabled;
        data["IsMainCurrency"] = this.isMainCurrency;
        data["IsTradeable"] = this.isTradeable;
        data["BuyMultiplier"] = this.buyMultiplier;
        data["BuyAddPercent"] = this.buyAddPercent;
        data["BuyAddValue"] = this.buyAddValue;
        data["SellAddPercent"] = this.sellAddPercent;
        data["SellMultiplier"] = this.sellMultiplier;
        data["SellAddValue"] = this.sellAddValue;
        return data;
    }
}

export interface ISymbol {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    isDeleted?: boolean;
    countryId?: string | undefined;
    country?: Country;
    symbolType?: SymbolType;
    mediaId?: number | undefined;
    media?: Media;
    baseSymbolId?: number | undefined;
    baseSymbol?: Symbol;
    isoCode?: string | undefined;
    currencySymbol?: string | undefined;
    matriksId?: number;
    matriksCode?: string | undefined;
    name?: string | undefined;
    isActive?: boolean;
    isSyncRateEnabled?: boolean;
    isMainCurrency?: boolean;
    isTradeable?: boolean;
    buyMultiplier?: number;
    buyAddPercent?: number;
    buyAddValue?: number;
    sellAddPercent?: number;
    sellMultiplier?: number;
    sellAddValue?: number;
}

export class SymbolAlarmModel implements ISymbolAlarmModel {
    symbolAlarmType?: SymbolAlarmType;
    value?: number;
    isRate?: boolean;
    whileOnStatus?: boolean;
    anyTimeStatus?: boolean;
    validityStatus?: boolean;
    userId?: number;
    user?: UserModel;
    symbolId?: number;
    symbol?: SymbolModel;
    transactionType?: TransactionType;

    constructor(data?: ISymbolAlarmModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.symbolAlarmType = _data["SymbolAlarmType"];
            this.value = _data["Value"];
            this.isRate = _data["IsRate"];
            this.whileOnStatus = _data["WhileOnStatus"];
            this.anyTimeStatus = _data["AnyTimeStatus"];
            this.validityStatus = _data["ValidityStatus"];
            this.userId = _data["UserId"];
            this.user = _data["User"] ? UserModel.fromJS(_data["User"]) : <any>undefined;
            this.symbolId = _data["SymbolId"];
            this.symbol = _data["Symbol"] ? SymbolModel.fromJS(_data["Symbol"]) : <any>undefined;
            this.transactionType = _data["TransactionType"];
        }
    }

    static fromJS(data: any): SymbolAlarmModel {
        data = typeof data === 'object' ? data : {};
        let result = new SymbolAlarmModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["SymbolAlarmType"] = this.symbolAlarmType;
        data["Value"] = this.value;
        data["IsRate"] = this.isRate;
        data["WhileOnStatus"] = this.whileOnStatus;
        data["AnyTimeStatus"] = this.anyTimeStatus;
        data["ValidityStatus"] = this.validityStatus;
        data["UserId"] = this.userId;
        data["User"] = this.user ? this.user.toJSON() : <any>undefined;
        data["SymbolId"] = this.symbolId;
        data["Symbol"] = this.symbol ? this.symbol.toJSON() : <any>undefined;
        data["TransactionType"] = this.transactionType;
        return data;
    }
}

export interface ISymbolAlarmModel {
    symbolAlarmType?: SymbolAlarmType;
    value?: number;
    isRate?: boolean;
    whileOnStatus?: boolean;
    anyTimeStatus?: boolean;
    validityStatus?: boolean;
    userId?: number;
    user?: UserModel;
    symbolId?: number;
    symbol?: SymbolModel;
    transactionType?: TransactionType;
}

export enum SymbolAlarmType {
    Unknown = "Unknown",
}

export class SymbolModel implements ISymbolModel {
    id?: number;
    countryId?: string | undefined;
    country?: CountryModel;
    symbolType?: string | undefined;
    isoCode?: string | undefined;
    matriksId?: number;
    matriksCode?: string | undefined;
    currencySymbol?: string | undefined;
    name?: string | undefined;
    isActive?: boolean;
    isSyncRateEnabled?: boolean;
    isMainCurrency?: boolean;
    isTradeable?: boolean;
    buyAddPercent?: number;
    buyAddValue?: number;
    sellAddPercent?: number;
    sellAddValue?: number;

    constructor(data?: ISymbolModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.countryId = _data["CountryId"];
            this.country = _data["Country"] ? CountryModel.fromJS(_data["Country"]) : <any>undefined;
            this.symbolType = _data["SymbolType"];
            this.isoCode = _data["IsoCode"];
            this.matriksId = _data["MatriksId"];
            this.matriksCode = _data["MatriksCode"];
            this.currencySymbol = _data["CurrencySymbol"];
            this.name = _data["Name"];
            this.isActive = _data["IsActive"];
            this.isSyncRateEnabled = _data["IsSyncRateEnabled"];
            this.isMainCurrency = _data["IsMainCurrency"];
            this.isTradeable = _data["IsTradeable"];
            this.buyAddPercent = _data["BuyAddPercent"];
            this.buyAddValue = _data["BuyAddValue"];
            this.sellAddPercent = _data["SellAddPercent"];
            this.sellAddValue = _data["SellAddValue"];
        }
    }

    static fromJS(data: any): SymbolModel {
        data = typeof data === 'object' ? data : {};
        let result = new SymbolModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CountryId"] = this.countryId;
        data["Country"] = this.country ? this.country.toJSON() : <any>undefined;
        data["SymbolType"] = this.symbolType;
        data["IsoCode"] = this.isoCode;
        data["MatriksId"] = this.matriksId;
        data["MatriksCode"] = this.matriksCode;
        data["CurrencySymbol"] = this.currencySymbol;
        data["Name"] = this.name;
        data["IsActive"] = this.isActive;
        data["IsSyncRateEnabled"] = this.isSyncRateEnabled;
        data["IsMainCurrency"] = this.isMainCurrency;
        data["IsTradeable"] = this.isTradeable;
        data["BuyAddPercent"] = this.buyAddPercent;
        data["BuyAddValue"] = this.buyAddValue;
        data["SellAddPercent"] = this.sellAddPercent;
        data["SellAddValue"] = this.sellAddValue;
        return data;
    }
}

export interface ISymbolModel {
    id?: number;
    countryId?: string | undefined;
    country?: CountryModel;
    symbolType?: string | undefined;
    isoCode?: string | undefined;
    matriksId?: number;
    matriksCode?: string | undefined;
    currencySymbol?: string | undefined;
    name?: string | undefined;
    isActive?: boolean;
    isSyncRateEnabled?: boolean;
    isMainCurrency?: boolean;
    isTradeable?: boolean;
    buyAddPercent?: number;
    buyAddValue?: number;
    sellAddPercent?: number;
    sellAddValue?: number;
}

export class SymbolRateModel implements ISymbolRateModel {
    symbolId?: number;
    symbolType?: string | undefined;
    isoCode?: string | undefined;
    matriksId?: number;
    matriksCode?: string | undefined;
    currencySymbol?: string | undefined;
    name?: string | undefined;
    isMainCurrency?: boolean;
    isTradeable?: boolean;
    rateDate?: moment.Moment;
    buy?: number;
    sell?: number;
    difference?: number;
    min?: number;
    max?: number;
    minYear?: number;
    maxYear?: number;
    dailyChangePercent?: number;
    latestClosing?: number;
    opening?: number;
    volumeLot?: number;
    volumeTry?: number;
    capital?: number;

    constructor(data?: ISymbolRateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.symbolId = _data["SymbolId"];
            this.symbolType = _data["SymbolType"];
            this.isoCode = _data["IsoCode"];
            this.matriksId = _data["MatriksId"];
            this.matriksCode = _data["MatriksCode"];
            this.currencySymbol = _data["CurrencySymbol"];
            this.name = _data["Name"];
            this.isMainCurrency = _data["IsMainCurrency"];
            this.isTradeable = _data["IsTradeable"];
            this.rateDate = _data["RateDate"] ? moment(_data["RateDate"].toString()) : <any>undefined;
            this.buy = _data["Buy"];
            this.sell = _data["Sell"];
            this.difference = _data["Difference"];
            this.min = _data["Min"];
            this.max = _data["Max"];
            this.minYear = _data["MinYear"];
            this.maxYear = _data["MaxYear"];
            this.dailyChangePercent = _data["DailyChangePercent"];
            this.latestClosing = _data["LatestClosing"];
            this.opening = _data["Opening"];
            this.volumeLot = _data["VolumeLot"];
            this.volumeTry = _data["VolumeTry"];
            this.capital = _data["Capital"];
        }
    }

    static fromJS(data: any): SymbolRateModel {
        data = typeof data === 'object' ? data : {};
        let result = new SymbolRateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["SymbolId"] = this.symbolId;
        data["SymbolType"] = this.symbolType;
        data["IsoCode"] = this.isoCode;
        data["MatriksId"] = this.matriksId;
        data["MatriksCode"] = this.matriksCode;
        data["CurrencySymbol"] = this.currencySymbol;
        data["Name"] = this.name;
        data["IsMainCurrency"] = this.isMainCurrency;
        data["IsTradeable"] = this.isTradeable;
        data["RateDate"] = this.rateDate ? this.rateDate.toISOString() : <any>undefined;
        data["Buy"] = this.buy;
        data["Sell"] = this.sell;
        data["Difference"] = this.difference;
        data["Min"] = this.min;
        data["Max"] = this.max;
        data["MinYear"] = this.minYear;
        data["MaxYear"] = this.maxYear;
        data["DailyChangePercent"] = this.dailyChangePercent;
        data["LatestClosing"] = this.latestClosing;
        data["Opening"] = this.opening;
        data["VolumeLot"] = this.volumeLot;
        data["VolumeTry"] = this.volumeTry;
        data["Capital"] = this.capital;
        return data;
    }
}

export interface ISymbolRateModel {
    symbolId?: number;
    symbolType?: string | undefined;
    isoCode?: string | undefined;
    matriksId?: number;
    matriksCode?: string | undefined;
    currencySymbol?: string | undefined;
    name?: string | undefined;
    isMainCurrency?: boolean;
    isTradeable?: boolean;
    rateDate?: moment.Moment;
    buy?: number;
    sell?: number;
    difference?: number;
    min?: number;
    max?: number;
    minYear?: number;
    maxYear?: number;
    dailyChangePercent?: number;
    latestClosing?: number;
    opening?: number;
    volumeLot?: number;
    volumeTry?: number;
    capital?: number;
}

export enum SymbolType {
    Forex = "Forex",
    Metal = "Metal",
    Index = "Index",
    Commodity = "Commodity",
    Future = "Future",
    Share = "Share",
    Crypto = "Crypto",
    Sarrafiye = "Sarrafiye",
}

export class SymbolVoteRequestModel implements ISymbolVoteRequestModel {
    userId?: number;
    symbolId?: number;
    vote?: boolean;

    constructor(data?: ISymbolVoteRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["UserId"];
            this.symbolId = _data["SymbolId"];
            this.vote = _data["Vote"];
        }
    }

    static fromJS(data: any): SymbolVoteRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new SymbolVoteRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["UserId"] = this.userId;
        data["SymbolId"] = this.symbolId;
        data["Vote"] = this.vote;
        return data;
    }
}

export interface ISymbolVoteRequestModel {
    userId?: number;
    symbolId?: number;
    vote?: boolean;
}

export class SymbolVoteSummaryModel implements ISymbolVoteSummaryModel {
    increasingCount?: number;
    decreasingCount?: number;
    hasUserVote?: boolean;
    userVote?: boolean;

    constructor(data?: ISymbolVoteSummaryModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.increasingCount = _data["IncreasingCount"];
            this.decreasingCount = _data["DecreasingCount"];
            this.hasUserVote = _data["HasUserVote"];
            this.userVote = _data["UserVote"];
        }
    }

    static fromJS(data: any): SymbolVoteSummaryModel {
        data = typeof data === 'object' ? data : {};
        let result = new SymbolVoteSummaryModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["IncreasingCount"] = this.increasingCount;
        data["DecreasingCount"] = this.decreasingCount;
        data["HasUserVote"] = this.hasUserVote;
        data["UserVote"] = this.userVote;
        return data;
    }
}

export interface ISymbolVoteSummaryModel {
    increasingCount?: number;
    decreasingCount?: number;
    hasUserVote?: boolean;
    userVote?: boolean;
}

export class TimeSpan implements ITimeSpan {
    ticks?: number;
    readonly days?: number;
    readonly hours?: number;
    readonly milliseconds?: number;
    readonly minutes?: number;
    readonly seconds?: number;
    readonly totalDays?: number;
    readonly totalHours?: number;
    readonly totalMilliseconds?: number;
    readonly totalMinutes?: number;
    readonly totalSeconds?: number;

    constructor(data?: ITimeSpan) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ticks = _data["Ticks"];
            (<any>this).days = _data["Days"];
            (<any>this).hours = _data["Hours"];
            (<any>this).milliseconds = _data["Milliseconds"];
            (<any>this).minutes = _data["Minutes"];
            (<any>this).seconds = _data["Seconds"];
            (<any>this).totalDays = _data["TotalDays"];
            (<any>this).totalHours = _data["TotalHours"];
            (<any>this).totalMilliseconds = _data["TotalMilliseconds"];
            (<any>this).totalMinutes = _data["TotalMinutes"];
            (<any>this).totalSeconds = _data["TotalSeconds"];
        }
    }

    static fromJS(data: any): TimeSpan {
        data = typeof data === 'object' ? data : {};
        let result = new TimeSpan();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Ticks"] = this.ticks;
        data["Days"] = this.days;
        data["Hours"] = this.hours;
        data["Milliseconds"] = this.milliseconds;
        data["Minutes"] = this.minutes;
        data["Seconds"] = this.seconds;
        data["TotalDays"] = this.totalDays;
        data["TotalHours"] = this.totalHours;
        data["TotalMilliseconds"] = this.totalMilliseconds;
        data["TotalMinutes"] = this.totalMinutes;
        data["TotalSeconds"] = this.totalSeconds;
        return data;
    }
}

export interface ITimeSpan {
    ticks?: number;
    days?: number;
    hours?: number;
    milliseconds?: number;
    minutes?: number;
    seconds?: number;
    totalDays?: number;
    totalHours?: number;
    totalMilliseconds?: number;
    totalMinutes?: number;
    totalSeconds?: number;
}

export class TokenModel implements ITokenModel {
    token?: string | undefined;

    constructor(data?: ITokenModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["Token"];
        }
    }

    static fromJS(data: any): TokenModel {
        data = typeof data === 'object' ? data : {};
        let result = new TokenModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Token"] = this.token;
        return data;
    }
}

export interface ITokenModel {
    token?: string | undefined;
}

export class Transaction implements ITransaction {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    isDeleted?: boolean;
    userId?: number;
    user?: User;
    symbolId?: number;
    symbol?: Symbol;
    transactionTypeId?: number;
    transactionType?: TransactionType;
    paymentType?: PaymentType;
    actionDate?: moment.Moment;
    quantity?: number;
    amount?: number;
    netAmount?: number;
    commissionAmount?: number;
    tax?: number;
    kpayTxnId?: string | undefined;
    paymentCardId?: string | undefined;
    paymentMessage?: string | undefined;
    description?: string | undefined;

    constructor(data?: ITransaction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.createdOn = _data["CreatedOn"] ? moment(_data["CreatedOn"].toString()) : <any>undefined;
            this.createdById = _data["CreatedById"];
            this.updatedOn = _data["UpdatedOn"] ? moment(_data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedById = _data["UpdatedById"];
            this.deletedOn = _data["DeletedOn"] ? moment(_data["DeletedOn"].toString()) : <any>undefined;
            this.deletedById = _data["DeletedById"];
            this.isDeleted = _data["IsDeleted"];
            this.userId = _data["UserId"];
            this.user = _data["User"] ? User.fromJS(_data["User"]) : <any>undefined;
            this.symbolId = _data["SymbolId"];
            this.symbol = _data["Symbol"] ? Symbol.fromJS(_data["Symbol"]) : <any>undefined;
            this.transactionTypeId = _data["TransactionTypeId"];
            this.transactionType = _data["TransactionType"];
            this.paymentType = _data["PaymentType"];
            this.actionDate = _data["ActionDate"] ? moment(_data["ActionDate"].toString()) : <any>undefined;
            this.quantity = _data["Quantity"];
            this.amount = _data["Amount"];
            this.netAmount = _data["NetAmount"];
            this.commissionAmount = _data["CommissionAmount"];
            this.tax = _data["Tax"];
            this.kpayTxnId = _data["KpayTxnId"];
            this.paymentCardId = _data["PaymentCardId"];
            this.paymentMessage = _data["PaymentMessage"];
            this.description = _data["Description"];
        }
    }

    static fromJS(data: any): Transaction {
        data = typeof data === 'object' ? data : {};
        let result = new Transaction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedById"] = this.createdById;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["DeletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        data["DeletedById"] = this.deletedById;
        data["IsDeleted"] = this.isDeleted;
        data["UserId"] = this.userId;
        data["User"] = this.user ? this.user.toJSON() : <any>undefined;
        data["SymbolId"] = this.symbolId;
        data["Symbol"] = this.symbol ? this.symbol.toJSON() : <any>undefined;
        data["TransactionTypeId"] = this.transactionTypeId;
        data["TransactionType"] = this.transactionType;
        data["PaymentType"] = this.paymentType;
        data["ActionDate"] = this.actionDate ? this.actionDate.toISOString() : <any>undefined;
        data["Quantity"] = this.quantity;
        data["Amount"] = this.amount;
        data["NetAmount"] = this.netAmount;
        data["CommissionAmount"] = this.commissionAmount;
        data["Tax"] = this.tax;
        data["KpayTxnId"] = this.kpayTxnId;
        data["PaymentCardId"] = this.paymentCardId;
        data["PaymentMessage"] = this.paymentMessage;
        data["Description"] = this.description;
        return data;
    }
}

export interface ITransaction {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    isDeleted?: boolean;
    userId?: number;
    user?: User;
    symbolId?: number;
    symbol?: Symbol;
    transactionTypeId?: number;
    transactionType?: TransactionType;
    paymentType?: PaymentType;
    actionDate?: moment.Moment;
    quantity?: number;
    amount?: number;
    netAmount?: number;
    commissionAmount?: number;
    tax?: number;
    kpayTxnId?: string | undefined;
    paymentCardId?: string | undefined;
    paymentMessage?: string | undefined;
    description?: string | undefined;
}

export class TransactionModel implements ITransactionModel {
    id?: number;
    userId?: number;
    user?: UserModel;
    symbolId?: number;
    symbol?: SymbolModel;
    transactionType?: TransactionType;
    paymentType?: PaymentType;
    actionDate?: moment.Moment;
    quantity?: number;
    amount?: number;
    netAmount?: number;
    commissionAmount?: number;
    tax?: number;
    kpayTxnId?: string | undefined;
    paymentCardId?: string | undefined;
    paymentMessage?: string | undefined;
    description?: string | undefined;

    constructor(data?: ITransactionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.userId = _data["UserId"];
            this.user = _data["User"] ? UserModel.fromJS(_data["User"]) : <any>undefined;
            this.symbolId = _data["SymbolId"];
            this.symbol = _data["Symbol"] ? SymbolModel.fromJS(_data["Symbol"]) : <any>undefined;
            this.transactionType = _data["TransactionType"];
            this.paymentType = _data["PaymentType"];
            this.actionDate = _data["ActionDate"] ? moment(_data["ActionDate"].toString()) : <any>undefined;
            this.quantity = _data["Quantity"];
            this.amount = _data["Amount"];
            this.netAmount = _data["NetAmount"];
            this.commissionAmount = _data["CommissionAmount"];
            this.tax = _data["Tax"];
            this.kpayTxnId = _data["KpayTxnId"];
            this.paymentCardId = _data["PaymentCardId"];
            this.paymentMessage = _data["PaymentMessage"];
            this.description = _data["Description"];
        }
    }

    static fromJS(data: any): TransactionModel {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["UserId"] = this.userId;
        data["User"] = this.user ? this.user.toJSON() : <any>undefined;
        data["SymbolId"] = this.symbolId;
        data["Symbol"] = this.symbol ? this.symbol.toJSON() : <any>undefined;
        data["TransactionType"] = this.transactionType;
        data["PaymentType"] = this.paymentType;
        data["ActionDate"] = this.actionDate ? this.actionDate.toISOString() : <any>undefined;
        data["Quantity"] = this.quantity;
        data["Amount"] = this.amount;
        data["NetAmount"] = this.netAmount;
        data["CommissionAmount"] = this.commissionAmount;
        data["Tax"] = this.tax;
        data["KpayTxnId"] = this.kpayTxnId;
        data["PaymentCardId"] = this.paymentCardId;
        data["PaymentMessage"] = this.paymentMessage;
        data["Description"] = this.description;
        return data;
    }
}

export interface ITransactionModel {
    id?: number;
    userId?: number;
    user?: UserModel;
    symbolId?: number;
    symbol?: SymbolModel;
    transactionType?: TransactionType;
    paymentType?: PaymentType;
    actionDate?: moment.Moment;
    quantity?: number;
    amount?: number;
    netAmount?: number;
    commissionAmount?: number;
    tax?: number;
    kpayTxnId?: string | undefined;
    paymentCardId?: string | undefined;
    paymentMessage?: string | undefined;
    description?: string | undefined;
}

export class TransactionRequestModel implements ITransactionRequestModel {
    userId?: number;
    symbolId?: number;
    transactionTypeId?: number;
    startDate?: moment.Moment;
    endDate?: moment.Moment;

    constructor(data?: ITransactionRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["UserId"];
            this.symbolId = _data["SymbolId"];
            this.transactionTypeId = _data["TransactionTypeId"];
            this.startDate = _data["StartDate"] ? moment(_data["StartDate"].toString()) : <any>undefined;
            this.endDate = _data["EndDate"] ? moment(_data["EndDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): TransactionRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["UserId"] = this.userId;
        data["SymbolId"] = this.symbolId;
        data["TransactionTypeId"] = this.transactionTypeId;
        data["StartDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["EndDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface ITransactionRequestModel {
    userId?: number;
    symbolId?: number;
    transactionTypeId?: number;
    startDate?: moment.Moment;
    endDate?: moment.Moment;
}

export enum TransactionType {
    Buy = "Buy",
    Sell = "Sell",
    Convert = "Convert",
    Deposit = "Deposit",
    Withdrawal = "Withdrawal",
}

export class User implements IUser {
    id?: number;
    userName?: string | undefined;
    normalizedUserName?: string | undefined;
    email?: string | undefined;
    normalizedEmail?: string | undefined;
    emailConfirmed?: boolean;
    passwordHash?: string | undefined;
    securityStamp?: string | undefined;
    concurrencyStamp?: string | undefined;
    phoneNumber?: string | undefined;
    phoneNumberConfirmed?: boolean;
    twoFactorEnabled?: boolean;
    lockoutEnd?: moment.Moment | undefined;
    lockoutEnabled?: boolean;
    accessFailedCount?: number;
    userGuid?: string;
    version?: number;
    isAcceptKvk?: boolean;
    isAcceptTerms?: boolean;
    isAcceptContact?: boolean;
    isActive?: boolean;
    isDeleted?: boolean;
    otp?: string | undefined;
    otpSentOn?: moment.Moment | undefined;
    userType?: UserType;
    retail?: Retail;
    corporate?: Corporate;
    channelType?: number;
    groupId?: number | undefined;
    group?: Group;
    orders?: Order[] | undefined;
    assets?: Asset[] | undefined;
    bonuses?: Bonus[] | undefined;
    coupons?: Coupon[] | undefined;
    transactions?: Transaction[] | undefined;
    userAddresses?: UserAddress[] | undefined;
    userBankAccounts?: UserBankAccount[] | undefined;
    userDocuments?: UserDocument[] | undefined;
    userContacts?: UserContact[] | undefined;
    userRoles?: UserRole[] | undefined;

    constructor(data?: IUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.userName = _data["UserName"];
            this.normalizedUserName = _data["NormalizedUserName"];
            this.email = _data["Email"];
            this.normalizedEmail = _data["NormalizedEmail"];
            this.emailConfirmed = _data["EmailConfirmed"];
            this.passwordHash = _data["PasswordHash"];
            this.securityStamp = _data["SecurityStamp"];
            this.concurrencyStamp = _data["ConcurrencyStamp"];
            this.phoneNumber = _data["PhoneNumber"];
            this.phoneNumberConfirmed = _data["PhoneNumberConfirmed"];
            this.twoFactorEnabled = _data["TwoFactorEnabled"];
            this.lockoutEnd = _data["LockoutEnd"] ? moment(_data["LockoutEnd"].toString()) : <any>undefined;
            this.lockoutEnabled = _data["LockoutEnabled"];
            this.accessFailedCount = _data["AccessFailedCount"];
            this.userGuid = _data["UserGuid"];
            this.version = _data["Version"];
            this.isAcceptKvk = _data["IsAcceptKvk"];
            this.isAcceptTerms = _data["IsAcceptTerms"];
            this.isAcceptContact = _data["IsAcceptContact"];
            this.isActive = _data["IsActive"];
            this.isDeleted = _data["IsDeleted"];
            this.otp = _data["Otp"];
            this.otpSentOn = _data["OtpSentOn"] ? moment(_data["OtpSentOn"].toString()) : <any>undefined;
            this.userType = _data["UserType"];
            this.retail = _data["Retail"] ? Retail.fromJS(_data["Retail"]) : <any>undefined;
            this.corporate = _data["Corporate"] ? Corporate.fromJS(_data["Corporate"]) : <any>undefined;
            this.channelType = _data["ChannelType"];
            this.groupId = _data["GroupId"];
            this.group = _data["Group"] ? Group.fromJS(_data["Group"]) : <any>undefined;
            if (Array.isArray(_data["Orders"])) {
                this.orders = [] as any;
                for (let item of _data["Orders"])
                    this.orders!.push(Order.fromJS(item));
            }
            if (Array.isArray(_data["Assets"])) {
                this.assets = [] as any;
                for (let item of _data["Assets"])
                    this.assets!.push(Asset.fromJS(item));
            }
            if (Array.isArray(_data["Bonuses"])) {
                this.bonuses = [] as any;
                for (let item of _data["Bonuses"])
                    this.bonuses!.push(Bonus.fromJS(item));
            }
            if (Array.isArray(_data["Coupons"])) {
                this.coupons = [] as any;
                for (let item of _data["Coupons"])
                    this.coupons!.push(Coupon.fromJS(item));
            }
            if (Array.isArray(_data["Transactions"])) {
                this.transactions = [] as any;
                for (let item of _data["Transactions"])
                    this.transactions!.push(Transaction.fromJS(item));
            }
            if (Array.isArray(_data["UserAddresses"])) {
                this.userAddresses = [] as any;
                for (let item of _data["UserAddresses"])
                    this.userAddresses!.push(UserAddress.fromJS(item));
            }
            if (Array.isArray(_data["UserBankAccounts"])) {
                this.userBankAccounts = [] as any;
                for (let item of _data["UserBankAccounts"])
                    this.userBankAccounts!.push(UserBankAccount.fromJS(item));
            }
            if (Array.isArray(_data["UserDocuments"])) {
                this.userDocuments = [] as any;
                for (let item of _data["UserDocuments"])
                    this.userDocuments!.push(UserDocument.fromJS(item));
            }
            if (Array.isArray(_data["UserContacts"])) {
                this.userContacts = [] as any;
                for (let item of _data["UserContacts"])
                    this.userContacts!.push(UserContact.fromJS(item));
            }
            if (Array.isArray(_data["UserRoles"])) {
                this.userRoles = [] as any;
                for (let item of _data["UserRoles"])
                    this.userRoles!.push(UserRole.fromJS(item));
            }
        }
    }

    static fromJS(data: any): User {
        data = typeof data === 'object' ? data : {};
        let result = new User();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["UserName"] = this.userName;
        data["NormalizedUserName"] = this.normalizedUserName;
        data["Email"] = this.email;
        data["NormalizedEmail"] = this.normalizedEmail;
        data["EmailConfirmed"] = this.emailConfirmed;
        data["PasswordHash"] = this.passwordHash;
        data["SecurityStamp"] = this.securityStamp;
        data["ConcurrencyStamp"] = this.concurrencyStamp;
        data["PhoneNumber"] = this.phoneNumber;
        data["PhoneNumberConfirmed"] = this.phoneNumberConfirmed;
        data["TwoFactorEnabled"] = this.twoFactorEnabled;
        data["LockoutEnd"] = this.lockoutEnd ? this.lockoutEnd.toISOString() : <any>undefined;
        data["LockoutEnabled"] = this.lockoutEnabled;
        data["AccessFailedCount"] = this.accessFailedCount;
        data["UserGuid"] = this.userGuid;
        data["Version"] = this.version;
        data["IsAcceptKvk"] = this.isAcceptKvk;
        data["IsAcceptTerms"] = this.isAcceptTerms;
        data["IsAcceptContact"] = this.isAcceptContact;
        data["IsActive"] = this.isActive;
        data["IsDeleted"] = this.isDeleted;
        data["Otp"] = this.otp;
        data["OtpSentOn"] = this.otpSentOn ? this.otpSentOn.toISOString() : <any>undefined;
        data["UserType"] = this.userType;
        data["Retail"] = this.retail ? this.retail.toJSON() : <any>undefined;
        data["Corporate"] = this.corporate ? this.corporate.toJSON() : <any>undefined;
        data["ChannelType"] = this.channelType;
        data["GroupId"] = this.groupId;
        data["Group"] = this.group ? this.group.toJSON() : <any>undefined;
        if (Array.isArray(this.orders)) {
            data["Orders"] = [];
            for (let item of this.orders)
                data["Orders"].push(item.toJSON());
        }
        if (Array.isArray(this.assets)) {
            data["Assets"] = [];
            for (let item of this.assets)
                data["Assets"].push(item.toJSON());
        }
        if (Array.isArray(this.bonuses)) {
            data["Bonuses"] = [];
            for (let item of this.bonuses)
                data["Bonuses"].push(item.toJSON());
        }
        if (Array.isArray(this.coupons)) {
            data["Coupons"] = [];
            for (let item of this.coupons)
                data["Coupons"].push(item.toJSON());
        }
        if (Array.isArray(this.transactions)) {
            data["Transactions"] = [];
            for (let item of this.transactions)
                data["Transactions"].push(item.toJSON());
        }
        if (Array.isArray(this.userAddresses)) {
            data["UserAddresses"] = [];
            for (let item of this.userAddresses)
                data["UserAddresses"].push(item.toJSON());
        }
        if (Array.isArray(this.userBankAccounts)) {
            data["UserBankAccounts"] = [];
            for (let item of this.userBankAccounts)
                data["UserBankAccounts"].push(item.toJSON());
        }
        if (Array.isArray(this.userDocuments)) {
            data["UserDocuments"] = [];
            for (let item of this.userDocuments)
                data["UserDocuments"].push(item.toJSON());
        }
        if (Array.isArray(this.userContacts)) {
            data["UserContacts"] = [];
            for (let item of this.userContacts)
                data["UserContacts"].push(item.toJSON());
        }
        if (Array.isArray(this.userRoles)) {
            data["UserRoles"] = [];
            for (let item of this.userRoles)
                data["UserRoles"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUser {
    id?: number;
    userName?: string | undefined;
    normalizedUserName?: string | undefined;
    email?: string | undefined;
    normalizedEmail?: string | undefined;
    emailConfirmed?: boolean;
    passwordHash?: string | undefined;
    securityStamp?: string | undefined;
    concurrencyStamp?: string | undefined;
    phoneNumber?: string | undefined;
    phoneNumberConfirmed?: boolean;
    twoFactorEnabled?: boolean;
    lockoutEnd?: moment.Moment | undefined;
    lockoutEnabled?: boolean;
    accessFailedCount?: number;
    userGuid?: string;
    version?: number;
    isAcceptKvk?: boolean;
    isAcceptTerms?: boolean;
    isAcceptContact?: boolean;
    isActive?: boolean;
    isDeleted?: boolean;
    otp?: string | undefined;
    otpSentOn?: moment.Moment | undefined;
    userType?: UserType;
    retail?: Retail;
    corporate?: Corporate;
    channelType?: number;
    groupId?: number | undefined;
    group?: Group;
    orders?: Order[] | undefined;
    assets?: Asset[] | undefined;
    bonuses?: Bonus[] | undefined;
    coupons?: Coupon[] | undefined;
    transactions?: Transaction[] | undefined;
    userAddresses?: UserAddress[] | undefined;
    userBankAccounts?: UserBankAccount[] | undefined;
    userDocuments?: UserDocument[] | undefined;
    userContacts?: UserContact[] | undefined;
    userRoles?: UserRole[] | undefined;
}

export class UserAddress implements IUserAddress {
    id?: number;
    userId?: number;
    user?: User;
    addressId?: number;
    address?: Address;
    lastUsedOn?: moment.Moment | undefined;
    isPrimary?: boolean;

    constructor(data?: IUserAddress) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.userId = _data["UserId"];
            this.user = _data["User"] ? User.fromJS(_data["User"]) : <any>undefined;
            this.addressId = _data["AddressId"];
            this.address = _data["Address"] ? Address.fromJS(_data["Address"]) : <any>undefined;
            this.lastUsedOn = _data["LastUsedOn"] ? moment(_data["LastUsedOn"].toString()) : <any>undefined;
            this.isPrimary = _data["IsPrimary"];
        }
    }

    static fromJS(data: any): UserAddress {
        data = typeof data === 'object' ? data : {};
        let result = new UserAddress();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["UserId"] = this.userId;
        data["User"] = this.user ? this.user.toJSON() : <any>undefined;
        data["AddressId"] = this.addressId;
        data["Address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["LastUsedOn"] = this.lastUsedOn ? this.lastUsedOn.toISOString() : <any>undefined;
        data["IsPrimary"] = this.isPrimary;
        return data;
    }
}

export interface IUserAddress {
    id?: number;
    userId?: number;
    user?: User;
    addressId?: number;
    address?: Address;
    lastUsedOn?: moment.Moment | undefined;
    isPrimary?: boolean;
}

export class UserBankAccount implements IUserBankAccount {
    id?: number;
    userId?: number;
    user?: User;
    symbolId?: number;
    symbol?: Symbol;
    bankId?: number;
    bank?: Bank;
    name?: string | undefined;
    accountNo?: string | undefined;
    isDeleted?: boolean;

    constructor(data?: IUserBankAccount) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.userId = _data["UserId"];
            this.user = _data["User"] ? User.fromJS(_data["User"]) : <any>undefined;
            this.symbolId = _data["SymbolId"];
            this.symbol = _data["Symbol"] ? Symbol.fromJS(_data["Symbol"]) : <any>undefined;
            this.bankId = _data["BankId"];
            this.bank = _data["Bank"] ? Bank.fromJS(_data["Bank"]) : <any>undefined;
            this.name = _data["Name"];
            this.accountNo = _data["AccountNo"];
            this.isDeleted = _data["IsDeleted"];
        }
    }

    static fromJS(data: any): UserBankAccount {
        data = typeof data === 'object' ? data : {};
        let result = new UserBankAccount();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["UserId"] = this.userId;
        data["User"] = this.user ? this.user.toJSON() : <any>undefined;
        data["SymbolId"] = this.symbolId;
        data["Symbol"] = this.symbol ? this.symbol.toJSON() : <any>undefined;
        data["BankId"] = this.bankId;
        data["Bank"] = this.bank ? this.bank.toJSON() : <any>undefined;
        data["Name"] = this.name;
        data["AccountNo"] = this.accountNo;
        data["IsDeleted"] = this.isDeleted;
        return data;
    }
}

export interface IUserBankAccount {
    id?: number;
    userId?: number;
    user?: User;
    symbolId?: number;
    symbol?: Symbol;
    bankId?: number;
    bank?: Bank;
    name?: string | undefined;
    accountNo?: string | undefined;
    isDeleted?: boolean;
}

export class UserBankAccountModel implements IUserBankAccountModel {
    id?: number;
    userId?: number;
    user?: UserModel;
    symbolId?: number;
    symbol?: SymbolModel;
    bankId?: number;
    bank?: BankModel;
    name?: string | undefined;
    accountNo?: string | undefined;

    constructor(data?: IUserBankAccountModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.userId = _data["UserId"];
            this.user = _data["User"] ? UserModel.fromJS(_data["User"]) : <any>undefined;
            this.symbolId = _data["SymbolId"];
            this.symbol = _data["Symbol"] ? SymbolModel.fromJS(_data["Symbol"]) : <any>undefined;
            this.bankId = _data["BankId"];
            this.bank = _data["Bank"] ? BankModel.fromJS(_data["Bank"]) : <any>undefined;
            this.name = _data["Name"];
            this.accountNo = _data["AccountNo"];
        }
    }

    static fromJS(data: any): UserBankAccountModel {
        data = typeof data === 'object' ? data : {};
        let result = new UserBankAccountModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["UserId"] = this.userId;
        data["User"] = this.user ? this.user.toJSON() : <any>undefined;
        data["SymbolId"] = this.symbolId;
        data["Symbol"] = this.symbol ? this.symbol.toJSON() : <any>undefined;
        data["BankId"] = this.bankId;
        data["Bank"] = this.bank ? this.bank.toJSON() : <any>undefined;
        data["Name"] = this.name;
        data["AccountNo"] = this.accountNo;
        return data;
    }
}

export interface IUserBankAccountModel {
    id?: number;
    userId?: number;
    user?: UserModel;
    symbolId?: number;
    symbol?: SymbolModel;
    bankId?: number;
    bank?: BankModel;
    name?: string | undefined;
    accountNo?: string | undefined;
}

export class UserContact implements IUserContact {
    id?: number;
    userId?: number;
    user?: User;
    contactType?: ContactType;
    contactValue?: string | undefined;
    isPrimary?: boolean;
    isDeleted?: boolean;

    constructor(data?: IUserContact) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.userId = _data["UserId"];
            this.user = _data["User"] ? User.fromJS(_data["User"]) : <any>undefined;
            this.contactType = _data["ContactType"];
            this.contactValue = _data["ContactValue"];
            this.isPrimary = _data["IsPrimary"];
            this.isDeleted = _data["IsDeleted"];
        }
    }

    static fromJS(data: any): UserContact {
        data = typeof data === 'object' ? data : {};
        let result = new UserContact();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["UserId"] = this.userId;
        data["User"] = this.user ? this.user.toJSON() : <any>undefined;
        data["ContactType"] = this.contactType;
        data["ContactValue"] = this.contactValue;
        data["IsPrimary"] = this.isPrimary;
        data["IsDeleted"] = this.isDeleted;
        return data;
    }
}

export interface IUserContact {
    id?: number;
    userId?: number;
    user?: User;
    contactType?: ContactType;
    contactValue?: string | undefined;
    isPrimary?: boolean;
    isDeleted?: boolean;
}

export class UserDocument implements IUserDocument {
    id?: number;
    userId?: number;
    user?: User;
    documentTypeId?: number;
    documentType?: DocumentType;
    medias?: UserDocumentMedia[] | undefined;
    countryId?: string | undefined;
    country?: Country;
    documentNo?: string | undefined;
    serialNo?: string | undefined;
    dateOfIssue?: moment.Moment;
    dateOfExpiry?: moment.Moment;
    isVerified?: boolean;
    verifiedOn?: moment.Moment;
    isDeleted?: boolean;

    constructor(data?: IUserDocument) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.userId = _data["UserId"];
            this.user = _data["User"] ? User.fromJS(_data["User"]) : <any>undefined;
            this.documentTypeId = _data["DocumentTypeId"];
            this.documentType = _data["DocumentType"];
            if (Array.isArray(_data["Medias"])) {
                this.medias = [] as any;
                for (let item of _data["Medias"])
                    this.medias!.push(UserDocumentMedia.fromJS(item));
            }
            this.countryId = _data["CountryId"];
            this.country = _data["Country"] ? Country.fromJS(_data["Country"]) : <any>undefined;
            this.documentNo = _data["DocumentNo"];
            this.serialNo = _data["SerialNo"];
            this.dateOfIssue = _data["DateOfIssue"] ? moment(_data["DateOfIssue"].toString()) : <any>undefined;
            this.dateOfExpiry = _data["DateOfExpiry"] ? moment(_data["DateOfExpiry"].toString()) : <any>undefined;
            this.isVerified = _data["IsVerified"];
            this.verifiedOn = _data["VerifiedOn"] ? moment(_data["VerifiedOn"].toString()) : <any>undefined;
            this.isDeleted = _data["IsDeleted"];
        }
    }

    static fromJS(data: any): UserDocument {
        data = typeof data === 'object' ? data : {};
        let result = new UserDocument();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["UserId"] = this.userId;
        data["User"] = this.user ? this.user.toJSON() : <any>undefined;
        data["DocumentTypeId"] = this.documentTypeId;
        data["DocumentType"] = this.documentType;
        if (Array.isArray(this.medias)) {
            data["Medias"] = [];
            for (let item of this.medias)
                data["Medias"].push(item.toJSON());
        }
        data["CountryId"] = this.countryId;
        data["Country"] = this.country ? this.country.toJSON() : <any>undefined;
        data["DocumentNo"] = this.documentNo;
        data["SerialNo"] = this.serialNo;
        data["DateOfIssue"] = this.dateOfIssue ? this.dateOfIssue.toISOString() : <any>undefined;
        data["DateOfExpiry"] = this.dateOfExpiry ? this.dateOfExpiry.toISOString() : <any>undefined;
        data["IsVerified"] = this.isVerified;
        data["VerifiedOn"] = this.verifiedOn ? this.verifiedOn.toISOString() : <any>undefined;
        data["IsDeleted"] = this.isDeleted;
        return data;
    }
}

export interface IUserDocument {
    id?: number;
    userId?: number;
    user?: User;
    documentTypeId?: number;
    documentType?: DocumentType;
    medias?: UserDocumentMedia[] | undefined;
    countryId?: string | undefined;
    country?: Country;
    documentNo?: string | undefined;
    serialNo?: string | undefined;
    dateOfIssue?: moment.Moment;
    dateOfExpiry?: moment.Moment;
    isVerified?: boolean;
    verifiedOn?: moment.Moment;
    isDeleted?: boolean;
}

export class UserDocumentMedia implements IUserDocumentMedia {
    id?: number;
    userDocumentId?: number;
    userDocument?: UserDocument;
    mediaId?: number;
    media?: Media;
    scanTypeId?: number;
    scanType?: ScanType;

    constructor(data?: IUserDocumentMedia) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.userDocumentId = _data["UserDocumentId"];
            this.userDocument = _data["UserDocument"] ? UserDocument.fromJS(_data["UserDocument"]) : <any>undefined;
            this.mediaId = _data["MediaId"];
            this.media = _data["Media"] ? Media.fromJS(_data["Media"]) : <any>undefined;
            this.scanTypeId = _data["ScanTypeId"];
            this.scanType = _data["ScanType"];
        }
    }

    static fromJS(data: any): UserDocumentMedia {
        data = typeof data === 'object' ? data : {};
        let result = new UserDocumentMedia();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["UserDocumentId"] = this.userDocumentId;
        data["UserDocument"] = this.userDocument ? this.userDocument.toJSON() : <any>undefined;
        data["MediaId"] = this.mediaId;
        data["Media"] = this.media ? this.media.toJSON() : <any>undefined;
        data["ScanTypeId"] = this.scanTypeId;
        data["ScanType"] = this.scanType;
        return data;
    }
}

export interface IUserDocumentMedia {
    id?: number;
    userDocumentId?: number;
    userDocument?: UserDocument;
    mediaId?: number;
    media?: Media;
    scanTypeId?: number;
    scanType?: ScanType;
}

export class UserDocumentModel implements IUserDocumentModel {

    constructor(data?: IUserDocumentModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): UserDocumentModel {
        data = typeof data === 'object' ? data : {};
        let result = new UserDocumentModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IUserDocumentModel {
}

export class UserModel implements IUserModel {
    userId?: number;
    firstName?: string | undefined;
    lastName?: string | undefined;
    email?: string | undefined;
    phoneNumber?: string | undefined;
    institutionId?: number | undefined;
    institutionName?: string | undefined;
    departmentId?: number | undefined;
    departmentName?: string | undefined;

    constructor(data?: IUserModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["UserId"];
            this.firstName = _data["FirstName"];
            this.lastName = _data["LastName"];
            this.email = _data["Email"];
            this.phoneNumber = _data["PhoneNumber"];
            this.institutionId = _data["InstitutionId"];
            this.institutionName = _data["InstitutionName"];
            this.departmentId = _data["DepartmentId"];
            this.departmentName = _data["DepartmentName"];
        }
    }

    static fromJS(data: any): UserModel {
        data = typeof data === 'object' ? data : {};
        let result = new UserModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["UserId"] = this.userId;
        data["FirstName"] = this.firstName;
        data["LastName"] = this.lastName;
        data["Email"] = this.email;
        data["PhoneNumber"] = this.phoneNumber;
        data["InstitutionId"] = this.institutionId;
        data["InstitutionName"] = this.institutionName;
        data["DepartmentId"] = this.departmentId;
        data["DepartmentName"] = this.departmentName;
        return data;
    }
}

export interface IUserModel {
    userId?: number;
    firstName?: string | undefined;
    lastName?: string | undefined;
    email?: string | undefined;
    phoneNumber?: string | undefined;
    institutionId?: number | undefined;
    institutionName?: string | undefined;
    departmentId?: number | undefined;
    departmentName?: string | undefined;
}

export class UserRole implements IUserRole {
    userId?: number;
    user?: User;
    roleId?: number;
    role?: Role;

    constructor(data?: IUserRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["UserId"];
            this.user = _data["User"] ? User.fromJS(_data["User"]) : <any>undefined;
            this.roleId = _data["RoleId"];
            this.role = _data["Role"] ? Role.fromJS(_data["Role"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UserRole {
        data = typeof data === 'object' ? data : {};
        let result = new UserRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["UserId"] = this.userId;
        data["User"] = this.user ? this.user.toJSON() : <any>undefined;
        data["RoleId"] = this.roleId;
        data["Role"] = this.role ? this.role.toJSON() : <any>undefined;
        return data;
    }
}

export interface IUserRole {
    userId?: number;
    user?: User;
    roleId?: number;
    role?: Role;
}

export enum UserType {
    Retail = "Retail",
    Corporate = "Corporate",
    Admin = "Admin",
}

export class VerifyModel implements IVerifyModel {
    otp?: string | undefined;
    authenticatorCode?: string | undefined;
    phoneNumber!: string;

    constructor(data?: IVerifyModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.otp = _data["Otp"];
            this.authenticatorCode = _data["AuthenticatorCode"];
            this.phoneNumber = _data["PhoneNumber"];
        }
    }

    static fromJS(data: any): VerifyModel {
        data = typeof data === 'object' ? data : {};
        let result = new VerifyModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Otp"] = this.otp;
        data["AuthenticatorCode"] = this.authenticatorCode;
        data["PhoneNumber"] = this.phoneNumber;
        return data;
    }
}

export interface IVerifyModel {
    otp?: string | undefined;
    authenticatorCode?: string | undefined;
    phoneNumber: string;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = getFileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}
export function getFileReader(): FileReader {
	const fileReader = new FileReader();
	const zoneOriginalInstance = (fileReader as any)["__zone_symbol__originalInstance"];
	return zoneOriginalInstance || fileReader;
}