/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import * as moment from 'moment';

export const MARITZA_API_URL = new InjectionToken<string>('MARITZA_API_URL');

@Injectable()
export class AnalysisApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://api.yatirimim.local";
    }

    /**
     * @return Success
     */
    getlist(): Observable<Analysis[]> {
        let url_ = this.baseUrl + "/api/contents/analysis/getlist";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetlist(<any>response_);
                } catch (e) {
                    return <Observable<Analysis[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Analysis[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetlist(response: HttpResponseBase): Observable<Analysis[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Analysis.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Analysis[]>(<any>null);
    }
}

@Injectable()
export class AssetsApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://api.yatirimim.local";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    add(body: Asset | undefined): Observable<Asset> {
        let url_ = this.baseUrl + "/api/finance/assets/add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd(<any>response_);
                } catch (e) {
                    return <Observable<Asset>><any>_observableThrow(e);
                }
            } else
                return <Observable<Asset>><any>_observableThrow(response_);
        }));
    }

    protected processAdd(response: HttpResponseBase): Observable<Asset> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Asset.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Asset>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getbyid(id: number | undefined): Observable<Asset> {
        let url_ = this.baseUrl + "/api/finance/assets/getbyid?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyid(<any>response_);
                } catch (e) {
                    return <Observable<Asset>><any>_observableThrow(e);
                }
            } else
                return <Observable<Asset>><any>_observableThrow(response_);
        }));
    }

    protected processGetbyid(response: HttpResponseBase): Observable<Asset> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Asset.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Asset>(<any>null);
    }

    /**
     * @param customerId (optional) 
     * @return Success
     */
    getassetlist(customerId: number | undefined): Observable<Asset[]> {
        let url_ = this.baseUrl + "/api/finance/assets/getassetlist?";
        if (customerId === null)
            throw new Error("The parameter 'customerId' cannot be null.");
        else if (customerId !== undefined)
            url_ += "customerId=" + encodeURIComponent("" + customerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetassetlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetassetlist(<any>response_);
                } catch (e) {
                    return <Observable<Asset[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Asset[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetassetlist(response: HttpResponseBase): Observable<Asset[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Asset.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Asset[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: Asset | undefined): Observable<Asset> {
        let url_ = this.baseUrl + "/api/finance/assets/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<Asset>><any>_observableThrow(e);
                }
            } else
                return <Observable<Asset>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<Asset> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Asset.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Asset>(<any>null);
    }
}

@Injectable()
export class BankApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://api.yatirimim.local";
    }

    /**
     * @return Success
     */
    getlist(): Observable<Bank[]> {
        let url_ = this.baseUrl + "/api/settings/core/bank/getlist";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetlist(<any>response_);
                } catch (e) {
                    return <Observable<Bank[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Bank[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetlist(response: HttpResponseBase): Observable<Bank[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Bank.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Bank[]>(<any>null);
    }
}

@Injectable()
export class BankaccountApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://api.yatirimim.local";
    }

    /**
     * @param customerId (optional) 
     * @return Success
     */
    getcustomeraccountdetail(customerId: number | undefined): Observable<CustomerBankAccount[]> {
        let url_ = this.baseUrl + "/api/auth/bankaccount/getcustomeraccountdetail?";
        if (customerId === null)
            throw new Error("The parameter 'customerId' cannot be null.");
        else if (customerId !== undefined)
            url_ += "customerId=" + encodeURIComponent("" + customerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetcustomeraccountdetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetcustomeraccountdetail(<any>response_);
                } catch (e) {
                    return <Observable<CustomerBankAccount[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CustomerBankAccount[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetcustomeraccountdetail(response: HttpResponseBase): Observable<CustomerBankAccount[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CustomerBankAccount.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CustomerBankAccount[]>(<any>null);
    }
}

@Injectable()
export class BloodtypeApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://api.yatirimim.local";
    }

    /**
     * @return Success
     */
    getlist(): Observable<BloodType[]> {
        let url_ = this.baseUrl + "/api/settings/code/bloodtype/getlist";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetlist(<any>response_);
                } catch (e) {
                    return <Observable<BloodType[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<BloodType[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetlist(response: HttpResponseBase): Observable<BloodType[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(BloodType.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BloodType[]>(<any>null);
    }
}

@Injectable()
export class ChanneltypeApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://api.yatirimim.local";
    }

    /**
     * @return Success
     */
    getlist(): Observable<ChannelType[]> {
        let url_ = this.baseUrl + "/api/settings/code/channeltype/getlist";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetlist(<any>response_);
                } catch (e) {
                    return <Observable<ChannelType[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ChannelType[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetlist(response: HttpResponseBase): Observable<ChannelType[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ChannelType.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ChannelType[]>(<any>null);
    }
}

@Injectable()
export class CommissionApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://api.yatirimim.local";
    }

    /**
     * @return Success
     */
    getlist(): Observable<Commission[]> {
        let url_ = this.baseUrl + "/api/settings/finance/commission/getlist";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetlist(<any>response_);
                } catch (e) {
                    return <Observable<Commission[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Commission[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetlist(response: HttpResponseBase): Observable<Commission[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Commission.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Commission[]>(<any>null);
    }
}

@Injectable()
export class ContacstypeApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://api.yatirimim.local";
    }

    /**
     * @return Success
     */
    getlist(): Observable<ContactType[]> {
        let url_ = this.baseUrl + "/api/settings/code/contacstype/getlist";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetlist(<any>response_);
                } catch (e) {
                    return <Observable<ContactType[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContactType[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetlist(response: HttpResponseBase): Observable<ContactType[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ContactType.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContactType[]>(<any>null);
    }
}

@Injectable()
export class CorporateApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://api.yatirimim.local";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    add(body: CorporateModel | undefined): Observable<CorporateModel> {
        let url_ = this.baseUrl + "/api/auth/corporate/add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd(<any>response_);
                } catch (e) {
                    return <Observable<CorporateModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<CorporateModel>><any>_observableThrow(response_);
        }));
    }

    protected processAdd(response: HttpResponseBase): Observable<CorporateModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CorporateModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CorporateModel>(<any>null);
    }
}

@Injectable()
export class GetbyidApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://api.yatirimim.local";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getbyid(id: number | undefined): Observable<CorporateModel> {
        let url_ = this.baseUrl + "/api/auth/corporate/getbyid/getbyid?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyid(<any>response_);
                } catch (e) {
                    return <Observable<CorporateModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<CorporateModel>><any>_observableThrow(response_);
        }));
    }

    protected processGetbyid(response: HttpResponseBase): Observable<CorporateModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CorporateModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CorporateModel>(<any>null);
    }
}

@Injectable()
export class ReadApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://api.yatirimim.local";
    }

    /**
     * @return Success
     */
    getcorporatelist(): Observable<CorporateModel[]> {
        let url_ = this.baseUrl + "/api/auth/corporate/read/getcorporatelist";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetcorporatelist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetcorporatelist(<any>response_);
                } catch (e) {
                    return <Observable<CorporateModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CorporateModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetcorporatelist(response: HttpResponseBase): Observable<CorporateModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CorporateModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CorporateModel[]>(<any>null);
    }
}

@Injectable()
export class UpdateApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://api.yatirimim.local";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: CorporateModel | undefined): Observable<CorporateModel> {
        let url_ = this.baseUrl + "/api/auth/corporate/update/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<CorporateModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<CorporateModel>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<CorporateModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CorporateModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CorporateModel>(<any>null);
    }
}

@Injectable()
export class CorporatecategoriesApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://api.yatirimim.local";
    }

    /**
     * @return Success
     */
    getlist(): Observable<CorporateCategory[]> {
        let url_ = this.baseUrl + "/api/settings/code/corporatecategories/getlist";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetlist(<any>response_);
                } catch (e) {
                    return <Observable<CorporateCategory[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CorporateCategory[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetlist(response: HttpResponseBase): Observable<CorporateCategory[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CorporateCategory.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CorporateCategory[]>(<any>null);
    }
}

@Injectable()
export class CountryApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://api.yatirimim.local";
    }

    /**
     * @return Success
     */
    getlist(): Observable<Country[]> {
        let url_ = this.baseUrl + "/api/settings/place/country/getlist";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetlist(<any>response_);
                } catch (e) {
                    return <Observable<Country[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Country[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetlist(response: HttpResponseBase): Observable<Country[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Country.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Country[]>(<any>null);
    }
}

@Injectable()
export class DemandtypesApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://api.yatirimim.local";
    }

    /**
     * @return Success
     */
    getlist(): Observable<DemandType[]> {
        let url_ = this.baseUrl + "/api/settings/code/demandtypes/getlist";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetlist(<any>response_);
                } catch (e) {
                    return <Observable<DemandType[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DemandType[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetlist(response: HttpResponseBase): Observable<DemandType[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DemandType.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DemandType[]>(<any>null);
    }
}

@Injectable()
export class DepositsApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://api.yatirimim.local";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addphysical(body: Request | undefined): Observable<Request> {
        let url_ = this.baseUrl + "/api/finance/deposits/addphysical";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddphysical(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddphysical(<any>response_);
                } catch (e) {
                    return <Observable<Request>><any>_observableThrow(e);
                }
            } else
                return <Observable<Request>><any>_observableThrow(response_);
        }));
    }

    protected processAddphysical(response: HttpResponseBase): Observable<Request> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Request.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Request>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    adddigital(body: Request | undefined): Observable<Request> {
        let url_ = this.baseUrl + "/api/finance/deposits/adddigital";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdddigital(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdddigital(<any>response_);
                } catch (e) {
                    return <Observable<Request>><any>_observableThrow(e);
                }
            } else
                return <Observable<Request>><any>_observableThrow(response_);
        }));
    }

    protected processAdddigital(response: HttpResponseBase): Observable<Request> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Request.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Request>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getbyid(id: number | undefined): Observable<Request> {
        let url_ = this.baseUrl + "/api/finance/deposits/getbyid?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyid(<any>response_);
                } catch (e) {
                    return <Observable<Request>><any>_observableThrow(e);
                }
            } else
                return <Observable<Request>><any>_observableThrow(response_);
        }));
    }

    protected processGetbyid(response: HttpResponseBase): Observable<Request> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Request.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Request>(<any>null);
    }

    getdetailbyid(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/finance/deposits/getdetailbyid?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetdetailbyid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetdetailbyid(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGetdetailbyid(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param customerId (optional) 
     * @return Success
     */
    getdigitalrequestlist(customerId: number | undefined): Observable<Request[]> {
        let url_ = this.baseUrl + "/api/finance/deposits/getdigitalrequestlist?";
        if (customerId === null)
            throw new Error("The parameter 'customerId' cannot be null.");
        else if (customerId !== undefined)
            url_ += "customerId=" + encodeURIComponent("" + customerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetdigitalrequestlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetdigitalrequestlist(<any>response_);
                } catch (e) {
                    return <Observable<Request[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Request[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetdigitalrequestlist(response: HttpResponseBase): Observable<Request[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Request.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Request[]>(<any>null);
    }

    /**
     * @param customerId (optional) 
     * @return Success
     */
    getphysicalrequestlist(customerId: number | undefined): Observable<Request[]> {
        let url_ = this.baseUrl + "/api/finance/deposits/getphysicalrequestlist?";
        if (customerId === null)
            throw new Error("The parameter 'customerId' cannot be null.");
        else if (customerId !== undefined)
            url_ += "customerId=" + encodeURIComponent("" + customerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetphysicalrequestlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetphysicalrequestlist(<any>response_);
                } catch (e) {
                    return <Observable<Request[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Request[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetphysicalrequestlist(response: HttpResponseBase): Observable<Request[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Request.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Request[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: Request | undefined): Observable<Request> {
        let url_ = this.baseUrl + "/api/finance/deposits/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<Request>><any>_observableThrow(e);
                }
            } else
                return <Observable<Request>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<Request> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Request.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Request>(<any>null);
    }
}

@Injectable()
export class DocumenttypesApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://api.yatirimim.local";
    }

    /**
     * @return Success
     */
    getlist(): Observable<DocumentType[]> {
        let url_ = this.baseUrl + "/api/settings/code/documenttypes/getlist";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetlist(<any>response_);
                } catch (e) {
                    return <Observable<DocumentType[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DocumentType[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetlist(response: HttpResponseBase): Observable<DocumentType[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DocumentType.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DocumentType[]>(<any>null);
    }
}

@Injectable()
export class GenderApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://api.yatirimim.local";
    }

    /**
     * @return Success
     */
    getlist(): Observable<Gender[]> {
        let url_ = this.baseUrl + "/api/settings/code/gender/getlist";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetlist(<any>response_);
                } catch (e) {
                    return <Observable<Gender[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Gender[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetlist(response: HttpResponseBase): Observable<Gender[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Gender.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Gender[]>(<any>null);
    }
}

@Injectable()
export class InvoicestatusApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://api.yatirimim.local";
    }

    /**
     * @return Success
     */
    getlist(): Observable<InvoiceStatus[]> {
        let url_ = this.baseUrl + "/api/settings/code/invoicestatus/getlist";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetlist(<any>response_);
                } catch (e) {
                    return <Observable<InvoiceStatus[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<InvoiceStatus[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetlist(response: HttpResponseBase): Observable<InvoiceStatus[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(InvoiceStatus.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvoiceStatus[]>(<any>null);
    }
}

@Injectable()
export class KnowledgebaseApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://api.yatirimim.local";
    }

    /**
     * @return Success
     */
    getlist(): Observable<KnowledgeBase[]> {
        let url_ = this.baseUrl + "/api/contents/knowledgebase/getlist";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetlist(<any>response_);
                } catch (e) {
                    return <Observable<KnowledgeBase[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<KnowledgeBase[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetlist(response: HttpResponseBase): Observable<KnowledgeBase[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(KnowledgeBase.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<KnowledgeBase[]>(<any>null);
    }
}

@Injectable()
export class MatriksApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://api.yatirimim.local";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getturkeydebenturedata(body: string[] | undefined): Observable<DebentureModel> {
        let url_ = this.baseUrl + "/api/proxy/matriks/getturkeydebenturedata";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetturkeydebenturedata(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetturkeydebenturedata(<any>response_);
                } catch (e) {
                    return <Observable<DebentureModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<DebentureModel>><any>_observableThrow(response_);
        }));
    }

    protected processGetturkeydebenturedata(response: HttpResponseBase): Observable<DebentureModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DebentureModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DebentureModel>(<any>null);
    }

    /**
     * @return Success
     */
    getmatriksnewsdata(): Observable<MatriksNewsModel> {
        let url_ = this.baseUrl + "/api/proxy/matriks/getmatriksnewsdata";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetmatriksnewsdata(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetmatriksnewsdata(<any>response_);
                } catch (e) {
                    return <Observable<MatriksNewsModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<MatriksNewsModel>><any>_observableThrow(response_);
        }));
    }

    protected processGetmatriksnewsdata(response: HttpResponseBase): Observable<MatriksNewsModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MatriksNewsModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MatriksNewsModel>(<any>null);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    getmatrikseconomynewsdata(startDate: moment.Moment | undefined, endDate: moment.Moment | undefined): Observable<MatriksEconomyNewsModel> {
        let url_ = this.baseUrl + "/api/proxy/matriks/getmatrikseconomynewsdata?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetmatrikseconomynewsdata(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetmatrikseconomynewsdata(<any>response_);
                } catch (e) {
                    return <Observable<MatriksEconomyNewsModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<MatriksEconomyNewsModel>><any>_observableThrow(response_);
        }));
    }

    protected processGetmatrikseconomynewsdata(response: HttpResponseBase): Observable<MatriksEconomyNewsModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MatriksEconomyNewsModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MatriksEconomyNewsModel>(<any>null);
    }

    /**
     * @return Success
     */
    getmatriksmarketmodeldata(): Observable<MarketModel> {
        let url_ = this.baseUrl + "/api/proxy/matriks/getmatriksmarketmodeldata";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetmatriksmarketmodeldata(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetmatriksmarketmodeldata(<any>response_);
                } catch (e) {
                    return <Observable<MarketModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<MarketModel>><any>_observableThrow(response_);
        }));
    }

    protected processGetmatriksmarketmodeldata(response: HttpResponseBase): Observable<MarketModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MarketModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MarketModel>(<any>null);
    }
}

@Injectable()
export class MediatypeApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://api.yatirimim.local";
    }

    /**
     * @return Success
     */
    getlist(): Observable<MediaType[]> {
        let url_ = this.baseUrl + "/api/settings/code/mediatype/getlist";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetlist(<any>response_);
                } catch (e) {
                    return <Observable<MediaType[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<MediaType[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetlist(response: HttpResponseBase): Observable<MediaType[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MediaType.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MediaType[]>(<any>null);
    }
}

@Injectable()
export class NotificationApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://api.yatirimim.local";
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    getnotifications(userId: number | undefined): Observable<Notification[]> {
        let url_ = this.baseUrl + "/api/contents/notification/getnotifications?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetnotifications(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetnotifications(<any>response_);
                } catch (e) {
                    return <Observable<Notification[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Notification[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetnotifications(response: HttpResponseBase): Observable<Notification[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Notification.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Notification[]>(<any>null);
    }

    /**
     * @param notificationId (optional) 
     * @return Success
     */
    deletenotification(notificationId: number | undefined): Observable<Notification> {
        let url_ = this.baseUrl + "/api/contents/notification/deletenotification?";
        if (notificationId === null)
            throw new Error("The parameter 'notificationId' cannot be null.");
        else if (notificationId !== undefined)
            url_ += "notificationId=" + encodeURIComponent("" + notificationId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletenotification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletenotification(<any>response_);
                } catch (e) {
                    return <Observable<Notification>><any>_observableThrow(e);
                }
            } else
                return <Observable<Notification>><any>_observableThrow(response_);
        }));
    }

    protected processDeletenotification(response: HttpResponseBase): Observable<Notification> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Notification.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Notification>(<any>null);
    }
}

@Injectable()
export class NotificationtypeApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://api.yatirimim.local";
    }

    /**
     * @return Success
     */
    getlist(): Observable<NotificationType[]> {
        let url_ = this.baseUrl + "/api/settings/code/notificationtype/getlist";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetlist(<any>response_);
                } catch (e) {
                    return <Observable<NotificationType[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NotificationType[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetlist(response: HttpResponseBase): Observable<NotificationType[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NotificationType.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NotificationType[]>(<any>null);
    }
}

@Injectable()
export class OrderApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://api.yatirimim.local";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    add(body: Order | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/commerce/order/add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAdd(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param orderId (optional) 
     * @return Success
     */
    cancel(orderId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/commerce/order/cancel?";
        if (orderId === null)
            throw new Error("The parameter 'orderId' cannot be null.");
        else if (orderId !== undefined)
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancel(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCancel(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param orderId (optional) 
     * @return Success
     */
    complete(orderId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/commerce/order/complete?";
        if (orderId === null)
            throw new Error("The parameter 'orderId' cannot be null.");
        else if (orderId !== undefined)
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processComplete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processComplete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processComplete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class OrderstatusApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://api.yatirimim.local";
    }

    /**
     * @return Success
     */
    getlist(): Observable<OrderStatus[]> {
        let url_ = this.baseUrl + "/api/settings/code/orderstatus/getlist";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetlist(<any>response_);
                } catch (e) {
                    return <Observable<OrderStatus[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrderStatus[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetlist(response: HttpResponseBase): Observable<OrderStatus[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OrderStatus.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrderStatus[]>(<any>null);
    }
}

@Injectable()
export class PaymenttypeApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://api.yatirimim.local";
    }

    /**
     * @return Success
     */
    getlist(): Observable<PaymentType[]> {
        let url_ = this.baseUrl + "/api/settings/code/paymenttype/getlist";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetlist(<any>response_);
                } catch (e) {
                    return <Observable<PaymentType[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PaymentType[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetlist(response: HttpResponseBase): Observable<PaymentType[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PaymentType.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaymentType[]>(<any>null);
    }
}

@Injectable()
export class PostApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://api.yatirimim.local";
    }

    /**
     * @return Success
     */
    getlist(): Observable<Post[]> {
        let url_ = this.baseUrl + "/api/contents/post/getlist";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetlist(<any>response_);
                } catch (e) {
                    return <Observable<Post[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Post[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetlist(response: HttpResponseBase): Observable<Post[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Post.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Post[]>(<any>null);
    }
}

@Injectable()
export class ProducttypeApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://api.yatirimim.local";
    }

    /**
     * @return Success
     */
    getlist(): Observable<ProductType[]> {
        let url_ = this.baseUrl + "/api/settings/code/producttype/getlist";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetlist(<any>response_);
                } catch (e) {
                    return <Observable<ProductType[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProductType[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetlist(response: HttpResponseBase): Observable<ProductType[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProductType.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductType[]>(<any>null);
    }
}

@Injectable()
export class ProductunitApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://api.yatirimim.local";
    }

    /**
     * @return Success
     */
    getlist(): Observable<ProductUnit[]> {
        let url_ = this.baseUrl + "/api/settings/code/productunit/getlist";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetlist(<any>response_);
                } catch (e) {
                    return <Observable<ProductUnit[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProductUnit[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetlist(response: HttpResponseBase): Observable<ProductUnit[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProductUnit.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductUnit[]>(<any>null);
    }
}

@Injectable()
export class ProvinceApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://api.yatirimim.local";
    }

    /**
     * @return Success
     */
    getlist(): Observable<Province[]> {
        let url_ = this.baseUrl + "/api/settings/place/province/getlist";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetlist(<any>response_);
                } catch (e) {
                    return <Observable<Province[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Province[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetlist(response: HttpResponseBase): Observable<Province[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Province.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Province[]>(<any>null);
    }
}

@Injectable()
export class RequeststatusApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://api.yatirimim.local";
    }

    /**
     * @return Success
     */
    getlist(): Observable<RequestStatus[]> {
        let url_ = this.baseUrl + "/api/settings/code/requeststatus/getlist";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetlist(<any>response_);
                } catch (e) {
                    return <Observable<RequestStatus[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<RequestStatus[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetlist(response: HttpResponseBase): Observable<RequestStatus[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RequestStatus.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RequestStatus[]>(<any>null);
    }
}

@Injectable()
export class RequesttypeApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://api.yatirimim.local";
    }

    /**
     * @return Success
     */
    getlist(): Observable<RequestType[]> {
        let url_ = this.baseUrl + "/api/settings/code/requesttype/getlist";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetlist(<any>response_);
                } catch (e) {
                    return <Observable<RequestType[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<RequestType[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetlist(response: HttpResponseBase): Observable<RequestType[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RequestType.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RequestType[]>(<any>null);
    }
}

@Injectable()
export class RetailApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://api.yatirimim.local";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    add(body: Retail | undefined): Observable<RetailModel> {
        let url_ = this.baseUrl + "/api/auth/retail/add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd(<any>response_);
                } catch (e) {
                    return <Observable<RetailModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<RetailModel>><any>_observableThrow(response_);
        }));
    }

    protected processAdd(response: HttpResponseBase): Observable<RetailModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RetailModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RetailModel>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getbyid(id: number | undefined): Observable<RetailModel> {
        let url_ = this.baseUrl + "/api/auth/retail/getbyid?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyid(<any>response_);
                } catch (e) {
                    return <Observable<RetailModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<RetailModel>><any>_observableThrow(response_);
        }));
    }

    protected processGetbyid(response: HttpResponseBase): Observable<RetailModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RetailModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RetailModel>(<any>null);
    }

    /**
     * @return Success
     */
    read(): Observable<RetailModel[]> {
        let url_ = this.baseUrl + "/api/auth/retail/read";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRead(<any>response_);
                } catch (e) {
                    return <Observable<RetailModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<RetailModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processRead(response: HttpResponseBase): Observable<RetailModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RetailModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RetailModel[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: Retail | undefined): Observable<RetailModel> {
        let url_ = this.baseUrl + "/api/auth/retail/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<RetailModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<RetailModel>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<RetailModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RetailModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RetailModel>(<any>null);
    }
}

@Injectable()
export class RssfeedApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://api.yatirimim.local";
    }

    /**
     * @return Success
     */
    getlist(): Observable<RssFeed[]> {
        let url_ = this.baseUrl + "/api/contents/rssfeed/getlist";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetlist(<any>response_);
                } catch (e) {
                    return <Observable<RssFeed[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<RssFeed[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetlist(response: HttpResponseBase): Observable<RssFeed[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RssFeed.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RssFeed[]>(<any>null);
    }
}

@Injectable()
export class ScantypeApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://api.yatirimim.local";
    }

    /**
     * @return Success
     */
    getlist(): Observable<ScanType[]> {
        let url_ = this.baseUrl + "/api/settings/code/scantype/getlist";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetlist(<any>response_);
                } catch (e) {
                    return <Observable<ScanType[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ScanType[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetlist(response: HttpResponseBase): Observable<ScanType[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ScanType.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ScanType[]>(<any>null);
    }
}

@Injectable()
export class SettingApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://api.yatirimim.local";
    }

    /**
     * @return Success
     */
    getlist(): Observable<Setting[]> {
        let url_ = this.baseUrl + "/api/settings/core/setting/getlist";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetlist(<any>response_);
                } catch (e) {
                    return <Observable<Setting[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Setting[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetlist(response: HttpResponseBase): Observable<Setting[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Setting.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Setting[]>(<any>null);
    }
}

@Injectable()
export class StaticpageApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://api.yatirimim.local";
    }

    /**
     * @return Success
     */
    getlist(): Observable<StaticPage[]> {
        let url_ = this.baseUrl + "/api/contents/staticpage/getlist";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetlist(<any>response_);
                } catch (e) {
                    return <Observable<StaticPage[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<StaticPage[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetlist(response: HttpResponseBase): Observable<StaticPage[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(StaticPage.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StaticPage[]>(<any>null);
    }
}

@Injectable()
export class SymbolsApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://api.yatirimim.local";
    }

    /**
     * @return Success
     */
    getsymbollist(): Observable<Symbol[]> {
        let url_ = this.baseUrl + "/api/finance/symbols/getsymbollist";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetsymbollist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetsymbollist(<any>response_);
                } catch (e) {
                    return <Observable<Symbol[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Symbol[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetsymbollist(response: HttpResponseBase): Observable<Symbol[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Symbol.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Symbol[]>(<any>null);
    }
}

@Injectable()
export class SymboltypeApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://api.yatirimim.local";
    }

    /**
     * @return Success
     */
    getlist(): Observable<SymbolType[]> {
        let url_ = this.baseUrl + "/api/settings/code/symboltype/getlist";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetlist(<any>response_);
                } catch (e) {
                    return <Observable<SymbolType[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SymbolType[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetlist(response: HttpResponseBase): Observable<SymbolType[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SymbolType.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SymbolType[]>(<any>null);
    }
}

@Injectable()
export class TransactionsApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://api.yatirimim.local";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    gettransactionhistory(body: TransactionRequestModel | undefined): Observable<Transaction[]> {
        let url_ = this.baseUrl + "/api/finance/transactions/gettransactionhistory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGettransactionhistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGettransactionhistory(<any>response_);
                } catch (e) {
                    return <Observable<Transaction[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Transaction[]>><any>_observableThrow(response_);
        }));
    }

    protected processGettransactionhistory(response: HttpResponseBase): Observable<Transaction[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Transaction.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Transaction[]>(<any>null);
    }
}

@Injectable()
export class TransactiontypeApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://api.yatirimim.local";
    }

    /**
     * @return Success
     */
    getlist(): Observable<TransactionType[]> {
        let url_ = this.baseUrl + "/api/settings/code/transactiontype/getlist";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetlist(<any>response_);
                } catch (e) {
                    return <Observable<TransactionType[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TransactionType[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetlist(response: HttpResponseBase): Observable<TransactionType[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TransactionType.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransactionType[]>(<any>null);
    }
}

@Injectable()
export class WithdrawalsApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://api.yatirimim.local";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addphysical(body: Request | undefined): Observable<Request> {
        let url_ = this.baseUrl + "/api/finance/withdrawals/addphysical";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddphysical(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddphysical(<any>response_);
                } catch (e) {
                    return <Observable<Request>><any>_observableThrow(e);
                }
            } else
                return <Observable<Request>><any>_observableThrow(response_);
        }));
    }

    protected processAddphysical(response: HttpResponseBase): Observable<Request> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Request.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Request>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    adddigital(body: Request | undefined): Observable<Request> {
        let url_ = this.baseUrl + "/api/finance/withdrawals/adddigital";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdddigital(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdddigital(<any>response_);
                } catch (e) {
                    return <Observable<Request>><any>_observableThrow(e);
                }
            } else
                return <Observable<Request>><any>_observableThrow(response_);
        }));
    }

    protected processAdddigital(response: HttpResponseBase): Observable<Request> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Request.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Request>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getbyid(id: number | undefined): Observable<Request> {
        let url_ = this.baseUrl + "/api/finance/withdrawals/getbyid?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyid(<any>response_);
                } catch (e) {
                    return <Observable<Request>><any>_observableThrow(e);
                }
            } else
                return <Observable<Request>><any>_observableThrow(response_);
        }));
    }

    protected processGetbyid(response: HttpResponseBase): Observable<Request> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Request.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Request>(<any>null);
    }

    getdetailbyid(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/finance/withdrawals/getdetailbyid?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetdetailbyid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetdetailbyid(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGetdetailbyid(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param customerId (optional) 
     * @return Success
     */
    getdigitalrequestlist(customerId: number | undefined): Observable<Request[]> {
        let url_ = this.baseUrl + "/api/finance/withdrawals/getdigitalrequestlist?";
        if (customerId === null)
            throw new Error("The parameter 'customerId' cannot be null.");
        else if (customerId !== undefined)
            url_ += "customerId=" + encodeURIComponent("" + customerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetdigitalrequestlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetdigitalrequestlist(<any>response_);
                } catch (e) {
                    return <Observable<Request[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Request[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetdigitalrequestlist(response: HttpResponseBase): Observable<Request[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Request.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Request[]>(<any>null);
    }

    /**
     * @param customerId (optional) 
     * @return Success
     */
    getphysicalrequestlist(customerId: number | undefined): Observable<Request[]> {
        let url_ = this.baseUrl + "/api/finance/withdrawals/getphysicalrequestlist?";
        if (customerId === null)
            throw new Error("The parameter 'customerId' cannot be null.");
        else if (customerId !== undefined)
            url_ += "customerId=" + encodeURIComponent("" + customerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetphysicalrequestlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetphysicalrequestlist(<any>response_);
                } catch (e) {
                    return <Observable<Request[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Request[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetphysicalrequestlist(response: HttpResponseBase): Observable<Request[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Request.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Request[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: Request | undefined): Observable<Request> {
        let url_ = this.baseUrl + "/api/finance/withdrawals/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<Request>><any>_observableThrow(e);
                }
            } else
                return <Observable<Request>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<Request> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Request.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Request>(<any>null);
    }
}

export class ActionContextBooleanFunc implements IActionContextBooleanFunc {
    readonly target?: any | undefined;
    method?: MethodInfo;

    constructor(data?: IActionContextBooleanFunc) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).target = _data["Target"];
            this.method = _data["Method"] ? MethodInfo.fromJS(_data["Method"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ActionContextBooleanFunc {
        data = typeof data === 'object' ? data : {};
        let result = new ActionContextBooleanFunc();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Target"] = this.target;
        data["Method"] = this.method ? this.method.toJSON() : <any>undefined;
        return data;
    }
}

export interface IActionContextBooleanFunc {
    target?: any | undefined;
    method?: MethodInfo;
}

export class ActionDescriptor implements IActionDescriptor {
    readonly id?: string | undefined;
    routeValues?: { [key: string]: string; } | undefined;
    attributeRouteInfo?: AttributeRouteInfo;
    actionConstraints?: IActionConstraintMetadata[] | undefined;
    endpointMetadata?: any[] | undefined;
    parameters?: ParameterDescriptor[] | undefined;
    boundProperties?: ParameterDescriptor[] | undefined;
    filterDescriptors?: FilterDescriptor[] | undefined;
    displayName?: string | undefined;
    properties?: { [key: string]: any; } | undefined;

    constructor(data?: IActionDescriptor) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).id = _data["Id"];
            if (_data["RouteValues"]) {
                this.routeValues = {} as any;
                for (let key in _data["RouteValues"]) {
                    if (_data["RouteValues"].hasOwnProperty(key))
                        (<any>this.routeValues)![key] = _data["RouteValues"][key];
                }
            }
            this.attributeRouteInfo = _data["AttributeRouteInfo"] ? AttributeRouteInfo.fromJS(_data["AttributeRouteInfo"]) : <any>undefined;
            if (Array.isArray(_data["ActionConstraints"])) {
                this.actionConstraints = [] as any;
                for (let item of _data["ActionConstraints"])
                    this.actionConstraints!.push(IActionConstraintMetadata.fromJS(item));
            }
            if (Array.isArray(_data["EndpointMetadata"])) {
                this.endpointMetadata = [] as any;
                for (let item of _data["EndpointMetadata"])
                    this.endpointMetadata!.push(item);
            }
            if (Array.isArray(_data["Parameters"])) {
                this.parameters = [] as any;
                for (let item of _data["Parameters"])
                    this.parameters!.push(ParameterDescriptor.fromJS(item));
            }
            if (Array.isArray(_data["BoundProperties"])) {
                this.boundProperties = [] as any;
                for (let item of _data["BoundProperties"])
                    this.boundProperties!.push(ParameterDescriptor.fromJS(item));
            }
            if (Array.isArray(_data["FilterDescriptors"])) {
                this.filterDescriptors = [] as any;
                for (let item of _data["FilterDescriptors"])
                    this.filterDescriptors!.push(FilterDescriptor.fromJS(item));
            }
            this.displayName = _data["DisplayName"];
            if (_data["Properties"]) {
                this.properties = {} as any;
                for (let key in _data["Properties"]) {
                    if (_data["Properties"].hasOwnProperty(key))
                        (<any>this.properties)![key] = _data["Properties"][key];
                }
            }
        }
    }

    static fromJS(data: any): ActionDescriptor {
        data = typeof data === 'object' ? data : {};
        let result = new ActionDescriptor();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        if (this.routeValues) {
            data["RouteValues"] = {};
            for (let key in this.routeValues) {
                if (this.routeValues.hasOwnProperty(key))
                    (<any>data["RouteValues"])[key] = this.routeValues[key];
            }
        }
        data["AttributeRouteInfo"] = this.attributeRouteInfo ? this.attributeRouteInfo.toJSON() : <any>undefined;
        if (Array.isArray(this.actionConstraints)) {
            data["ActionConstraints"] = [];
            for (let item of this.actionConstraints)
                data["ActionConstraints"].push(item.toJSON());
        }
        if (Array.isArray(this.endpointMetadata)) {
            data["EndpointMetadata"] = [];
            for (let item of this.endpointMetadata)
                data["EndpointMetadata"].push(item);
        }
        if (Array.isArray(this.parameters)) {
            data["Parameters"] = [];
            for (let item of this.parameters)
                data["Parameters"].push(item.toJSON());
        }
        if (Array.isArray(this.boundProperties)) {
            data["BoundProperties"] = [];
            for (let item of this.boundProperties)
                data["BoundProperties"].push(item.toJSON());
        }
        if (Array.isArray(this.filterDescriptors)) {
            data["FilterDescriptors"] = [];
            for (let item of this.filterDescriptors)
                data["FilterDescriptors"].push(item.toJSON());
        }
        data["DisplayName"] = this.displayName;
        if (this.properties) {
            data["Properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["Properties"])[key] = this.properties[key];
            }
        }
        return data;
    }
}

export interface IActionDescriptor {
    id?: string | undefined;
    routeValues?: { [key: string]: string; } | undefined;
    attributeRouteInfo?: AttributeRouteInfo;
    actionConstraints?: IActionConstraintMetadata[] | undefined;
    endpointMetadata?: any[] | undefined;
    parameters?: ParameterDescriptor[] | undefined;
    boundProperties?: ParameterDescriptor[] | undefined;
    filterDescriptors?: FilterDescriptor[] | undefined;
    displayName?: string | undefined;
    properties?: { [key: string]: any; } | undefined;
}

export class Address implements IAddress {
    id?: number;
    name?: string | undefined;
    contactName?: string | undefined;
    phone?: string | undefined;
    addressLine?: string | undefined;
    directions?: string | undefined;
    latitude?: number;
    longitude?: number;
    neighborhoodId?: number | undefined;
    neighborhood?: Neighborhood;
    districtId?: number | undefined;
    district?: District;
    provinceId?: number;
    province?: Province;
    countryId?: string | undefined;
    country?: Country;

    constructor(data?: IAddress) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.name = _data["Name"];
            this.contactName = _data["ContactName"];
            this.phone = _data["Phone"];
            this.addressLine = _data["AddressLine"];
            this.directions = _data["Directions"];
            this.latitude = _data["Latitude"];
            this.longitude = _data["Longitude"];
            this.neighborhoodId = _data["NeighborhoodId"];
            this.neighborhood = _data["Neighborhood"] ? Neighborhood.fromJS(_data["Neighborhood"]) : <any>undefined;
            this.districtId = _data["DistrictId"];
            this.district = _data["District"] ? District.fromJS(_data["District"]) : <any>undefined;
            this.provinceId = _data["ProvinceId"];
            this.province = _data["Province"] ? Province.fromJS(_data["Province"]) : <any>undefined;
            this.countryId = _data["CountryId"];
            this.country = _data["Country"] ? Country.fromJS(_data["Country"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Address {
        data = typeof data === 'object' ? data : {};
        let result = new Address();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Name"] = this.name;
        data["ContactName"] = this.contactName;
        data["Phone"] = this.phone;
        data["AddressLine"] = this.addressLine;
        data["Directions"] = this.directions;
        data["Latitude"] = this.latitude;
        data["Longitude"] = this.longitude;
        data["NeighborhoodId"] = this.neighborhoodId;
        data["Neighborhood"] = this.neighborhood ? this.neighborhood.toJSON() : <any>undefined;
        data["DistrictId"] = this.districtId;
        data["District"] = this.district ? this.district.toJSON() : <any>undefined;
        data["ProvinceId"] = this.provinceId;
        data["Province"] = this.province ? this.province.toJSON() : <any>undefined;
        data["CountryId"] = this.countryId;
        data["Country"] = this.country ? this.country.toJSON() : <any>undefined;
        return data;
    }
}

export interface IAddress {
    id?: number;
    name?: string | undefined;
    contactName?: string | undefined;
    phone?: string | undefined;
    addressLine?: string | undefined;
    directions?: string | undefined;
    latitude?: number;
    longitude?: number;
    neighborhoodId?: number | undefined;
    neighborhood?: Neighborhood;
    districtId?: number | undefined;
    district?: District;
    provinceId?: number;
    province?: Province;
    countryId?: string | undefined;
    country?: Country;
}

export enum AddressFamily {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _8 = 8,
    _9 = 9,
    _10 = 10,
    _11 = 11,
    _12 = 12,
    _13 = 13,
    _14 = 14,
    _15 = 15,
    _16 = 16,
    _17 = 17,
    _18 = 18,
    _19 = 19,
    _21 = 21,
    _22 = 22,
    _23 = 23,
    _24 = 24,
    _25 = 25,
    _26 = 26,
    _28 = 28,
    _29 = 29,
    _65536 = 65536,
    _65537 = 65537,
    __1 = -1,
}

export class Altin implements IAltin {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IAltin) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): Altin {
        data = typeof data === 'object' ? data : {};
        let result = new Altin();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IAltin {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class Altincum implements IAltincum {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IAltincum) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): Altincum {
        data = typeof data === 'object' ? data : {};
        let result = new Altincum();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IAltincum {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class AltinfixEurAm implements IAltinfixEurAm {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IAltinfixEurAm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): AltinfixEurAm {
        data = typeof data === 'object' ? data : {};
        let result = new AltinfixEurAm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IAltinfixEurAm {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class AltinfixEurPm implements IAltinfixEurPm {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IAltinfixEurPm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): AltinfixEurPm {
        data = typeof data === 'object' ? data : {};
        let result = new AltinfixEurPm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IAltinfixEurPm {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class AltinfixGbpAm implements IAltinfixGbpAm {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IAltinfixGbpAm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): AltinfixGbpAm {
        data = typeof data === 'object' ? data : {};
        let result = new AltinfixGbpAm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IAltinfixGbpAm {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class AltinfixGbpPm implements IAltinfixGbpPm {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IAltinfixGbpPm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): AltinfixGbpPm {
        data = typeof data === 'object' ? data : {};
        let result = new AltinfixGbpPm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IAltinfixGbpPm {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class AltinfixUsdAm implements IAltinfixUsdAm {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IAltinfixUsdAm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): AltinfixUsdAm {
        data = typeof data === 'object' ? data : {};
        let result = new AltinfixUsdAm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IAltinfixUsdAm {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class AltinfixUsdPm implements IAltinfixUsdPm {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IAltinfixUsdPm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): AltinfixUsdPm {
        data = typeof data === 'object' ? data : {};
        let result = new AltinfixUsdPm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IAltinfixUsdPm {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class Altingldc implements IAltingldc {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IAltingldc) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): Altingldc {
        data = typeof data === 'object' ? data : {};
        let result = new Altingldc();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IAltingldc {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class Altingldt implements IAltingldt {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IAltingldt) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): Altingldt {
        data = typeof data === 'object' ? data : {};
        let result = new Altingldt();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IAltingldt {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class Altingldy implements IAltingldy {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IAltingldy) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): Altingldy {
        data = typeof data === 'object' ? data : {};
        let result = new Altingldy();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IAltingldy {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class Altingr implements IAltingr {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IAltingr) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): Altingr {
        data = typeof data === 'object' ? data : {};
        let result = new Altingr();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IAltingr {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class Altinkgtl implements IAltinkgtl {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IAltinkgtl) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): Altinkgtl {
        data = typeof data === 'object' ? data : {};
        let result = new Altinkgtl();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IAltinkgtl {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class Altinkgusd implements IAltinkgusd {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IAltinkgusd) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): Altinkgusd {
        data = typeof data === 'object' ? data : {};
        let result = new Altinkgusd();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IAltinkgusd {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class Altinres implements IAltinres {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IAltinres) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): Altinres {
        data = typeof data === 'object' ? data : {};
        let result = new Altinres();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IAltinres {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class Altinresk implements IAltinresk {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IAltinresk) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): Altinresk {
        data = typeof data === 'object' ? data : {};
        let result = new Altinresk();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IAltinresk {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class Altinusd implements IAltinusd {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IAltinusd) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): Altinusd {
        data = typeof data === 'object' ? data : {};
        let result = new Altinusd();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IAltinusd {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class Analysis implements IAnalysis {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    title!: string;
    subTitle?: string | undefined;
    slug?: string | undefined;
    metaKeywords?: string | undefined;
    metaDescription?: string | undefined;
    body?: string | undefined;
    mediaId?: number | undefined;
    media?: Media;
    isPublished?: boolean;
    publishedOn?: moment.Moment | undefined;
    publishedTill?: moment.Moment | undefined;
    symbolId?: number | undefined;
    symbol?: Symbol;

    constructor(data?: IAnalysis) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.createdOn = _data["CreatedOn"] ? moment(_data["CreatedOn"].toString()) : <any>undefined;
            this.createdById = _data["CreatedById"];
            this.createdBy = _data["CreatedBy"] ? User.fromJS(_data["CreatedBy"]) : <any>undefined;
            this.updatedOn = _data["UpdatedOn"] ? moment(_data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedById = _data["UpdatedById"];
            this.updatedBy = _data["UpdatedBy"] ? User.fromJS(_data["UpdatedBy"]) : <any>undefined;
            this.deletedOn = _data["DeletedOn"] ? moment(_data["DeletedOn"].toString()) : <any>undefined;
            this.deletedById = _data["DeletedById"];
            this.deletedBy = _data["DeletedBy"] ? User.fromJS(_data["DeletedBy"]) : <any>undefined;
            this.isDeleted = _data["IsDeleted"];
            this.title = _data["Title"];
            this.subTitle = _data["SubTitle"];
            this.slug = _data["Slug"];
            this.metaKeywords = _data["MetaKeywords"];
            this.metaDescription = _data["MetaDescription"];
            this.body = _data["Body"];
            this.mediaId = _data["MediaId"];
            this.media = _data["Media"] ? Media.fromJS(_data["Media"]) : <any>undefined;
            this.isPublished = _data["IsPublished"];
            this.publishedOn = _data["PublishedOn"] ? moment(_data["PublishedOn"].toString()) : <any>undefined;
            this.publishedTill = _data["PublishedTill"] ? moment(_data["PublishedTill"].toString()) : <any>undefined;
            this.symbolId = _data["SymbolId"];
            this.symbol = _data["Symbol"] ? Symbol.fromJS(_data["Symbol"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Analysis {
        data = typeof data === 'object' ? data : {};
        let result = new Analysis();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedById"] = this.createdById;
        data["CreatedBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["DeletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        data["DeletedById"] = this.deletedById;
        data["DeletedBy"] = this.deletedBy ? this.deletedBy.toJSON() : <any>undefined;
        data["IsDeleted"] = this.isDeleted;
        data["Title"] = this.title;
        data["SubTitle"] = this.subTitle;
        data["Slug"] = this.slug;
        data["MetaKeywords"] = this.metaKeywords;
        data["MetaDescription"] = this.metaDescription;
        data["Body"] = this.body;
        data["MediaId"] = this.mediaId;
        data["Media"] = this.media ? this.media.toJSON() : <any>undefined;
        data["IsPublished"] = this.isPublished;
        data["PublishedOn"] = this.publishedOn ? this.publishedOn.toISOString() : <any>undefined;
        data["PublishedTill"] = this.publishedTill ? this.publishedTill.toISOString() : <any>undefined;
        data["SymbolId"] = this.symbolId;
        data["Symbol"] = this.symbol ? this.symbol.toJSON() : <any>undefined;
        return data;
    }
}

export interface IAnalysis {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    title: string;
    subTitle?: string | undefined;
    slug?: string | undefined;
    metaKeywords?: string | undefined;
    metaDescription?: string | undefined;
    body?: string | undefined;
    mediaId?: number | undefined;
    media?: Media;
    isPublished?: boolean;
    publishedOn?: moment.Moment | undefined;
    publishedTill?: moment.Moment | undefined;
    symbolId?: number | undefined;
    symbol?: Symbol;
}

export class AsnEncodedData implements IAsnEncodedData {
    oid?: Oid;
    rawData?: string | undefined;

    constructor(data?: IAsnEncodedData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.oid = _data["Oid"] ? Oid.fromJS(_data["Oid"]) : <any>undefined;
            this.rawData = _data["RawData"];
        }
    }

    static fromJS(data: any): AsnEncodedData {
        data = typeof data === 'object' ? data : {};
        let result = new AsnEncodedData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Oid"] = this.oid ? this.oid.toJSON() : <any>undefined;
        data["RawData"] = this.rawData;
        return data;
    }
}

export interface IAsnEncodedData {
    oid?: Oid;
    rawData?: string | undefined;
}

export class Assembly implements IAssembly {
    readonly definedTypes?: TypeInfo[] | undefined;
    readonly exportedTypes?: Type[] | undefined;
    readonly codeBase?: string | undefined;
    entryPoint?: MethodInfo;
    readonly fullName?: string | undefined;
    readonly imageRuntimeVersion?: string | undefined;
    readonly isDynamic?: boolean;
    readonly location?: string | undefined;
    readonly reflectionOnly?: boolean;
    readonly isCollectible?: boolean;
    readonly isFullyTrusted?: boolean;
    readonly customAttributes?: CustomAttributeData[] | undefined;
    readonly escapedCodeBase?: string | undefined;
    manifestModule?: Module;
    readonly modules?: Module[] | undefined;
    readonly globalAssemblyCache?: boolean;
    readonly hostContext?: number;
    securityRuleSet?: SecurityRuleSet;

    constructor(data?: IAssembly) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["DefinedTypes"])) {
                (<any>this).definedTypes = [] as any;
                for (let item of _data["DefinedTypes"])
                    (<any>this).definedTypes!.push(TypeInfo.fromJS(item));
            }
            if (Array.isArray(_data["ExportedTypes"])) {
                (<any>this).exportedTypes = [] as any;
                for (let item of _data["ExportedTypes"])
                    (<any>this).exportedTypes!.push(Type.fromJS(item));
            }
            (<any>this).codeBase = _data["CodeBase"];
            this.entryPoint = _data["EntryPoint"] ? MethodInfo.fromJS(_data["EntryPoint"]) : <any>undefined;
            (<any>this).fullName = _data["FullName"];
            (<any>this).imageRuntimeVersion = _data["ImageRuntimeVersion"];
            (<any>this).isDynamic = _data["IsDynamic"];
            (<any>this).location = _data["Location"];
            (<any>this).reflectionOnly = _data["ReflectionOnly"];
            (<any>this).isCollectible = _data["IsCollectible"];
            (<any>this).isFullyTrusted = _data["IsFullyTrusted"];
            if (Array.isArray(_data["CustomAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["CustomAttributes"])
                    (<any>this).customAttributes!.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).escapedCodeBase = _data["EscapedCodeBase"];
            this.manifestModule = _data["ManifestModule"] ? Module.fromJS(_data["ManifestModule"]) : <any>undefined;
            if (Array.isArray(_data["Modules"])) {
                (<any>this).modules = [] as any;
                for (let item of _data["Modules"])
                    (<any>this).modules!.push(Module.fromJS(item));
            }
            (<any>this).globalAssemblyCache = _data["GlobalAssemblyCache"];
            (<any>this).hostContext = _data["HostContext"];
            this.securityRuleSet = _data["SecurityRuleSet"];
        }
    }

    static fromJS(data: any): Assembly {
        data = typeof data === 'object' ? data : {};
        let result = new Assembly();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.definedTypes)) {
            data["DefinedTypes"] = [];
            for (let item of this.definedTypes)
                data["DefinedTypes"].push(item.toJSON());
        }
        if (Array.isArray(this.exportedTypes)) {
            data["ExportedTypes"] = [];
            for (let item of this.exportedTypes)
                data["ExportedTypes"].push(item.toJSON());
        }
        data["CodeBase"] = this.codeBase;
        data["EntryPoint"] = this.entryPoint ? this.entryPoint.toJSON() : <any>undefined;
        data["FullName"] = this.fullName;
        data["ImageRuntimeVersion"] = this.imageRuntimeVersion;
        data["IsDynamic"] = this.isDynamic;
        data["Location"] = this.location;
        data["ReflectionOnly"] = this.reflectionOnly;
        data["IsCollectible"] = this.isCollectible;
        data["IsFullyTrusted"] = this.isFullyTrusted;
        if (Array.isArray(this.customAttributes)) {
            data["CustomAttributes"] = [];
            for (let item of this.customAttributes)
                data["CustomAttributes"].push(item.toJSON());
        }
        data["EscapedCodeBase"] = this.escapedCodeBase;
        data["ManifestModule"] = this.manifestModule ? this.manifestModule.toJSON() : <any>undefined;
        if (Array.isArray(this.modules)) {
            data["Modules"] = [];
            for (let item of this.modules)
                data["Modules"].push(item.toJSON());
        }
        data["GlobalAssemblyCache"] = this.globalAssemblyCache;
        data["HostContext"] = this.hostContext;
        data["SecurityRuleSet"] = this.securityRuleSet;
        return data;
    }
}

export interface IAssembly {
    definedTypes?: TypeInfo[] | undefined;
    exportedTypes?: Type[] | undefined;
    codeBase?: string | undefined;
    entryPoint?: MethodInfo;
    fullName?: string | undefined;
    imageRuntimeVersion?: string | undefined;
    isDynamic?: boolean;
    location?: string | undefined;
    reflectionOnly?: boolean;
    isCollectible?: boolean;
    isFullyTrusted?: boolean;
    customAttributes?: CustomAttributeData[] | undefined;
    escapedCodeBase?: string | undefined;
    manifestModule?: Module;
    modules?: Module[] | undefined;
    globalAssemblyCache?: boolean;
    hostContext?: number;
    securityRuleSet?: SecurityRuleSet;
}

export class Asset implements IAsset {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    customerId?: number;
    customer?: Customer;
    symbolId?: number;
    symbol?: Symbol;
    quantity?: number;
    price?: number;

    constructor(data?: IAsset) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.createdOn = _data["CreatedOn"] ? moment(_data["CreatedOn"].toString()) : <any>undefined;
            this.createdById = _data["CreatedById"];
            this.createdBy = _data["CreatedBy"] ? User.fromJS(_data["CreatedBy"]) : <any>undefined;
            this.updatedOn = _data["UpdatedOn"] ? moment(_data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedById = _data["UpdatedById"];
            this.updatedBy = _data["UpdatedBy"] ? User.fromJS(_data["UpdatedBy"]) : <any>undefined;
            this.deletedOn = _data["DeletedOn"] ? moment(_data["DeletedOn"].toString()) : <any>undefined;
            this.deletedById = _data["DeletedById"];
            this.deletedBy = _data["DeletedBy"] ? User.fromJS(_data["DeletedBy"]) : <any>undefined;
            this.isDeleted = _data["IsDeleted"];
            this.customerId = _data["CustomerId"];
            this.customer = _data["Customer"] ? Customer.fromJS(_data["Customer"]) : <any>undefined;
            this.symbolId = _data["SymbolId"];
            this.symbol = _data["Symbol"] ? Symbol.fromJS(_data["Symbol"]) : <any>undefined;
            this.quantity = _data["Quantity"];
            this.price = _data["Price"];
        }
    }

    static fromJS(data: any): Asset {
        data = typeof data === 'object' ? data : {};
        let result = new Asset();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedById"] = this.createdById;
        data["CreatedBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["DeletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        data["DeletedById"] = this.deletedById;
        data["DeletedBy"] = this.deletedBy ? this.deletedBy.toJSON() : <any>undefined;
        data["IsDeleted"] = this.isDeleted;
        data["CustomerId"] = this.customerId;
        data["Customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        data["SymbolId"] = this.symbolId;
        data["Symbol"] = this.symbol ? this.symbol.toJSON() : <any>undefined;
        data["Quantity"] = this.quantity;
        data["Price"] = this.price;
        return data;
    }
}

export interface IAsset {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    customerId?: number;
    customer?: Customer;
    symbolId?: number;
    symbol?: Symbol;
    quantity?: number;
    price?: number;
}

export class AsymmetricAlgorithm implements IAsymmetricAlgorithm {
    keySize?: number;
    readonly legalKeySizes?: KeySizes[] | undefined;
    readonly signatureAlgorithm?: string | undefined;
    readonly keyExchangeAlgorithm?: string | undefined;

    constructor(data?: IAsymmetricAlgorithm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.keySize = _data["KeySize"];
            if (Array.isArray(_data["LegalKeySizes"])) {
                (<any>this).legalKeySizes = [] as any;
                for (let item of _data["LegalKeySizes"])
                    (<any>this).legalKeySizes!.push(KeySizes.fromJS(item));
            }
            (<any>this).signatureAlgorithm = _data["SignatureAlgorithm"];
            (<any>this).keyExchangeAlgorithm = _data["KeyExchangeAlgorithm"];
        }
    }

    static fromJS(data: any): AsymmetricAlgorithm {
        data = typeof data === 'object' ? data : {};
        let result = new AsymmetricAlgorithm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["KeySize"] = this.keySize;
        if (Array.isArray(this.legalKeySizes)) {
            data["LegalKeySizes"] = [];
            for (let item of this.legalKeySizes)
                data["LegalKeySizes"].push(item.toJSON());
        }
        data["SignatureAlgorithm"] = this.signatureAlgorithm;
        data["KeyExchangeAlgorithm"] = this.keyExchangeAlgorithm;
        return data;
    }
}

export interface IAsymmetricAlgorithm {
    keySize?: number;
    legalKeySizes?: KeySizes[] | undefined;
    signatureAlgorithm?: string | undefined;
    keyExchangeAlgorithm?: string | undefined;
}

export class AttributeRouteInfo implements IAttributeRouteInfo {
    template?: string | undefined;
    order?: number;
    name?: string | undefined;
    suppressLinkGeneration?: boolean;
    suppressPathMatching?: boolean;

    constructor(data?: IAttributeRouteInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.template = _data["Template"];
            this.order = _data["Order"];
            this.name = _data["Name"];
            this.suppressLinkGeneration = _data["SuppressLinkGeneration"];
            this.suppressPathMatching = _data["SuppressPathMatching"];
        }
    }

    static fromJS(data: any): AttributeRouteInfo {
        data = typeof data === 'object' ? data : {};
        let result = new AttributeRouteInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Template"] = this.template;
        data["Order"] = this.order;
        data["Name"] = this.name;
        data["SuppressLinkGeneration"] = this.suppressLinkGeneration;
        data["SuppressPathMatching"] = this.suppressPathMatching;
        return data;
    }
}

export interface IAttributeRouteInfo {
    template?: string | undefined;
    order?: number;
    name?: string | undefined;
    suppressLinkGeneration?: boolean;
    suppressPathMatching?: boolean;
}

export class Aud implements IAud {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IAud) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): Aud {
        data = typeof data === 'object' ? data : {};
        let result = new Aud();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IAud {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class Bank implements IBank {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    name!: string;
    logoId?: number | undefined;
    logo?: Media;
    description?: string | undefined;
    isActive?: boolean;

    constructor(data?: IBank) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.createdOn = _data["CreatedOn"] ? moment(_data["CreatedOn"].toString()) : <any>undefined;
            this.createdById = _data["CreatedById"];
            this.createdBy = _data["CreatedBy"] ? User.fromJS(_data["CreatedBy"]) : <any>undefined;
            this.updatedOn = _data["UpdatedOn"] ? moment(_data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedById = _data["UpdatedById"];
            this.updatedBy = _data["UpdatedBy"] ? User.fromJS(_data["UpdatedBy"]) : <any>undefined;
            this.deletedOn = _data["DeletedOn"] ? moment(_data["DeletedOn"].toString()) : <any>undefined;
            this.deletedById = _data["DeletedById"];
            this.deletedBy = _data["DeletedBy"] ? User.fromJS(_data["DeletedBy"]) : <any>undefined;
            this.isDeleted = _data["IsDeleted"];
            this.name = _data["Name"];
            this.logoId = _data["LogoId"];
            this.logo = _data["Logo"] ? Media.fromJS(_data["Logo"]) : <any>undefined;
            this.description = _data["Description"];
            this.isActive = _data["IsActive"];
        }
    }

    static fromJS(data: any): Bank {
        data = typeof data === 'object' ? data : {};
        let result = new Bank();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedById"] = this.createdById;
        data["CreatedBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["DeletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        data["DeletedById"] = this.deletedById;
        data["DeletedBy"] = this.deletedBy ? this.deletedBy.toJSON() : <any>undefined;
        data["IsDeleted"] = this.isDeleted;
        data["Name"] = this.name;
        data["LogoId"] = this.logoId;
        data["Logo"] = this.logo ? this.logo.toJSON() : <any>undefined;
        data["Description"] = this.description;
        data["IsActive"] = this.isActive;
        return data;
    }
}

export interface IBank {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    name: string;
    logoId?: number | undefined;
    logo?: Media;
    description?: string | undefined;
    isActive?: boolean;
}

export class BindingInfo implements IBindingInfo {
    bindingSource?: BindingSource;
    binderModelName?: string | undefined;
    binderType?: Type;
    propertyFilterProvider?: IPropertyFilterProvider;
    requestPredicate?: ActionContextBooleanFunc;
    emptyBodyBehavior?: EmptyBodyBehavior;

    constructor(data?: IBindingInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.bindingSource = _data["BindingSource"] ? BindingSource.fromJS(_data["BindingSource"]) : <any>undefined;
            this.binderModelName = _data["BinderModelName"];
            this.binderType = _data["BinderType"] ? Type.fromJS(_data["BinderType"]) : <any>undefined;
            this.propertyFilterProvider = _data["PropertyFilterProvider"] ? IPropertyFilterProvider.fromJS(_data["PropertyFilterProvider"]) : <any>undefined;
            this.requestPredicate = _data["RequestPredicate"] ? ActionContextBooleanFunc.fromJS(_data["RequestPredicate"]) : <any>undefined;
            this.emptyBodyBehavior = _data["EmptyBodyBehavior"];
        }
    }

    static fromJS(data: any): BindingInfo {
        data = typeof data === 'object' ? data : {};
        let result = new BindingInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["BindingSource"] = this.bindingSource ? this.bindingSource.toJSON() : <any>undefined;
        data["BinderModelName"] = this.binderModelName;
        data["BinderType"] = this.binderType ? this.binderType.toJSON() : <any>undefined;
        data["PropertyFilterProvider"] = this.propertyFilterProvider ? this.propertyFilterProvider.toJSON() : <any>undefined;
        data["RequestPredicate"] = this.requestPredicate ? this.requestPredicate.toJSON() : <any>undefined;
        data["EmptyBodyBehavior"] = this.emptyBodyBehavior;
        return data;
    }
}

export interface IBindingInfo {
    bindingSource?: BindingSource;
    binderModelName?: string | undefined;
    binderType?: Type;
    propertyFilterProvider?: IPropertyFilterProvider;
    requestPredicate?: ActionContextBooleanFunc;
    emptyBodyBehavior?: EmptyBodyBehavior;
}

export class BindingSource implements IBindingSource {
    readonly displayName?: string | undefined;
    readonly id?: string | undefined;
    readonly isGreedy?: boolean;
    readonly isFromRequest?: boolean;

    constructor(data?: IBindingSource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).displayName = _data["DisplayName"];
            (<any>this).id = _data["Id"];
            (<any>this).isGreedy = _data["IsGreedy"];
            (<any>this).isFromRequest = _data["IsFromRequest"];
        }
    }

    static fromJS(data: any): BindingSource {
        data = typeof data === 'object' ? data : {};
        let result = new BindingSource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["DisplayName"] = this.displayName;
        data["Id"] = this.id;
        data["IsGreedy"] = this.isGreedy;
        data["IsFromRequest"] = this.isFromRequest;
        return data;
    }
}

export interface IBindingSource {
    displayName?: string | undefined;
    id?: string | undefined;
    isGreedy?: boolean;
    isFromRequest?: boolean;
}

export class BloodType implements IBloodType {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    code?: string | undefined;
    group?: string | undefined;
    rhPositive?: boolean;
    displayOrder?: number;
    readonly name?: string | undefined;

    constructor(data?: IBloodType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.createdOn = _data["CreatedOn"] ? moment(_data["CreatedOn"].toString()) : <any>undefined;
            this.createdById = _data["CreatedById"];
            this.createdBy = _data["CreatedBy"] ? User.fromJS(_data["CreatedBy"]) : <any>undefined;
            this.updatedOn = _data["UpdatedOn"] ? moment(_data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedById = _data["UpdatedById"];
            this.updatedBy = _data["UpdatedBy"] ? User.fromJS(_data["UpdatedBy"]) : <any>undefined;
            this.deletedOn = _data["DeletedOn"] ? moment(_data["DeletedOn"].toString()) : <any>undefined;
            this.deletedById = _data["DeletedById"];
            this.deletedBy = _data["DeletedBy"] ? User.fromJS(_data["DeletedBy"]) : <any>undefined;
            this.isDeleted = _data["IsDeleted"];
            this.code = _data["Code"];
            this.group = _data["Group"];
            this.rhPositive = _data["RhPositive"];
            this.displayOrder = _data["DisplayOrder"];
            (<any>this).name = _data["Name"];
        }
    }

    static fromJS(data: any): BloodType {
        data = typeof data === 'object' ? data : {};
        let result = new BloodType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedById"] = this.createdById;
        data["CreatedBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["DeletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        data["DeletedById"] = this.deletedById;
        data["DeletedBy"] = this.deletedBy ? this.deletedBy.toJSON() : <any>undefined;
        data["IsDeleted"] = this.isDeleted;
        data["Code"] = this.code;
        data["Group"] = this.group;
        data["RhPositive"] = this.rhPositive;
        data["DisplayOrder"] = this.displayOrder;
        data["Name"] = this.name;
        return data;
    }
}

export interface IBloodType {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    code?: string | undefined;
    group?: string | undefined;
    rhPositive?: boolean;
    displayOrder?: number;
    name?: string | undefined;
}

export class Bonus implements IBonus {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    customerId?: number;
    customer?: Customer;
    symbolId?: number;
    symbol?: Symbol;
    quantity?: number;
    price?: number;
    isUsed?: boolean;
    isActive?: boolean;

    constructor(data?: IBonus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.createdOn = _data["CreatedOn"] ? moment(_data["CreatedOn"].toString()) : <any>undefined;
            this.createdById = _data["CreatedById"];
            this.createdBy = _data["CreatedBy"] ? User.fromJS(_data["CreatedBy"]) : <any>undefined;
            this.updatedOn = _data["UpdatedOn"] ? moment(_data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedById = _data["UpdatedById"];
            this.updatedBy = _data["UpdatedBy"] ? User.fromJS(_data["UpdatedBy"]) : <any>undefined;
            this.deletedOn = _data["DeletedOn"] ? moment(_data["DeletedOn"].toString()) : <any>undefined;
            this.deletedById = _data["DeletedById"];
            this.deletedBy = _data["DeletedBy"] ? User.fromJS(_data["DeletedBy"]) : <any>undefined;
            this.isDeleted = _data["IsDeleted"];
            this.customerId = _data["CustomerId"];
            this.customer = _data["Customer"] ? Customer.fromJS(_data["Customer"]) : <any>undefined;
            this.symbolId = _data["SymbolId"];
            this.symbol = _data["Symbol"] ? Symbol.fromJS(_data["Symbol"]) : <any>undefined;
            this.quantity = _data["Quantity"];
            this.price = _data["Price"];
            this.isUsed = _data["IsUsed"];
            this.isActive = _data["IsActive"];
        }
    }

    static fromJS(data: any): Bonus {
        data = typeof data === 'object' ? data : {};
        let result = new Bonus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedById"] = this.createdById;
        data["CreatedBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["DeletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        data["DeletedById"] = this.deletedById;
        data["DeletedBy"] = this.deletedBy ? this.deletedBy.toJSON() : <any>undefined;
        data["IsDeleted"] = this.isDeleted;
        data["CustomerId"] = this.customerId;
        data["Customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        data["SymbolId"] = this.symbolId;
        data["Symbol"] = this.symbol ? this.symbol.toJSON() : <any>undefined;
        data["Quantity"] = this.quantity;
        data["Price"] = this.price;
        data["IsUsed"] = this.isUsed;
        data["IsActive"] = this.isActive;
        return data;
    }
}

export interface IBonus {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    customerId?: number;
    customer?: Customer;
    symbolId?: number;
    symbol?: Symbol;
    quantity?: number;
    price?: number;
    isUsed?: boolean;
    isActive?: boolean;
}

export class ByteReadOnlySpan implements IByteReadOnlySpan {
    readonly length?: number;
    readonly isEmpty?: boolean;

    constructor(data?: IByteReadOnlySpan) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).length = _data["Length"];
            (<any>this).isEmpty = _data["IsEmpty"];
        }
    }

    static fromJS(data: any): ByteReadOnlySpan {
        data = typeof data === 'object' ? data : {};
        let result = new ByteReadOnlySpan();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Length"] = this.length;
        data["IsEmpty"] = this.isEmpty;
        return data;
    }
}

export interface IByteReadOnlySpan {
    length?: number;
    isEmpty?: boolean;
}

export class Cad implements ICad {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: ICad) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): Cad {
        data = typeof data === 'object' ? data : {};
        let result = new Cad();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface ICad {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export enum CallingConventions {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _32 = 32,
    _64 = 64,
}

export class CancellationToken implements ICancellationToken {
    readonly isCancellationRequested?: boolean;
    readonly canBeCanceled?: boolean;
    waitHandle?: WaitHandle;

    constructor(data?: ICancellationToken) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isCancellationRequested = _data["IsCancellationRequested"];
            (<any>this).canBeCanceled = _data["CanBeCanceled"];
            this.waitHandle = _data["WaitHandle"] ? WaitHandle.fromJS(_data["WaitHandle"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CancellationToken {
        data = typeof data === 'object' ? data : {};
        let result = new CancellationToken();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["IsCancellationRequested"] = this.isCancellationRequested;
        data["CanBeCanceled"] = this.canBeCanceled;
        data["WaitHandle"] = this.waitHandle ? this.waitHandle.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICancellationToken {
    isCancellationRequested?: boolean;
    canBeCanceled?: boolean;
    waitHandle?: WaitHandle;
}

export class Category implements ICategory {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    name?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isPublished?: boolean;
    mediaId?: number | undefined;
    media?: Media;
    parentId?: number | undefined;
    parent?: Category;
    yatirimimId?: number | undefined;
    readonly children?: Category[] | undefined;
    readonly productCategories?: ProductCategory[] | undefined;

    constructor(data?: ICategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.createdOn = _data["CreatedOn"] ? moment(_data["CreatedOn"].toString()) : <any>undefined;
            this.createdById = _data["CreatedById"];
            this.createdBy = _data["CreatedBy"] ? User.fromJS(_data["CreatedBy"]) : <any>undefined;
            this.updatedOn = _data["UpdatedOn"] ? moment(_data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedById = _data["UpdatedById"];
            this.updatedBy = _data["UpdatedBy"] ? User.fromJS(_data["UpdatedBy"]) : <any>undefined;
            this.deletedOn = _data["DeletedOn"] ? moment(_data["DeletedOn"].toString()) : <any>undefined;
            this.deletedById = _data["DeletedById"];
            this.deletedBy = _data["DeletedBy"] ? User.fromJS(_data["DeletedBy"]) : <any>undefined;
            this.isDeleted = _data["IsDeleted"];
            this.name = _data["Name"];
            this.description = _data["Description"];
            this.displayOrder = _data["DisplayOrder"];
            this.isPublished = _data["IsPublished"];
            this.mediaId = _data["MediaId"];
            this.media = _data["Media"] ? Media.fromJS(_data["Media"]) : <any>undefined;
            this.parentId = _data["ParentId"];
            this.parent = _data["Parent"] ? Category.fromJS(_data["Parent"]) : <any>undefined;
            this.yatirimimId = _data["YatirimimId"];
            if (Array.isArray(_data["Children"])) {
                (<any>this).children = [] as any;
                for (let item of _data["Children"])
                    (<any>this).children!.push(Category.fromJS(item));
            }
            if (Array.isArray(_data["ProductCategories"])) {
                (<any>this).productCategories = [] as any;
                for (let item of _data["ProductCategories"])
                    (<any>this).productCategories!.push(ProductCategory.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Category {
        data = typeof data === 'object' ? data : {};
        let result = new Category();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedById"] = this.createdById;
        data["CreatedBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["DeletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        data["DeletedById"] = this.deletedById;
        data["DeletedBy"] = this.deletedBy ? this.deletedBy.toJSON() : <any>undefined;
        data["IsDeleted"] = this.isDeleted;
        data["Name"] = this.name;
        data["Description"] = this.description;
        data["DisplayOrder"] = this.displayOrder;
        data["IsPublished"] = this.isPublished;
        data["MediaId"] = this.mediaId;
        data["Media"] = this.media ? this.media.toJSON() : <any>undefined;
        data["ParentId"] = this.parentId;
        data["Parent"] = this.parent ? this.parent.toJSON() : <any>undefined;
        data["YatirimimId"] = this.yatirimimId;
        if (Array.isArray(this.children)) {
            data["Children"] = [];
            for (let item of this.children)
                data["Children"].push(item.toJSON());
        }
        if (Array.isArray(this.productCategories)) {
            data["ProductCategories"] = [];
            for (let item of this.productCategories)
                data["ProductCategories"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICategory {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    name?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isPublished?: boolean;
    mediaId?: number | undefined;
    media?: Media;
    parentId?: number | undefined;
    parent?: Category;
    yatirimimId?: number | undefined;
    children?: Category[] | undefined;
    productCategories?: ProductCategory[] | undefined;
}

export class ChannelType implements IChannelType {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;

    constructor(data?: IChannelType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.createdOn = _data["CreatedOn"] ? moment(_data["CreatedOn"].toString()) : <any>undefined;
            this.createdById = _data["CreatedById"];
            this.createdBy = _data["CreatedBy"] ? User.fromJS(_data["CreatedBy"]) : <any>undefined;
            this.updatedOn = _data["UpdatedOn"] ? moment(_data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedById = _data["UpdatedById"];
            this.updatedBy = _data["UpdatedBy"] ? User.fromJS(_data["UpdatedBy"]) : <any>undefined;
            this.deletedOn = _data["DeletedOn"] ? moment(_data["DeletedOn"].toString()) : <any>undefined;
            this.deletedById = _data["DeletedById"];
            this.deletedBy = _data["DeletedBy"] ? User.fromJS(_data["DeletedBy"]) : <any>undefined;
            this.isDeleted = _data["IsDeleted"];
            this.code = _data["Code"];
            this.description = _data["Description"];
            this.displayOrder = _data["DisplayOrder"];
            this.isActive = _data["IsActive"];
        }
    }

    static fromJS(data: any): ChannelType {
        data = typeof data === 'object' ? data : {};
        let result = new ChannelType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedById"] = this.createdById;
        data["CreatedBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["DeletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        data["DeletedById"] = this.deletedById;
        data["DeletedBy"] = this.deletedBy ? this.deletedBy.toJSON() : <any>undefined;
        data["IsDeleted"] = this.isDeleted;
        data["Code"] = this.code;
        data["Description"] = this.description;
        data["DisplayOrder"] = this.displayOrder;
        data["IsActive"] = this.isActive;
        return data;
    }
}

export interface IChannelType {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;
}

export enum CheckBoxHiddenInputRenderMode {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export class Chf implements IChf {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IChf) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): Chf {
        data = typeof data === 'object' ? data : {};
        let result = new Chf();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IChf {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class Claim implements IClaim {
    readonly issuer?: string | undefined;
    readonly originalIssuer?: string | undefined;
    readonly properties?: { [key: string]: string; } | undefined;
    subject?: ClaimsIdentity;
    readonly type?: string | undefined;
    readonly value?: string | undefined;
    readonly valueType?: string | undefined;

    constructor(data?: IClaim) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).issuer = _data["Issuer"];
            (<any>this).originalIssuer = _data["OriginalIssuer"];
            if (_data["Properties"]) {
                (<any>this).properties = {} as any;
                for (let key in _data["Properties"]) {
                    if (_data["Properties"].hasOwnProperty(key))
                        (<any>(<any>this).properties)![key] = _data["Properties"][key];
                }
            }
            this.subject = _data["Subject"] ? ClaimsIdentity.fromJS(_data["Subject"]) : <any>undefined;
            (<any>this).type = _data["Type"];
            (<any>this).value = _data["Value"];
            (<any>this).valueType = _data["ValueType"];
        }
    }

    static fromJS(data: any): Claim {
        data = typeof data === 'object' ? data : {};
        let result = new Claim();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Issuer"] = this.issuer;
        data["OriginalIssuer"] = this.originalIssuer;
        if (this.properties) {
            data["Properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["Properties"])[key] = this.properties[key];
            }
        }
        data["Subject"] = this.subject ? this.subject.toJSON() : <any>undefined;
        data["Type"] = this.type;
        data["Value"] = this.value;
        data["ValueType"] = this.valueType;
        return data;
    }
}

export interface IClaim {
    issuer?: string | undefined;
    originalIssuer?: string | undefined;
    properties?: { [key: string]: string; } | undefined;
    subject?: ClaimsIdentity;
    type?: string | undefined;
    value?: string | undefined;
    valueType?: string | undefined;
}

export class ClaimsIdentity implements IClaimsIdentity {
    readonly authenticationType?: string | undefined;
    readonly isAuthenticated?: boolean;
    actor?: ClaimsIdentity;
    bootstrapContext?: any | undefined;
    readonly claims?: Claim[] | undefined;
    label?: string | undefined;
    readonly name?: string | undefined;
    readonly nameClaimType?: string | undefined;
    readonly roleClaimType?: string | undefined;

    constructor(data?: IClaimsIdentity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).authenticationType = _data["AuthenticationType"];
            (<any>this).isAuthenticated = _data["IsAuthenticated"];
            this.actor = _data["Actor"] ? ClaimsIdentity.fromJS(_data["Actor"]) : <any>undefined;
            this.bootstrapContext = _data["BootstrapContext"];
            if (Array.isArray(_data["Claims"])) {
                (<any>this).claims = [] as any;
                for (let item of _data["Claims"])
                    (<any>this).claims!.push(Claim.fromJS(item));
            }
            this.label = _data["Label"];
            (<any>this).name = _data["Name"];
            (<any>this).nameClaimType = _data["NameClaimType"];
            (<any>this).roleClaimType = _data["RoleClaimType"];
        }
    }

    static fromJS(data: any): ClaimsIdentity {
        data = typeof data === 'object' ? data : {};
        let result = new ClaimsIdentity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["AuthenticationType"] = this.authenticationType;
        data["IsAuthenticated"] = this.isAuthenticated;
        data["Actor"] = this.actor ? this.actor.toJSON() : <any>undefined;
        data["BootstrapContext"] = this.bootstrapContext;
        if (Array.isArray(this.claims)) {
            data["Claims"] = [];
            for (let item of this.claims)
                data["Claims"].push(item.toJSON());
        }
        data["Label"] = this.label;
        data["Name"] = this.name;
        data["NameClaimType"] = this.nameClaimType;
        data["RoleClaimType"] = this.roleClaimType;
        return data;
    }
}

export interface IClaimsIdentity {
    authenticationType?: string | undefined;
    isAuthenticated?: boolean;
    actor?: ClaimsIdentity;
    bootstrapContext?: any | undefined;
    claims?: Claim[] | undefined;
    label?: string | undefined;
    name?: string | undefined;
    nameClaimType?: string | undefined;
    roleClaimType?: string | undefined;
}

export class ClaimsPrincipal implements IClaimsPrincipal {
    readonly claims?: Claim[] | undefined;
    readonly identities?: ClaimsIdentity[] | undefined;
    identity?: IIdentity;

    constructor(data?: IClaimsPrincipal) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["Claims"])) {
                (<any>this).claims = [] as any;
                for (let item of _data["Claims"])
                    (<any>this).claims!.push(Claim.fromJS(item));
            }
            if (Array.isArray(_data["Identities"])) {
                (<any>this).identities = [] as any;
                for (let item of _data["Identities"])
                    (<any>this).identities!.push(ClaimsIdentity.fromJS(item));
            }
            this.identity = _data["Identity"] ? IIdentity.fromJS(_data["Identity"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ClaimsPrincipal {
        data = typeof data === 'object' ? data : {};
        let result = new ClaimsPrincipal();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.claims)) {
            data["Claims"] = [];
            for (let item of this.claims)
                data["Claims"].push(item.toJSON());
        }
        if (Array.isArray(this.identities)) {
            data["Identities"] = [];
            for (let item of this.identities)
                data["Identities"].push(item.toJSON());
        }
        data["Identity"] = this.identity ? this.identity.toJSON() : <any>undefined;
        return data;
    }
}

export interface IClaimsPrincipal {
    claims?: Claim[] | undefined;
    identities?: ClaimsIdentity[] | undefined;
    identity?: IIdentity;
}

export class Commission implements ICommission {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    name?: string | undefined;
    symbolId?: number;
    symbol?: Symbol;
    commissionTypeId?: number;
    commissionType?: CommissionType;
    commissionRate?: number;
    commissionValue?: number;

    constructor(data?: ICommission) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.createdOn = _data["CreatedOn"] ? moment(_data["CreatedOn"].toString()) : <any>undefined;
            this.createdById = _data["CreatedById"];
            this.createdBy = _data["CreatedBy"] ? User.fromJS(_data["CreatedBy"]) : <any>undefined;
            this.updatedOn = _data["UpdatedOn"] ? moment(_data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedById = _data["UpdatedById"];
            this.updatedBy = _data["UpdatedBy"] ? User.fromJS(_data["UpdatedBy"]) : <any>undefined;
            this.deletedOn = _data["DeletedOn"] ? moment(_data["DeletedOn"].toString()) : <any>undefined;
            this.deletedById = _data["DeletedById"];
            this.deletedBy = _data["DeletedBy"] ? User.fromJS(_data["DeletedBy"]) : <any>undefined;
            this.isDeleted = _data["IsDeleted"];
            this.name = _data["Name"];
            this.symbolId = _data["SymbolId"];
            this.symbol = _data["Symbol"] ? Symbol.fromJS(_data["Symbol"]) : <any>undefined;
            this.commissionTypeId = _data["CommissionTypeId"];
            this.commissionType = _data["CommissionType"] ? CommissionType.fromJS(_data["CommissionType"]) : <any>undefined;
            this.commissionRate = _data["CommissionRate"];
            this.commissionValue = _data["CommissionValue"];
        }
    }

    static fromJS(data: any): Commission {
        data = typeof data === 'object' ? data : {};
        let result = new Commission();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedById"] = this.createdById;
        data["CreatedBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["DeletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        data["DeletedById"] = this.deletedById;
        data["DeletedBy"] = this.deletedBy ? this.deletedBy.toJSON() : <any>undefined;
        data["IsDeleted"] = this.isDeleted;
        data["Name"] = this.name;
        data["SymbolId"] = this.symbolId;
        data["Symbol"] = this.symbol ? this.symbol.toJSON() : <any>undefined;
        data["CommissionTypeId"] = this.commissionTypeId;
        data["CommissionType"] = this.commissionType ? this.commissionType.toJSON() : <any>undefined;
        data["CommissionRate"] = this.commissionRate;
        data["CommissionValue"] = this.commissionValue;
        return data;
    }
}

export interface ICommission {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    name?: string | undefined;
    symbolId?: number;
    symbol?: Symbol;
    commissionTypeId?: number;
    commissionType?: CommissionType;
    commissionRate?: number;
    commissionValue?: number;
}

export class CommissionType implements ICommissionType {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;

    constructor(data?: ICommissionType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.createdOn = _data["CreatedOn"] ? moment(_data["CreatedOn"].toString()) : <any>undefined;
            this.createdById = _data["CreatedById"];
            this.createdBy = _data["CreatedBy"] ? User.fromJS(_data["CreatedBy"]) : <any>undefined;
            this.updatedOn = _data["UpdatedOn"] ? moment(_data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedById = _data["UpdatedById"];
            this.updatedBy = _data["UpdatedBy"] ? User.fromJS(_data["UpdatedBy"]) : <any>undefined;
            this.deletedOn = _data["DeletedOn"] ? moment(_data["DeletedOn"].toString()) : <any>undefined;
            this.deletedById = _data["DeletedById"];
            this.deletedBy = _data["DeletedBy"] ? User.fromJS(_data["DeletedBy"]) : <any>undefined;
            this.isDeleted = _data["IsDeleted"];
            this.code = _data["Code"];
            this.description = _data["Description"];
            this.displayOrder = _data["DisplayOrder"];
            this.isActive = _data["IsActive"];
        }
    }

    static fromJS(data: any): CommissionType {
        data = typeof data === 'object' ? data : {};
        let result = new CommissionType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedById"] = this.createdById;
        data["CreatedBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["DeletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        data["DeletedById"] = this.deletedById;
        data["DeletedBy"] = this.deletedBy ? this.deletedBy.toJSON() : <any>undefined;
        data["IsDeleted"] = this.isDeleted;
        data["Code"] = this.code;
        data["Description"] = this.description;
        data["DisplayOrder"] = this.displayOrder;
        data["IsActive"] = this.isActive;
        return data;
    }
}

export interface ICommissionType {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;
}

export class ConnectionInfo implements IConnectionInfo {
    id?: string | undefined;
    remoteIpAddress?: IPAddress;
    remotePort?: number;
    localIpAddress?: IPAddress;
    localPort?: number;
    clientCertificate?: X509Certificate2;

    constructor(data?: IConnectionInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.remoteIpAddress = _data["RemoteIpAddress"] ? IPAddress.fromJS(_data["RemoteIpAddress"]) : <any>undefined;
            this.remotePort = _data["RemotePort"];
            this.localIpAddress = _data["LocalIpAddress"] ? IPAddress.fromJS(_data["LocalIpAddress"]) : <any>undefined;
            this.localPort = _data["LocalPort"];
            this.clientCertificate = _data["ClientCertificate"] ? X509Certificate2.fromJS(_data["ClientCertificate"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ConnectionInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ConnectionInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["RemoteIpAddress"] = this.remoteIpAddress ? this.remoteIpAddress.toJSON() : <any>undefined;
        data["RemotePort"] = this.remotePort;
        data["LocalIpAddress"] = this.localIpAddress ? this.localIpAddress.toJSON() : <any>undefined;
        data["LocalPort"] = this.localPort;
        data["ClientCertificate"] = this.clientCertificate ? this.clientCertificate.toJSON() : <any>undefined;
        return data;
    }
}

export interface IConnectionInfo {
    id?: string | undefined;
    remoteIpAddress?: IPAddress;
    remotePort?: number;
    localIpAddress?: IPAddress;
    localPort?: number;
    clientCertificate?: X509Certificate2;
}

export class ConstructorInfo implements IConstructorInfo {
    readonly name?: string | undefined;
    declaringType?: Type;
    reflectedType?: Type;
    module?: Module;
    readonly customAttributes?: CustomAttributeData[] | undefined;
    readonly isCollectible?: boolean;
    readonly metadataToken?: number;
    attributes?: MethodAttributes;
    methodImplementationFlags?: MethodImplAttributes;
    callingConvention?: CallingConventions;
    readonly isAbstract?: boolean;
    readonly isConstructor?: boolean;
    readonly isFinal?: boolean;
    readonly isHideBySig?: boolean;
    readonly isSpecialName?: boolean;
    readonly isStatic?: boolean;
    readonly isVirtual?: boolean;
    readonly isAssembly?: boolean;
    readonly isFamily?: boolean;
    readonly isFamilyAndAssembly?: boolean;
    readonly isFamilyOrAssembly?: boolean;
    readonly isPrivate?: boolean;
    readonly isPublic?: boolean;
    readonly isConstructedGenericMethod?: boolean;
    readonly isGenericMethod?: boolean;
    readonly isGenericMethodDefinition?: boolean;
    readonly containsGenericParameters?: boolean;
    methodHandle?: RuntimeMethodHandle;
    readonly isSecurityCritical?: boolean;
    readonly isSecuritySafeCritical?: boolean;
    readonly isSecurityTransparent?: boolean;
    memberType?: MemberTypes;

    constructor(data?: IConstructorInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).name = _data["Name"];
            this.declaringType = _data["DeclaringType"] ? Type.fromJS(_data["DeclaringType"]) : <any>undefined;
            this.reflectedType = _data["ReflectedType"] ? Type.fromJS(_data["ReflectedType"]) : <any>undefined;
            this.module = _data["Module"] ? Module.fromJS(_data["Module"]) : <any>undefined;
            if (Array.isArray(_data["CustomAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["CustomAttributes"])
                    (<any>this).customAttributes!.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).isCollectible = _data["IsCollectible"];
            (<any>this).metadataToken = _data["MetadataToken"];
            this.attributes = _data["Attributes"];
            this.methodImplementationFlags = _data["MethodImplementationFlags"];
            this.callingConvention = _data["CallingConvention"];
            (<any>this).isAbstract = _data["IsAbstract"];
            (<any>this).isConstructor = _data["IsConstructor"];
            (<any>this).isFinal = _data["IsFinal"];
            (<any>this).isHideBySig = _data["IsHideBySig"];
            (<any>this).isSpecialName = _data["IsSpecialName"];
            (<any>this).isStatic = _data["IsStatic"];
            (<any>this).isVirtual = _data["IsVirtual"];
            (<any>this).isAssembly = _data["IsAssembly"];
            (<any>this).isFamily = _data["IsFamily"];
            (<any>this).isFamilyAndAssembly = _data["IsFamilyAndAssembly"];
            (<any>this).isFamilyOrAssembly = _data["IsFamilyOrAssembly"];
            (<any>this).isPrivate = _data["IsPrivate"];
            (<any>this).isPublic = _data["IsPublic"];
            (<any>this).isConstructedGenericMethod = _data["IsConstructedGenericMethod"];
            (<any>this).isGenericMethod = _data["IsGenericMethod"];
            (<any>this).isGenericMethodDefinition = _data["IsGenericMethodDefinition"];
            (<any>this).containsGenericParameters = _data["ContainsGenericParameters"];
            this.methodHandle = _data["MethodHandle"] ? RuntimeMethodHandle.fromJS(_data["MethodHandle"]) : <any>undefined;
            (<any>this).isSecurityCritical = _data["IsSecurityCritical"];
            (<any>this).isSecuritySafeCritical = _data["IsSecuritySafeCritical"];
            (<any>this).isSecurityTransparent = _data["IsSecurityTransparent"];
            this.memberType = _data["MemberType"];
        }
    }

    static fromJS(data: any): ConstructorInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ConstructorInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Name"] = this.name;
        data["DeclaringType"] = this.declaringType ? this.declaringType.toJSON() : <any>undefined;
        data["ReflectedType"] = this.reflectedType ? this.reflectedType.toJSON() : <any>undefined;
        data["Module"] = this.module ? this.module.toJSON() : <any>undefined;
        if (Array.isArray(this.customAttributes)) {
            data["CustomAttributes"] = [];
            for (let item of this.customAttributes)
                data["CustomAttributes"].push(item.toJSON());
        }
        data["IsCollectible"] = this.isCollectible;
        data["MetadataToken"] = this.metadataToken;
        data["Attributes"] = this.attributes;
        data["MethodImplementationFlags"] = this.methodImplementationFlags;
        data["CallingConvention"] = this.callingConvention;
        data["IsAbstract"] = this.isAbstract;
        data["IsConstructor"] = this.isConstructor;
        data["IsFinal"] = this.isFinal;
        data["IsHideBySig"] = this.isHideBySig;
        data["IsSpecialName"] = this.isSpecialName;
        data["IsStatic"] = this.isStatic;
        data["IsVirtual"] = this.isVirtual;
        data["IsAssembly"] = this.isAssembly;
        data["IsFamily"] = this.isFamily;
        data["IsFamilyAndAssembly"] = this.isFamilyAndAssembly;
        data["IsFamilyOrAssembly"] = this.isFamilyOrAssembly;
        data["IsPrivate"] = this.isPrivate;
        data["IsPublic"] = this.isPublic;
        data["IsConstructedGenericMethod"] = this.isConstructedGenericMethod;
        data["IsGenericMethod"] = this.isGenericMethod;
        data["IsGenericMethodDefinition"] = this.isGenericMethodDefinition;
        data["ContainsGenericParameters"] = this.containsGenericParameters;
        data["MethodHandle"] = this.methodHandle ? this.methodHandle.toJSON() : <any>undefined;
        data["IsSecurityCritical"] = this.isSecurityCritical;
        data["IsSecuritySafeCritical"] = this.isSecuritySafeCritical;
        data["IsSecurityTransparent"] = this.isSecurityTransparent;
        data["MemberType"] = this.memberType;
        return data;
    }
}

export interface IConstructorInfo {
    name?: string | undefined;
    declaringType?: Type;
    reflectedType?: Type;
    module?: Module;
    customAttributes?: CustomAttributeData[] | undefined;
    isCollectible?: boolean;
    metadataToken?: number;
    attributes?: MethodAttributes;
    methodImplementationFlags?: MethodImplAttributes;
    callingConvention?: CallingConventions;
    isAbstract?: boolean;
    isConstructor?: boolean;
    isFinal?: boolean;
    isHideBySig?: boolean;
    isSpecialName?: boolean;
    isStatic?: boolean;
    isVirtual?: boolean;
    isAssembly?: boolean;
    isFamily?: boolean;
    isFamilyAndAssembly?: boolean;
    isFamilyOrAssembly?: boolean;
    isPrivate?: boolean;
    isPublic?: boolean;
    isConstructedGenericMethod?: boolean;
    isGenericMethod?: boolean;
    isGenericMethodDefinition?: boolean;
    containsGenericParameters?: boolean;
    methodHandle?: RuntimeMethodHandle;
    isSecurityCritical?: boolean;
    isSecuritySafeCritical?: boolean;
    isSecurityTransparent?: boolean;
    memberType?: MemberTypes;
}

export class ContactType implements IContactType {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;

    constructor(data?: IContactType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.createdOn = _data["CreatedOn"] ? moment(_data["CreatedOn"].toString()) : <any>undefined;
            this.createdById = _data["CreatedById"];
            this.createdBy = _data["CreatedBy"] ? User.fromJS(_data["CreatedBy"]) : <any>undefined;
            this.updatedOn = _data["UpdatedOn"] ? moment(_data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedById = _data["UpdatedById"];
            this.updatedBy = _data["UpdatedBy"] ? User.fromJS(_data["UpdatedBy"]) : <any>undefined;
            this.deletedOn = _data["DeletedOn"] ? moment(_data["DeletedOn"].toString()) : <any>undefined;
            this.deletedById = _data["DeletedById"];
            this.deletedBy = _data["DeletedBy"] ? User.fromJS(_data["DeletedBy"]) : <any>undefined;
            this.isDeleted = _data["IsDeleted"];
            this.code = _data["Code"];
            this.description = _data["Description"];
            this.displayOrder = _data["DisplayOrder"];
            this.isActive = _data["IsActive"];
        }
    }

    static fromJS(data: any): ContactType {
        data = typeof data === 'object' ? data : {};
        let result = new ContactType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedById"] = this.createdById;
        data["CreatedBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["DeletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        data["DeletedById"] = this.deletedById;
        data["DeletedBy"] = this.deletedBy ? this.deletedBy.toJSON() : <any>undefined;
        data["IsDeleted"] = this.isDeleted;
        data["Code"] = this.code;
        data["Description"] = this.description;
        data["DisplayOrder"] = this.displayOrder;
        data["IsActive"] = this.isActive;
        return data;
    }
}

export interface IContactType {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;
}

export class Corporate implements ICorporate {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    name!: string;
    categoryId?: number;
    category?: CorporateCategory;
    phoneNumber?: string | undefined;
    email?: string | undefined;
    logoId?: number | undefined;
    logo?: Media;
    taxNo?: string | undefined;
    taxOffice?: string | undefined;
    description?: string | undefined;
    isActive?: boolean;
    customer?: Customer;

    constructor(data?: ICorporate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.isActive = true;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.createdOn = _data["CreatedOn"] ? moment(_data["CreatedOn"].toString()) : <any>undefined;
            this.createdById = _data["CreatedById"];
            this.createdBy = _data["CreatedBy"] ? User.fromJS(_data["CreatedBy"]) : <any>undefined;
            this.updatedOn = _data["UpdatedOn"] ? moment(_data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedById = _data["UpdatedById"];
            this.updatedBy = _data["UpdatedBy"] ? User.fromJS(_data["UpdatedBy"]) : <any>undefined;
            this.deletedOn = _data["DeletedOn"] ? moment(_data["DeletedOn"].toString()) : <any>undefined;
            this.deletedById = _data["DeletedById"];
            this.deletedBy = _data["DeletedBy"] ? User.fromJS(_data["DeletedBy"]) : <any>undefined;
            this.isDeleted = _data["IsDeleted"];
            this.name = _data["Name"];
            this.categoryId = _data["CategoryId"];
            this.category = _data["Category"] ? CorporateCategory.fromJS(_data["Category"]) : <any>undefined;
            this.phoneNumber = _data["PhoneNumber"];
            this.email = _data["Email"];
            this.logoId = _data["LogoId"];
            this.logo = _data["Logo"] ? Media.fromJS(_data["Logo"]) : <any>undefined;
            this.taxNo = _data["TaxNo"];
            this.taxOffice = _data["TaxOffice"];
            this.description = _data["Description"];
            this.isActive = _data["IsActive"] !== undefined ? _data["IsActive"] : true;
            this.customer = _data["Customer"] ? Customer.fromJS(_data["Customer"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Corporate {
        data = typeof data === 'object' ? data : {};
        let result = new Corporate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedById"] = this.createdById;
        data["CreatedBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["DeletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        data["DeletedById"] = this.deletedById;
        data["DeletedBy"] = this.deletedBy ? this.deletedBy.toJSON() : <any>undefined;
        data["IsDeleted"] = this.isDeleted;
        data["Name"] = this.name;
        data["CategoryId"] = this.categoryId;
        data["Category"] = this.category ? this.category.toJSON() : <any>undefined;
        data["PhoneNumber"] = this.phoneNumber;
        data["Email"] = this.email;
        data["LogoId"] = this.logoId;
        data["Logo"] = this.logo ? this.logo.toJSON() : <any>undefined;
        data["TaxNo"] = this.taxNo;
        data["TaxOffice"] = this.taxOffice;
        data["Description"] = this.description;
        data["IsActive"] = this.isActive;
        data["Customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICorporate {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    name: string;
    categoryId?: number;
    category?: CorporateCategory;
    phoneNumber?: string | undefined;
    email?: string | undefined;
    logoId?: number | undefined;
    logo?: Media;
    taxNo?: string | undefined;
    taxOffice?: string | undefined;
    description?: string | undefined;
    isActive?: boolean;
    customer?: Customer;
}

export class CorporateCategory implements ICorporateCategory {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;

    constructor(data?: ICorporateCategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.createdOn = _data["CreatedOn"] ? moment(_data["CreatedOn"].toString()) : <any>undefined;
            this.createdById = _data["CreatedById"];
            this.createdBy = _data["CreatedBy"] ? User.fromJS(_data["CreatedBy"]) : <any>undefined;
            this.updatedOn = _data["UpdatedOn"] ? moment(_data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedById = _data["UpdatedById"];
            this.updatedBy = _data["UpdatedBy"] ? User.fromJS(_data["UpdatedBy"]) : <any>undefined;
            this.deletedOn = _data["DeletedOn"] ? moment(_data["DeletedOn"].toString()) : <any>undefined;
            this.deletedById = _data["DeletedById"];
            this.deletedBy = _data["DeletedBy"] ? User.fromJS(_data["DeletedBy"]) : <any>undefined;
            this.isDeleted = _data["IsDeleted"];
            this.code = _data["Code"];
            this.description = _data["Description"];
            this.displayOrder = _data["DisplayOrder"];
            this.isActive = _data["IsActive"];
        }
    }

    static fromJS(data: any): CorporateCategory {
        data = typeof data === 'object' ? data : {};
        let result = new CorporateCategory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedById"] = this.createdById;
        data["CreatedBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["DeletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        data["DeletedById"] = this.deletedById;
        data["DeletedBy"] = this.deletedBy ? this.deletedBy.toJSON() : <any>undefined;
        data["IsDeleted"] = this.isDeleted;
        data["Code"] = this.code;
        data["Description"] = this.description;
        data["DisplayOrder"] = this.displayOrder;
        data["IsActive"] = this.isActive;
        return data;
    }
}

export interface ICorporateCategory {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;
}

export class CorporateCategoryModel implements ICorporateCategoryModel {
    id?: number;
    code?: string | undefined;
    description?: string | undefined;

    constructor(data?: ICorporateCategoryModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.code = _data["Code"];
            this.description = _data["Description"];
        }
    }

    static fromJS(data: any): CorporateCategoryModel {
        data = typeof data === 'object' ? data : {};
        let result = new CorporateCategoryModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Code"] = this.code;
        data["Description"] = this.description;
        return data;
    }
}

export interface ICorporateCategoryModel {
    id?: number;
    code?: string | undefined;
    description?: string | undefined;
}

export class CorporateModel implements ICorporateModel {
    id?: number;
    name?: string | undefined;
    categoryId?: number;
    category?: CorporateCategoryModel;
    customer?: CustomerModel;

    constructor(data?: ICorporateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.name = _data["Name"];
            this.categoryId = _data["CategoryId"];
            this.category = _data["Category"] ? CorporateCategoryModel.fromJS(_data["Category"]) : <any>undefined;
            this.customer = _data["Customer"] ? CustomerModel.fromJS(_data["Customer"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CorporateModel {
        data = typeof data === 'object' ? data : {};
        let result = new CorporateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Name"] = this.name;
        data["CategoryId"] = this.categoryId;
        data["Category"] = this.category ? this.category.toJSON() : <any>undefined;
        data["Customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICorporateModel {
    id?: number;
    name?: string | undefined;
    categoryId?: number;
    category?: CorporateCategoryModel;
    customer?: CustomerModel;
}

export class Country implements ICountry {
    id?: string | undefined;
    code!: string;
    name!: string;
    nationality?: string | undefined;

    constructor(data?: ICountry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.code = _data["Code"];
            this.name = _data["Name"];
            this.nationality = _data["Nationality"];
        }
    }

    static fromJS(data: any): Country {
        data = typeof data === 'object' ? data : {};
        let result = new Country();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Code"] = this.code;
        data["Name"] = this.name;
        data["Nationality"] = this.nationality;
        return data;
    }
}

export interface ICountry {
    id?: string | undefined;
    code: string;
    name: string;
    nationality?: string | undefined;
}

export class CountryModel implements ICountryModel {

    constructor(data?: ICountryModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): CountryModel {
        data = typeof data === 'object' ? data : {};
        let result = new CountryModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface ICountryModel {
}

export class Coupon implements ICoupon {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    customerId?: number;
    customer?: Customer;
    code?: string | undefined;
    createDate?: moment.Moment;
    expireDate?: moment.Moment;

    constructor(data?: ICoupon) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.createdOn = _data["CreatedOn"] ? moment(_data["CreatedOn"].toString()) : <any>undefined;
            this.createdById = _data["CreatedById"];
            this.createdBy = _data["CreatedBy"] ? User.fromJS(_data["CreatedBy"]) : <any>undefined;
            this.updatedOn = _data["UpdatedOn"] ? moment(_data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedById = _data["UpdatedById"];
            this.updatedBy = _data["UpdatedBy"] ? User.fromJS(_data["UpdatedBy"]) : <any>undefined;
            this.deletedOn = _data["DeletedOn"] ? moment(_data["DeletedOn"].toString()) : <any>undefined;
            this.deletedById = _data["DeletedById"];
            this.deletedBy = _data["DeletedBy"] ? User.fromJS(_data["DeletedBy"]) : <any>undefined;
            this.isDeleted = _data["IsDeleted"];
            this.customerId = _data["CustomerId"];
            this.customer = _data["Customer"] ? Customer.fromJS(_data["Customer"]) : <any>undefined;
            this.code = _data["Code"];
            this.createDate = _data["CreateDate"] ? moment(_data["CreateDate"].toString()) : <any>undefined;
            this.expireDate = _data["ExpireDate"] ? moment(_data["ExpireDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Coupon {
        data = typeof data === 'object' ? data : {};
        let result = new Coupon();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedById"] = this.createdById;
        data["CreatedBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["DeletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        data["DeletedById"] = this.deletedById;
        data["DeletedBy"] = this.deletedBy ? this.deletedBy.toJSON() : <any>undefined;
        data["IsDeleted"] = this.isDeleted;
        data["CustomerId"] = this.customerId;
        data["Customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        data["Code"] = this.code;
        data["CreateDate"] = this.createDate ? this.createDate.toISOString() : <any>undefined;
        data["ExpireDate"] = this.expireDate ? this.expireDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface ICoupon {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    customerId?: number;
    customer?: Customer;
    code?: string | undefined;
    createDate?: moment.Moment;
    expireDate?: moment.Moment;
}

export class CustomAttributeData implements ICustomAttributeData {
    attributeType?: Type;
    constructor_?: ConstructorInfo;
    readonly constructorArguments?: CustomAttributeTypedArgument[] | undefined;
    readonly namedArguments?: CustomAttributeNamedArgument[] | undefined;

    constructor(data?: ICustomAttributeData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.attributeType = _data["AttributeType"] ? Type.fromJS(_data["AttributeType"]) : <any>undefined;
            this.constructor_ = _data["Constructor"] ? ConstructorInfo.fromJS(_data["Constructor"]) : <any>undefined;
            if (Array.isArray(_data["ConstructorArguments"])) {
                (<any>this).constructorArguments = [] as any;
                for (let item of _data["ConstructorArguments"])
                    (<any>this).constructorArguments!.push(CustomAttributeTypedArgument.fromJS(item));
            }
            if (Array.isArray(_data["NamedArguments"])) {
                (<any>this).namedArguments = [] as any;
                for (let item of _data["NamedArguments"])
                    (<any>this).namedArguments!.push(CustomAttributeNamedArgument.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CustomAttributeData {
        data = typeof data === 'object' ? data : {};
        let result = new CustomAttributeData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["AttributeType"] = this.attributeType ? this.attributeType.toJSON() : <any>undefined;
        data["Constructor"] = this.constructor_ ? this.constructor_.toJSON() : <any>undefined;
        if (Array.isArray(this.constructorArguments)) {
            data["ConstructorArguments"] = [];
            for (let item of this.constructorArguments)
                data["ConstructorArguments"].push(item.toJSON());
        }
        if (Array.isArray(this.namedArguments)) {
            data["NamedArguments"] = [];
            for (let item of this.namedArguments)
                data["NamedArguments"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICustomAttributeData {
    attributeType?: Type;
    constructor_?: ConstructorInfo;
    constructorArguments?: CustomAttributeTypedArgument[] | undefined;
    namedArguments?: CustomAttributeNamedArgument[] | undefined;
}

export class CustomAttributeNamedArgument implements ICustomAttributeNamedArgument {
    memberInfo?: MemberInfo;
    typedValue?: CustomAttributeTypedArgument;
    readonly memberName?: string | undefined;
    readonly isField?: boolean;

    constructor(data?: ICustomAttributeNamedArgument) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberInfo = _data["MemberInfo"] ? MemberInfo.fromJS(_data["MemberInfo"]) : <any>undefined;
            this.typedValue = _data["TypedValue"] ? CustomAttributeTypedArgument.fromJS(_data["TypedValue"]) : <any>undefined;
            (<any>this).memberName = _data["MemberName"];
            (<any>this).isField = _data["IsField"];
        }
    }

    static fromJS(data: any): CustomAttributeNamedArgument {
        data = typeof data === 'object' ? data : {};
        let result = new CustomAttributeNamedArgument();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["MemberInfo"] = this.memberInfo ? this.memberInfo.toJSON() : <any>undefined;
        data["TypedValue"] = this.typedValue ? this.typedValue.toJSON() : <any>undefined;
        data["MemberName"] = this.memberName;
        data["IsField"] = this.isField;
        return data;
    }
}

export interface ICustomAttributeNamedArgument {
    memberInfo?: MemberInfo;
    typedValue?: CustomAttributeTypedArgument;
    memberName?: string | undefined;
    isField?: boolean;
}

export class CustomAttributeTypedArgument implements ICustomAttributeTypedArgument {
    argumentType?: Type;
    readonly value?: any | undefined;

    constructor(data?: ICustomAttributeTypedArgument) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.argumentType = _data["ArgumentType"] ? Type.fromJS(_data["ArgumentType"]) : <any>undefined;
            (<any>this).value = _data["Value"];
        }
    }

    static fromJS(data: any): CustomAttributeTypedArgument {
        data = typeof data === 'object' ? data : {};
        let result = new CustomAttributeTypedArgument();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ArgumentType"] = this.argumentType ? this.argumentType.toJSON() : <any>undefined;
        data["Value"] = this.value;
        return data;
    }
}

export interface ICustomAttributeTypedArgument {
    argumentType?: Type;
    value?: any | undefined;
}

export class Customer implements ICustomer {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    customerType?: CustomerType;
    retail?: Retail;
    corporate?: Corporate;
    store?: Store;
    channelTypeId?: number | undefined;
    channelType?: ChannelType;
    groupId?: number | undefined;
    group?: Group;
    users?: User[] | undefined;
    assets?: Asset[] | undefined;
    bonuses?: Bonus[] | undefined;
    coupons?: Coupon[] | undefined;
    transactions?: Transaction[] | undefined;
    customerAddresses?: CustomerAddress[] | undefined;
    customerBankAccounts?: CustomerBankAccount[] | undefined;
    customerContacts?: CustomerContact[] | undefined;
    customerDocuments?: CustomerDocument[] | undefined;

    constructor(data?: ICustomer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.createdOn = _data["CreatedOn"] ? moment(_data["CreatedOn"].toString()) : <any>undefined;
            this.createdById = _data["CreatedById"];
            this.createdBy = _data["CreatedBy"] ? User.fromJS(_data["CreatedBy"]) : <any>undefined;
            this.updatedOn = _data["UpdatedOn"] ? moment(_data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedById = _data["UpdatedById"];
            this.updatedBy = _data["UpdatedBy"] ? User.fromJS(_data["UpdatedBy"]) : <any>undefined;
            this.deletedOn = _data["DeletedOn"] ? moment(_data["DeletedOn"].toString()) : <any>undefined;
            this.deletedById = _data["DeletedById"];
            this.deletedBy = _data["DeletedBy"] ? User.fromJS(_data["DeletedBy"]) : <any>undefined;
            this.isDeleted = _data["IsDeleted"];
            this.customerType = _data["CustomerType"];
            this.retail = _data["Retail"] ? Retail.fromJS(_data["Retail"]) : <any>undefined;
            this.corporate = _data["Corporate"] ? Corporate.fromJS(_data["Corporate"]) : <any>undefined;
            this.store = _data["Store"] ? Store.fromJS(_data["Store"]) : <any>undefined;
            this.channelTypeId = _data["ChannelTypeId"];
            this.channelType = _data["ChannelType"] ? ChannelType.fromJS(_data["ChannelType"]) : <any>undefined;
            this.groupId = _data["GroupId"];
            this.group = _data["Group"] ? Group.fromJS(_data["Group"]) : <any>undefined;
            if (Array.isArray(_data["Users"])) {
                this.users = [] as any;
                for (let item of _data["Users"])
                    this.users!.push(User.fromJS(item));
            }
            if (Array.isArray(_data["Assets"])) {
                this.assets = [] as any;
                for (let item of _data["Assets"])
                    this.assets!.push(Asset.fromJS(item));
            }
            if (Array.isArray(_data["Bonuses"])) {
                this.bonuses = [] as any;
                for (let item of _data["Bonuses"])
                    this.bonuses!.push(Bonus.fromJS(item));
            }
            if (Array.isArray(_data["Coupons"])) {
                this.coupons = [] as any;
                for (let item of _data["Coupons"])
                    this.coupons!.push(Coupon.fromJS(item));
            }
            if (Array.isArray(_data["Transactions"])) {
                this.transactions = [] as any;
                for (let item of _data["Transactions"])
                    this.transactions!.push(Transaction.fromJS(item));
            }
            if (Array.isArray(_data["CustomerAddresses"])) {
                this.customerAddresses = [] as any;
                for (let item of _data["CustomerAddresses"])
                    this.customerAddresses!.push(CustomerAddress.fromJS(item));
            }
            if (Array.isArray(_data["CustomerBankAccounts"])) {
                this.customerBankAccounts = [] as any;
                for (let item of _data["CustomerBankAccounts"])
                    this.customerBankAccounts!.push(CustomerBankAccount.fromJS(item));
            }
            if (Array.isArray(_data["CustomerContacts"])) {
                this.customerContacts = [] as any;
                for (let item of _data["CustomerContacts"])
                    this.customerContacts!.push(CustomerContact.fromJS(item));
            }
            if (Array.isArray(_data["CustomerDocuments"])) {
                this.customerDocuments = [] as any;
                for (let item of _data["CustomerDocuments"])
                    this.customerDocuments!.push(CustomerDocument.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Customer {
        data = typeof data === 'object' ? data : {};
        let result = new Customer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedById"] = this.createdById;
        data["CreatedBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["DeletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        data["DeletedById"] = this.deletedById;
        data["DeletedBy"] = this.deletedBy ? this.deletedBy.toJSON() : <any>undefined;
        data["IsDeleted"] = this.isDeleted;
        data["CustomerType"] = this.customerType;
        data["Retail"] = this.retail ? this.retail.toJSON() : <any>undefined;
        data["Corporate"] = this.corporate ? this.corporate.toJSON() : <any>undefined;
        data["Store"] = this.store ? this.store.toJSON() : <any>undefined;
        data["ChannelTypeId"] = this.channelTypeId;
        data["ChannelType"] = this.channelType ? this.channelType.toJSON() : <any>undefined;
        data["GroupId"] = this.groupId;
        data["Group"] = this.group ? this.group.toJSON() : <any>undefined;
        if (Array.isArray(this.users)) {
            data["Users"] = [];
            for (let item of this.users)
                data["Users"].push(item.toJSON());
        }
        if (Array.isArray(this.assets)) {
            data["Assets"] = [];
            for (let item of this.assets)
                data["Assets"].push(item.toJSON());
        }
        if (Array.isArray(this.bonuses)) {
            data["Bonuses"] = [];
            for (let item of this.bonuses)
                data["Bonuses"].push(item.toJSON());
        }
        if (Array.isArray(this.coupons)) {
            data["Coupons"] = [];
            for (let item of this.coupons)
                data["Coupons"].push(item.toJSON());
        }
        if (Array.isArray(this.transactions)) {
            data["Transactions"] = [];
            for (let item of this.transactions)
                data["Transactions"].push(item.toJSON());
        }
        if (Array.isArray(this.customerAddresses)) {
            data["CustomerAddresses"] = [];
            for (let item of this.customerAddresses)
                data["CustomerAddresses"].push(item.toJSON());
        }
        if (Array.isArray(this.customerBankAccounts)) {
            data["CustomerBankAccounts"] = [];
            for (let item of this.customerBankAccounts)
                data["CustomerBankAccounts"].push(item.toJSON());
        }
        if (Array.isArray(this.customerContacts)) {
            data["CustomerContacts"] = [];
            for (let item of this.customerContacts)
                data["CustomerContacts"].push(item.toJSON());
        }
        if (Array.isArray(this.customerDocuments)) {
            data["CustomerDocuments"] = [];
            for (let item of this.customerDocuments)
                data["CustomerDocuments"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICustomer {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    customerType?: CustomerType;
    retail?: Retail;
    corporate?: Corporate;
    store?: Store;
    channelTypeId?: number | undefined;
    channelType?: ChannelType;
    groupId?: number | undefined;
    group?: Group;
    users?: User[] | undefined;
    assets?: Asset[] | undefined;
    bonuses?: Bonus[] | undefined;
    coupons?: Coupon[] | undefined;
    transactions?: Transaction[] | undefined;
    customerAddresses?: CustomerAddress[] | undefined;
    customerBankAccounts?: CustomerBankAccount[] | undefined;
    customerContacts?: CustomerContact[] | undefined;
    customerDocuments?: CustomerDocument[] | undefined;
}

export class CustomerAddress implements ICustomerAddress {
    id?: number;
    customerId?: number;
    customer?: Customer;
    addressId?: number;
    address?: Address;
    lastUsedOn?: moment.Moment | undefined;
    isPrimary?: boolean;

    constructor(data?: ICustomerAddress) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.customerId = _data["CustomerId"];
            this.customer = _data["Customer"] ? Customer.fromJS(_data["Customer"]) : <any>undefined;
            this.addressId = _data["AddressId"];
            this.address = _data["Address"] ? Address.fromJS(_data["Address"]) : <any>undefined;
            this.lastUsedOn = _data["LastUsedOn"] ? moment(_data["LastUsedOn"].toString()) : <any>undefined;
            this.isPrimary = _data["IsPrimary"];
        }
    }

    static fromJS(data: any): CustomerAddress {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerAddress();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CustomerId"] = this.customerId;
        data["Customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        data["AddressId"] = this.addressId;
        data["Address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["LastUsedOn"] = this.lastUsedOn ? this.lastUsedOn.toISOString() : <any>undefined;
        data["IsPrimary"] = this.isPrimary;
        return data;
    }
}

export interface ICustomerAddress {
    id?: number;
    customerId?: number;
    customer?: Customer;
    addressId?: number;
    address?: Address;
    lastUsedOn?: moment.Moment | undefined;
    isPrimary?: boolean;
}

export class CustomerBankAccount implements ICustomerBankAccount {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    customerId?: number;
    customer?: Customer;
    symbolId?: number;
    symbol?: Symbol;
    bankId?: number;
    bank?: Bank;
    name?: string | undefined;
    accountNo?: string | undefined;

    constructor(data?: ICustomerBankAccount) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.createdOn = _data["CreatedOn"] ? moment(_data["CreatedOn"].toString()) : <any>undefined;
            this.createdById = _data["CreatedById"];
            this.createdBy = _data["CreatedBy"] ? User.fromJS(_data["CreatedBy"]) : <any>undefined;
            this.updatedOn = _data["UpdatedOn"] ? moment(_data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedById = _data["UpdatedById"];
            this.updatedBy = _data["UpdatedBy"] ? User.fromJS(_data["UpdatedBy"]) : <any>undefined;
            this.deletedOn = _data["DeletedOn"] ? moment(_data["DeletedOn"].toString()) : <any>undefined;
            this.deletedById = _data["DeletedById"];
            this.deletedBy = _data["DeletedBy"] ? User.fromJS(_data["DeletedBy"]) : <any>undefined;
            this.isDeleted = _data["IsDeleted"];
            this.customerId = _data["CustomerId"];
            this.customer = _data["Customer"] ? Customer.fromJS(_data["Customer"]) : <any>undefined;
            this.symbolId = _data["SymbolId"];
            this.symbol = _data["Symbol"] ? Symbol.fromJS(_data["Symbol"]) : <any>undefined;
            this.bankId = _data["BankId"];
            this.bank = _data["Bank"] ? Bank.fromJS(_data["Bank"]) : <any>undefined;
            this.name = _data["Name"];
            this.accountNo = _data["AccountNo"];
        }
    }

    static fromJS(data: any): CustomerBankAccount {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerBankAccount();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedById"] = this.createdById;
        data["CreatedBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["DeletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        data["DeletedById"] = this.deletedById;
        data["DeletedBy"] = this.deletedBy ? this.deletedBy.toJSON() : <any>undefined;
        data["IsDeleted"] = this.isDeleted;
        data["CustomerId"] = this.customerId;
        data["Customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        data["SymbolId"] = this.symbolId;
        data["Symbol"] = this.symbol ? this.symbol.toJSON() : <any>undefined;
        data["BankId"] = this.bankId;
        data["Bank"] = this.bank ? this.bank.toJSON() : <any>undefined;
        data["Name"] = this.name;
        data["AccountNo"] = this.accountNo;
        return data;
    }
}

export interface ICustomerBankAccount {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    customerId?: number;
    customer?: Customer;
    symbolId?: number;
    symbol?: Symbol;
    bankId?: number;
    bank?: Bank;
    name?: string | undefined;
    accountNo?: string | undefined;
}

export class CustomerContact implements ICustomerContact {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    customerId?: number;
    customer?: Customer;
    contactTypeId?: number;
    contactType?: ContactType;
    contactValue?: string | undefined;
    isPrimary?: boolean;

    constructor(data?: ICustomerContact) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.createdOn = _data["CreatedOn"] ? moment(_data["CreatedOn"].toString()) : <any>undefined;
            this.createdById = _data["CreatedById"];
            this.createdBy = _data["CreatedBy"] ? User.fromJS(_data["CreatedBy"]) : <any>undefined;
            this.updatedOn = _data["UpdatedOn"] ? moment(_data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedById = _data["UpdatedById"];
            this.updatedBy = _data["UpdatedBy"] ? User.fromJS(_data["UpdatedBy"]) : <any>undefined;
            this.deletedOn = _data["DeletedOn"] ? moment(_data["DeletedOn"].toString()) : <any>undefined;
            this.deletedById = _data["DeletedById"];
            this.deletedBy = _data["DeletedBy"] ? User.fromJS(_data["DeletedBy"]) : <any>undefined;
            this.isDeleted = _data["IsDeleted"];
            this.customerId = _data["CustomerId"];
            this.customer = _data["Customer"] ? Customer.fromJS(_data["Customer"]) : <any>undefined;
            this.contactTypeId = _data["ContactTypeId"];
            this.contactType = _data["ContactType"] ? ContactType.fromJS(_data["ContactType"]) : <any>undefined;
            this.contactValue = _data["ContactValue"];
            this.isPrimary = _data["IsPrimary"];
        }
    }

    static fromJS(data: any): CustomerContact {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerContact();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedById"] = this.createdById;
        data["CreatedBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["DeletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        data["DeletedById"] = this.deletedById;
        data["DeletedBy"] = this.deletedBy ? this.deletedBy.toJSON() : <any>undefined;
        data["IsDeleted"] = this.isDeleted;
        data["CustomerId"] = this.customerId;
        data["Customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        data["ContactTypeId"] = this.contactTypeId;
        data["ContactType"] = this.contactType ? this.contactType.toJSON() : <any>undefined;
        data["ContactValue"] = this.contactValue;
        data["IsPrimary"] = this.isPrimary;
        return data;
    }
}

export interface ICustomerContact {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    customerId?: number;
    customer?: Customer;
    contactTypeId?: number;
    contactType?: ContactType;
    contactValue?: string | undefined;
    isPrimary?: boolean;
}

export class CustomerDocument implements ICustomerDocument {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    customerId?: number;
    customer?: Customer;
    documentTypeId?: number;
    documentType?: DocumentType;
    medias?: CustomerDocumentMedia[] | undefined;
    countryId?: string | undefined;
    country?: Country;
    documentNo?: string | undefined;
    serialNo?: string | undefined;
    dateOfIssue?: moment.Moment;
    dateOfExpiry?: moment.Moment;
    isVerified?: boolean;
    verifiedOn?: moment.Moment;

    constructor(data?: ICustomerDocument) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.createdOn = _data["CreatedOn"] ? moment(_data["CreatedOn"].toString()) : <any>undefined;
            this.createdById = _data["CreatedById"];
            this.createdBy = _data["CreatedBy"] ? User.fromJS(_data["CreatedBy"]) : <any>undefined;
            this.updatedOn = _data["UpdatedOn"] ? moment(_data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedById = _data["UpdatedById"];
            this.updatedBy = _data["UpdatedBy"] ? User.fromJS(_data["UpdatedBy"]) : <any>undefined;
            this.deletedOn = _data["DeletedOn"] ? moment(_data["DeletedOn"].toString()) : <any>undefined;
            this.deletedById = _data["DeletedById"];
            this.deletedBy = _data["DeletedBy"] ? User.fromJS(_data["DeletedBy"]) : <any>undefined;
            this.isDeleted = _data["IsDeleted"];
            this.customerId = _data["CustomerId"];
            this.customer = _data["Customer"] ? Customer.fromJS(_data["Customer"]) : <any>undefined;
            this.documentTypeId = _data["DocumentTypeId"];
            this.documentType = _data["DocumentType"] ? DocumentType.fromJS(_data["DocumentType"]) : <any>undefined;
            if (Array.isArray(_data["Medias"])) {
                this.medias = [] as any;
                for (let item of _data["Medias"])
                    this.medias!.push(CustomerDocumentMedia.fromJS(item));
            }
            this.countryId = _data["CountryId"];
            this.country = _data["Country"] ? Country.fromJS(_data["Country"]) : <any>undefined;
            this.documentNo = _data["DocumentNo"];
            this.serialNo = _data["SerialNo"];
            this.dateOfIssue = _data["DateOfIssue"] ? moment(_data["DateOfIssue"].toString()) : <any>undefined;
            this.dateOfExpiry = _data["DateOfExpiry"] ? moment(_data["DateOfExpiry"].toString()) : <any>undefined;
            this.isVerified = _data["IsVerified"];
            this.verifiedOn = _data["VerifiedOn"] ? moment(_data["VerifiedOn"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CustomerDocument {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerDocument();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedById"] = this.createdById;
        data["CreatedBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["DeletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        data["DeletedById"] = this.deletedById;
        data["DeletedBy"] = this.deletedBy ? this.deletedBy.toJSON() : <any>undefined;
        data["IsDeleted"] = this.isDeleted;
        data["CustomerId"] = this.customerId;
        data["Customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        data["DocumentTypeId"] = this.documentTypeId;
        data["DocumentType"] = this.documentType ? this.documentType.toJSON() : <any>undefined;
        if (Array.isArray(this.medias)) {
            data["Medias"] = [];
            for (let item of this.medias)
                data["Medias"].push(item.toJSON());
        }
        data["CountryId"] = this.countryId;
        data["Country"] = this.country ? this.country.toJSON() : <any>undefined;
        data["DocumentNo"] = this.documentNo;
        data["SerialNo"] = this.serialNo;
        data["DateOfIssue"] = this.dateOfIssue ? this.dateOfIssue.toISOString() : <any>undefined;
        data["DateOfExpiry"] = this.dateOfExpiry ? this.dateOfExpiry.toISOString() : <any>undefined;
        data["IsVerified"] = this.isVerified;
        data["VerifiedOn"] = this.verifiedOn ? this.verifiedOn.toISOString() : <any>undefined;
        return data;
    }
}

export interface ICustomerDocument {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    customerId?: number;
    customer?: Customer;
    documentTypeId?: number;
    documentType?: DocumentType;
    medias?: CustomerDocumentMedia[] | undefined;
    countryId?: string | undefined;
    country?: Country;
    documentNo?: string | undefined;
    serialNo?: string | undefined;
    dateOfIssue?: moment.Moment;
    dateOfExpiry?: moment.Moment;
    isVerified?: boolean;
    verifiedOn?: moment.Moment;
}

export class CustomerDocumentMedia implements ICustomerDocumentMedia {
    id?: number;
    customerDocumentId?: number;
    customerDocument?: CustomerDocument;
    mediaId?: number;
    media?: Media;
    scanTypeId?: number;
    scanType?: ScanType;

    constructor(data?: ICustomerDocumentMedia) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.customerDocumentId = _data["CustomerDocumentId"];
            this.customerDocument = _data["CustomerDocument"] ? CustomerDocument.fromJS(_data["CustomerDocument"]) : <any>undefined;
            this.mediaId = _data["MediaId"];
            this.media = _data["Media"] ? Media.fromJS(_data["Media"]) : <any>undefined;
            this.scanTypeId = _data["ScanTypeId"];
            this.scanType = _data["ScanType"] ? ScanType.fromJS(_data["ScanType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CustomerDocumentMedia {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerDocumentMedia();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CustomerDocumentId"] = this.customerDocumentId;
        data["CustomerDocument"] = this.customerDocument ? this.customerDocument.toJSON() : <any>undefined;
        data["MediaId"] = this.mediaId;
        data["Media"] = this.media ? this.media.toJSON() : <any>undefined;
        data["ScanTypeId"] = this.scanTypeId;
        data["ScanType"] = this.scanType ? this.scanType.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICustomerDocumentMedia {
    id?: number;
    customerDocumentId?: number;
    customerDocument?: CustomerDocument;
    mediaId?: number;
    media?: Media;
    scanTypeId?: number;
    scanType?: ScanType;
}

export class CustomerModel implements ICustomerModel {
    customerType?: CustomerType;
    channelTypeId?: number | undefined;

    constructor(data?: ICustomerModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.customerType = _data["CustomerType"];
            this.channelTypeId = _data["ChannelTypeId"];
        }
    }

    static fromJS(data: any): CustomerModel {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["CustomerType"] = this.customerType;
        data["ChannelTypeId"] = this.channelTypeId;
        return data;
    }
}

export interface ICustomerModel {
    customerType?: CustomerType;
    channelTypeId?: number | undefined;
}

export enum CustomerType {
    _1 = 1,
    _2 = 2,
}

export class Cyp implements ICyp {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: ICyp) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): Cyp {
        data = typeof data === 'object' ? data : {};
        let result = new Cyp();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface ICyp {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class Data implements IData {
    day?: Day;

    constructor(data?: IData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.day = _data["Day"] ? Day.fromJS(_data["Day"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Data {
        data = typeof data === 'object' ? data : {};
        let result = new Data();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Day"] = this.day ? this.day.toJSON() : <any>undefined;
        return data;
    }
}

export interface IData {
    day?: Day;
}

export class Datum implements IDatum {
    time?: string | undefined;
    country?: string | undefined;
    indicator?: string | undefined;
    per?: string | undefined;
    priority?: string | undefined;
    actual?: string | undefined;
    consensus?: string | undefined;
    previous?: string | undefined;
    id?: string | undefined;

    constructor(data?: IDatum) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.time = _data["Time"];
            this.country = _data["Country"];
            this.indicator = _data["Indicator"];
            this.per = _data["Per"];
            this.priority = _data["Priority"];
            this.actual = _data["Actual"];
            this.consensus = _data["Consensus"];
            this.previous = _data["Previous"];
            this.id = _data["Id"];
        }
    }

    static fromJS(data: any): Datum {
        data = typeof data === 'object' ? data : {};
        let result = new Datum();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Time"] = this.time;
        data["Country"] = this.country;
        data["Indicator"] = this.indicator;
        data["Per"] = this.per;
        data["Priority"] = this.priority;
        data["Actual"] = this.actual;
        data["Consensus"] = this.consensus;
        data["Previous"] = this.previous;
        data["Id"] = this.id;
        return data;
    }
}

export interface IDatum {
    time?: string | undefined;
    country?: string | undefined;
    indicator?: string | undefined;
    per?: string | undefined;
    priority?: string | undefined;
    actual?: string | undefined;
    consensus?: string | undefined;
    previous?: string | undefined;
    id?: string | undefined;
}

export class Day implements IDay {
    datum?: Datum[] | undefined;
    date?: string | undefined;

    constructor(data?: IDay) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["Datum"])) {
                this.datum = [] as any;
                for (let item of _data["Datum"])
                    this.datum!.push(Datum.fromJS(item));
            }
            this.date = _data["Date"];
        }
    }

    static fromJS(data: any): Day {
        data = typeof data === 'object' ? data : {};
        let result = new Day();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.datum)) {
            data["Datum"] = [];
            for (let item of this.datum)
                data["Datum"].push(item.toJSON());
        }
        data["Date"] = this.date;
        return data;
    }
}

export interface IDay {
    datum?: Datum[] | undefined;
    date?: string | undefined;
}

export class DebentureModel implements IDebentureModel {
    data?: DebentureModelData[] | undefined;

    constructor(data?: IDebentureModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["Data"])) {
                this.data = [] as any;
                for (let item of _data["Data"])
                    this.data!.push(DebentureModelData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DebentureModel {
        data = typeof data === 'object' ? data : {};
        let result = new DebentureModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["Data"] = [];
            for (let item of this.data)
                data["Data"].push(item.toJSON());
        }
        return data;
    }
}

export interface IDebentureModel {
    data?: DebentureModelData[] | undefined;
}

export class DebentureModelData implements IDebentureModelData {
    sembol?: string | undefined;
    aciklama?: string | undefined;
    alis?: string | undefined;
    satis?: string | undefined;
    gunlukyuzde?: string | undefined;
    dunkukapanis?: string | undefined;
    piydeg?: string | undefined;
    fark?: string | undefined;
    tarih?: string | undefined;
    son?: string | undefined;
    simge?: string | undefined;
    vobSayi?: string | undefined;
    hacimtl?: string | undefined;
    hacimlot?: string | undefined;
    acilis?: string | undefined;
    dusuk?: string | undefined;
    yuksek?: string | undefined;
    tip?: string | undefined;
    sembolId?: string | undefined;
    yilYuksek?: string | undefined;
    yilDusuk?: string | undefined;
    sermaye?: string | undefined;

    constructor(data?: IDebentureModelData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sembol = _data["Sembol"];
            this.aciklama = _data["Aciklama"];
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
            this.dunkukapanis = _data["Dunkukapanis"];
            this.piydeg = _data["Piydeg"];
            this.fark = _data["Fark"];
            this.tarih = _data["Tarih"];
            this.son = _data["Son"];
            this.simge = _data["Simge"];
            this.vobSayi = _data["VobSayi"];
            this.hacimtl = _data["Hacimtl"];
            this.hacimlot = _data["Hacimlot"];
            this.acilis = _data["Acilis"];
            this.dusuk = _data["Dusuk"];
            this.yuksek = _data["Yuksek"];
            this.tip = _data["Tip"];
            this.sembolId = _data["SembolId"];
            this.yilYuksek = _data["YilYuksek"];
            this.yilDusuk = _data["YilDusuk"];
            this.sermaye = _data["Sermaye"];
        }
    }

    static fromJS(data: any): DebentureModelData {
        data = typeof data === 'object' ? data : {};
        let result = new DebentureModelData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Sembol"] = this.sembol;
        data["Aciklama"] = this.aciklama;
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        data["Dunkukapanis"] = this.dunkukapanis;
        data["Piydeg"] = this.piydeg;
        data["Fark"] = this.fark;
        data["Tarih"] = this.tarih;
        data["Son"] = this.son;
        data["Simge"] = this.simge;
        data["VobSayi"] = this.vobSayi;
        data["Hacimtl"] = this.hacimtl;
        data["Hacimlot"] = this.hacimlot;
        data["Acilis"] = this.acilis;
        data["Dusuk"] = this.dusuk;
        data["Yuksek"] = this.yuksek;
        data["Tip"] = this.tip;
        data["SembolId"] = this.sembolId;
        data["YilYuksek"] = this.yilYuksek;
        data["YilDusuk"] = this.yilDusuk;
        data["Sermaye"] = this.sermaye;
        return data;
    }
}

export interface IDebentureModelData {
    sembol?: string | undefined;
    aciklama?: string | undefined;
    alis?: string | undefined;
    satis?: string | undefined;
    gunlukyuzde?: string | undefined;
    dunkukapanis?: string | undefined;
    piydeg?: string | undefined;
    fark?: string | undefined;
    tarih?: string | undefined;
    son?: string | undefined;
    simge?: string | undefined;
    vobSayi?: string | undefined;
    hacimtl?: string | undefined;
    hacimlot?: string | undefined;
    acilis?: string | undefined;
    dusuk?: string | undefined;
    yuksek?: string | undefined;
    tip?: string | undefined;
    sembolId?: string | undefined;
    yilYuksek?: string | undefined;
    yilDusuk?: string | undefined;
    sermaye?: string | undefined;
}

export class DecoderFallback implements IDecoderFallback {
    readonly maxCharCount?: number;

    constructor(data?: IDecoderFallback) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).maxCharCount = _data["MaxCharCount"];
        }
    }

    static fromJS(data: any): DecoderFallback {
        data = typeof data === 'object' ? data : {};
        let result = new DecoderFallback();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["MaxCharCount"] = this.maxCharCount;
        return data;
    }
}

export interface IDecoderFallback {
    maxCharCount?: number;
}

export class DemandType implements IDemandType {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;

    constructor(data?: IDemandType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.createdOn = _data["CreatedOn"] ? moment(_data["CreatedOn"].toString()) : <any>undefined;
            this.createdById = _data["CreatedById"];
            this.createdBy = _data["CreatedBy"] ? User.fromJS(_data["CreatedBy"]) : <any>undefined;
            this.updatedOn = _data["UpdatedOn"] ? moment(_data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedById = _data["UpdatedById"];
            this.updatedBy = _data["UpdatedBy"] ? User.fromJS(_data["UpdatedBy"]) : <any>undefined;
            this.deletedOn = _data["DeletedOn"] ? moment(_data["DeletedOn"].toString()) : <any>undefined;
            this.deletedById = _data["DeletedById"];
            this.deletedBy = _data["DeletedBy"] ? User.fromJS(_data["DeletedBy"]) : <any>undefined;
            this.isDeleted = _data["IsDeleted"];
            this.code = _data["Code"];
            this.description = _data["Description"];
            this.displayOrder = _data["DisplayOrder"];
            this.isActive = _data["IsActive"];
        }
    }

    static fromJS(data: any): DemandType {
        data = typeof data === 'object' ? data : {};
        let result = new DemandType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedById"] = this.createdById;
        data["CreatedBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["DeletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        data["DeletedById"] = this.deletedById;
        data["DeletedBy"] = this.deletedBy ? this.deletedBy.toJSON() : <any>undefined;
        data["IsDeleted"] = this.isDeleted;
        data["Code"] = this.code;
        data["Description"] = this.description;
        data["DisplayOrder"] = this.displayOrder;
        data["IsActive"] = this.isActive;
        return data;
    }
}

export interface IDemandType {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;
}

export class District implements IDistrict {
    id?: number;
    provinceId?: number;
    province?: Province;
    name!: string;
    type?: string | undefined;
    location?: string | undefined;

    constructor(data?: IDistrict) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.provinceId = _data["ProvinceId"];
            this.province = _data["Province"] ? Province.fromJS(_data["Province"]) : <any>undefined;
            this.name = _data["Name"];
            this.type = _data["Type"];
            this.location = _data["Location"];
        }
    }

    static fromJS(data: any): District {
        data = typeof data === 'object' ? data : {};
        let result = new District();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["ProvinceId"] = this.provinceId;
        data["Province"] = this.province ? this.province.toJSON() : <any>undefined;
        data["Name"] = this.name;
        data["Type"] = this.type;
        data["Location"] = this.location;
        return data;
    }
}

export interface IDistrict {
    id?: number;
    provinceId?: number;
    province?: Province;
    name: string;
    type?: string | undefined;
    location?: string | undefined;
}

export class Dkk implements IDkk {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IDkk) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): Dkk {
        data = typeof data === 'object' ? data : {};
        let result = new Dkk();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IDkk {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class DocumentType implements IDocumentType {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;

    constructor(data?: IDocumentType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.createdOn = _data["CreatedOn"] ? moment(_data["CreatedOn"].toString()) : <any>undefined;
            this.createdById = _data["CreatedById"];
            this.createdBy = _data["CreatedBy"] ? User.fromJS(_data["CreatedBy"]) : <any>undefined;
            this.updatedOn = _data["UpdatedOn"] ? moment(_data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedById = _data["UpdatedById"];
            this.updatedBy = _data["UpdatedBy"] ? User.fromJS(_data["UpdatedBy"]) : <any>undefined;
            this.deletedOn = _data["DeletedOn"] ? moment(_data["DeletedOn"].toString()) : <any>undefined;
            this.deletedById = _data["DeletedById"];
            this.deletedBy = _data["DeletedBy"] ? User.fromJS(_data["DeletedBy"]) : <any>undefined;
            this.isDeleted = _data["IsDeleted"];
            this.code = _data["Code"];
            this.description = _data["Description"];
            this.displayOrder = _data["DisplayOrder"];
            this.isActive = _data["IsActive"];
        }
    }

    static fromJS(data: any): DocumentType {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedById"] = this.createdById;
        data["CreatedBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["DeletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        data["DeletedById"] = this.deletedById;
        data["DeletedBy"] = this.deletedBy ? this.deletedBy.toJSON() : <any>undefined;
        data["IsDeleted"] = this.isDeleted;
        data["Code"] = this.code;
        data["Description"] = this.description;
        data["DisplayOrder"] = this.displayOrder;
        data["IsActive"] = this.isActive;
        return data;
    }
}

export interface IDocumentType {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;
}

export class Effects implements IEffects {
    readonly container?: string[] | undefined;
    duration?: number;
    reverse?: boolean;

    constructor(data?: IEffects) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["Container"])) {
                (<any>this).container = [] as any;
                for (let item of _data["Container"])
                    (<any>this).container!.push(item);
            }
            this.duration = _data["Duration"];
            this.reverse = _data["Reverse"];
        }
    }

    static fromJS(data: any): Effects {
        data = typeof data === 'object' ? data : {};
        let result = new Effects();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.container)) {
            data["Container"] = [];
            for (let item of this.container)
                data["Container"].push(item);
        }
        data["Duration"] = this.duration;
        data["Reverse"] = this.reverse;
        return data;
    }
}

export interface IEffects {
    container?: string[] | undefined;
    duration?: number;
    reverse?: boolean;
}

export enum EmptyBodyBehavior {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export class EncoderFallback implements IEncoderFallback {
    readonly maxCharCount?: number;

    constructor(data?: IEncoderFallback) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).maxCharCount = _data["MaxCharCount"];
        }
    }

    static fromJS(data: any): EncoderFallback {
        data = typeof data === 'object' ? data : {};
        let result = new EncoderFallback();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["MaxCharCount"] = this.maxCharCount;
        return data;
    }
}

export interface IEncoderFallback {
    maxCharCount?: number;
}

export class Encoding implements IEncoding {
    preamble?: ByteReadOnlySpan;
    readonly bodyName?: string | undefined;
    readonly encodingName?: string | undefined;
    readonly headerName?: string | undefined;
    readonly webName?: string | undefined;
    readonly windowsCodePage?: number;
    readonly isBrowserDisplay?: boolean;
    readonly isBrowserSave?: boolean;
    readonly isMailNewsDisplay?: boolean;
    readonly isMailNewsSave?: boolean;
    readonly isSingleByte?: boolean;
    encoderFallback?: EncoderFallback;
    decoderFallback?: DecoderFallback;
    readonly isReadOnly?: boolean;
    readonly codePage?: number;

    constructor(data?: IEncoding) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.preamble = _data["Preamble"] ? ByteReadOnlySpan.fromJS(_data["Preamble"]) : <any>undefined;
            (<any>this).bodyName = _data["BodyName"];
            (<any>this).encodingName = _data["EncodingName"];
            (<any>this).headerName = _data["HeaderName"];
            (<any>this).webName = _data["WebName"];
            (<any>this).windowsCodePage = _data["WindowsCodePage"];
            (<any>this).isBrowserDisplay = _data["IsBrowserDisplay"];
            (<any>this).isBrowserSave = _data["IsBrowserSave"];
            (<any>this).isMailNewsDisplay = _data["IsMailNewsDisplay"];
            (<any>this).isMailNewsSave = _data["IsMailNewsSave"];
            (<any>this).isSingleByte = _data["IsSingleByte"];
            this.encoderFallback = _data["EncoderFallback"] ? EncoderFallback.fromJS(_data["EncoderFallback"]) : <any>undefined;
            this.decoderFallback = _data["DecoderFallback"] ? DecoderFallback.fromJS(_data["DecoderFallback"]) : <any>undefined;
            (<any>this).isReadOnly = _data["IsReadOnly"];
            (<any>this).codePage = _data["CodePage"];
        }
    }

    static fromJS(data: any): Encoding {
        data = typeof data === 'object' ? data : {};
        let result = new Encoding();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Preamble"] = this.preamble ? this.preamble.toJSON() : <any>undefined;
        data["BodyName"] = this.bodyName;
        data["EncodingName"] = this.encodingName;
        data["HeaderName"] = this.headerName;
        data["WebName"] = this.webName;
        data["WindowsCodePage"] = this.windowsCodePage;
        data["IsBrowserDisplay"] = this.isBrowserDisplay;
        data["IsBrowserSave"] = this.isBrowserSave;
        data["IsMailNewsDisplay"] = this.isMailNewsDisplay;
        data["IsMailNewsSave"] = this.isMailNewsSave;
        data["IsSingleByte"] = this.isSingleByte;
        data["EncoderFallback"] = this.encoderFallback ? this.encoderFallback.toJSON() : <any>undefined;
        data["DecoderFallback"] = this.decoderFallback ? this.decoderFallback.toJSON() : <any>undefined;
        data["IsReadOnly"] = this.isReadOnly;
        data["CodePage"] = this.codePage;
        return data;
    }
}

export interface IEncoding {
    preamble?: ByteReadOnlySpan;
    bodyName?: string | undefined;
    encodingName?: string | undefined;
    headerName?: string | undefined;
    webName?: string | undefined;
    windowsCodePage?: number;
    isBrowserDisplay?: boolean;
    isBrowserSave?: boolean;
    isMailNewsDisplay?: boolean;
    isMailNewsSave?: boolean;
    isSingleByte?: boolean;
    encoderFallback?: EncoderFallback;
    decoderFallback?: DecoderFallback;
    isReadOnly?: boolean;
    codePage?: number;
}

export class EnumGroupAndName implements IEnumGroupAndName {
    readonly group?: string | undefined;
    readonly name?: string | undefined;

    constructor(data?: IEnumGroupAndName) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).group = _data["Group"];
            (<any>this).name = _data["Name"];
        }
    }

    static fromJS(data: any): EnumGroupAndName {
        data = typeof data === 'object' ? data : {};
        let result = new EnumGroupAndName();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Group"] = this.group;
        data["Name"] = this.name;
        return data;
    }
}

export interface IEnumGroupAndName {
    group?: string | undefined;
    name?: string | undefined;
}

export class EnumGroupAndNameStringKeyValuePair implements IEnumGroupAndNameStringKeyValuePair {
    key?: EnumGroupAndName;
    readonly value?: string | undefined;

    constructor(data?: IEnumGroupAndNameStringKeyValuePair) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["Key"] ? EnumGroupAndName.fromJS(_data["Key"]) : <any>undefined;
            (<any>this).value = _data["Value"];
        }
    }

    static fromJS(data: any): EnumGroupAndNameStringKeyValuePair {
        data = typeof data === 'object' ? data : {};
        let result = new EnumGroupAndNameStringKeyValuePair();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Key"] = this.key ? this.key.toJSON() : <any>undefined;
        data["Value"] = this.value;
        return data;
    }
}

export interface IEnumGroupAndNameStringKeyValuePair {
    key?: EnumGroupAndName;
    value?: string | undefined;
}

export class ErrorDto implements IErrorDto {
    flag?: string | undefined;
    type?: string | undefined;
    msg?: string | undefined;

    constructor(data?: IErrorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.flag = _data["Flag"];
            this.type = _data["Type"];
            this.msg = _data["Msg"];
        }
    }

    static fromJS(data: any): ErrorDto {
        data = typeof data === 'object' ? data : {};
        let result = new ErrorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Flag"] = this.flag;
        data["Type"] = this.type;
        data["Msg"] = this.msg;
        return data;
    }
}

export interface IErrorDto {
    flag?: string | undefined;
    type?: string | undefined;
    msg?: string | undefined;
}

export class Euro implements IEuro {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IEuro) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): Euro {
        data = typeof data === 'object' ? data : {};
        let result = new Euro();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IEuro {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class Eurtry implements IEurtry {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IEurtry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): Eurtry {
        data = typeof data === 'object' ? data : {};
        let result = new Eurtry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IEurtry {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export enum EventAttributes {
    _0 = 0,
    _512 = 512,
    _1024 = 1024,
}

export class EventInfo implements IEventInfo {
    readonly name?: string | undefined;
    declaringType?: Type;
    reflectedType?: Type;
    module?: Module;
    readonly customAttributes?: CustomAttributeData[] | undefined;
    readonly isCollectible?: boolean;
    readonly metadataToken?: number;
    memberType?: MemberTypes;
    attributes?: EventAttributes;
    readonly isSpecialName?: boolean;
    addMethod?: MethodInfo;
    removeMethod?: MethodInfo;
    raiseMethod?: MethodInfo;
    readonly isMulticast?: boolean;
    eventHandlerType?: Type;

    constructor(data?: IEventInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).name = _data["Name"];
            this.declaringType = _data["DeclaringType"] ? Type.fromJS(_data["DeclaringType"]) : <any>undefined;
            this.reflectedType = _data["ReflectedType"] ? Type.fromJS(_data["ReflectedType"]) : <any>undefined;
            this.module = _data["Module"] ? Module.fromJS(_data["Module"]) : <any>undefined;
            if (Array.isArray(_data["CustomAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["CustomAttributes"])
                    (<any>this).customAttributes!.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).isCollectible = _data["IsCollectible"];
            (<any>this).metadataToken = _data["MetadataToken"];
            this.memberType = _data["MemberType"];
            this.attributes = _data["Attributes"];
            (<any>this).isSpecialName = _data["IsSpecialName"];
            this.addMethod = _data["AddMethod"] ? MethodInfo.fromJS(_data["AddMethod"]) : <any>undefined;
            this.removeMethod = _data["RemoveMethod"] ? MethodInfo.fromJS(_data["RemoveMethod"]) : <any>undefined;
            this.raiseMethod = _data["RaiseMethod"] ? MethodInfo.fromJS(_data["RaiseMethod"]) : <any>undefined;
            (<any>this).isMulticast = _data["IsMulticast"];
            this.eventHandlerType = _data["EventHandlerType"] ? Type.fromJS(_data["EventHandlerType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): EventInfo {
        data = typeof data === 'object' ? data : {};
        let result = new EventInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Name"] = this.name;
        data["DeclaringType"] = this.declaringType ? this.declaringType.toJSON() : <any>undefined;
        data["ReflectedType"] = this.reflectedType ? this.reflectedType.toJSON() : <any>undefined;
        data["Module"] = this.module ? this.module.toJSON() : <any>undefined;
        if (Array.isArray(this.customAttributes)) {
            data["CustomAttributes"] = [];
            for (let item of this.customAttributes)
                data["CustomAttributes"].push(item.toJSON());
        }
        data["IsCollectible"] = this.isCollectible;
        data["MetadataToken"] = this.metadataToken;
        data["MemberType"] = this.memberType;
        data["Attributes"] = this.attributes;
        data["IsSpecialName"] = this.isSpecialName;
        data["AddMethod"] = this.addMethod ? this.addMethod.toJSON() : <any>undefined;
        data["RemoveMethod"] = this.removeMethod ? this.removeMethod.toJSON() : <any>undefined;
        data["RaiseMethod"] = this.raiseMethod ? this.raiseMethod.toJSON() : <any>undefined;
        data["IsMulticast"] = this.isMulticast;
        data["EventHandlerType"] = this.eventHandlerType ? this.eventHandlerType.toJSON() : <any>undefined;
        return data;
    }
}

export interface IEventInfo {
    name?: string | undefined;
    declaringType?: Type;
    reflectedType?: Type;
    module?: Module;
    customAttributes?: CustomAttributeData[] | undefined;
    isCollectible?: boolean;
    metadataToken?: number;
    memberType?: MemberTypes;
    attributes?: EventAttributes;
    isSpecialName?: boolean;
    addMethod?: MethodInfo;
    removeMethod?: MethodInfo;
    raiseMethod?: MethodInfo;
    isMulticast?: boolean;
    eventHandlerType?: Type;
}

export class Exception implements IException {
    targetSite?: MethodBase;
    readonly stackTrace?: string | undefined;
    readonly message?: string | undefined;
    readonly data?: { [key: string]: any; } | undefined;
    innerException?: Exception;
    helpLink?: string | undefined;
    source?: string | undefined;
    hResult?: number;

    constructor(data?: IException) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.targetSite = _data["TargetSite"] ? MethodBase.fromJS(_data["TargetSite"]) : <any>undefined;
            (<any>this).stackTrace = _data["StackTrace"];
            (<any>this).message = _data["Message"];
            if (_data["Data"]) {
                (<any>this).data = {} as any;
                for (let key in _data["Data"]) {
                    if (_data["Data"].hasOwnProperty(key))
                        (<any>(<any>this).data)![key] = _data["Data"][key];
                }
            }
            this.innerException = _data["InnerException"] ? Exception.fromJS(_data["InnerException"]) : <any>undefined;
            this.helpLink = _data["HelpLink"];
            this.source = _data["Source"];
            this.hResult = _data["HResult"];
        }
    }

    static fromJS(data: any): Exception {
        data = typeof data === 'object' ? data : {};
        let result = new Exception();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["TargetSite"] = this.targetSite ? this.targetSite.toJSON() : <any>undefined;
        data["StackTrace"] = this.stackTrace;
        data["Message"] = this.message;
        if (this.data) {
            data["Data"] = {};
            for (let key in this.data) {
                if (this.data.hasOwnProperty(key))
                    (<any>data["Data"])[key] = this.data[key];
            }
        }
        data["InnerException"] = this.innerException ? this.innerException.toJSON() : <any>undefined;
        data["HelpLink"] = this.helpLink;
        data["Source"] = this.source;
        data["HResult"] = this.hResult;
        return data;
    }
}

export interface IException {
    targetSite?: MethodBase;
    stackTrace?: string | undefined;
    message?: string | undefined;
    data?: { [key: string]: any; } | undefined;
    innerException?: Exception;
    helpLink?: string | undefined;
    source?: string | undefined;
    hResult?: number;
}

export enum FieldAttributes {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _16 = 16,
    _32 = 32,
    _64 = 64,
    _128 = 128,
    _256 = 256,
    _512 = 512,
    _1024 = 1024,
    _4096 = 4096,
    _8192 = 8192,
    _32768 = 32768,
    _38144 = 38144,
}

export class FieldInfo implements IFieldInfo {
    readonly name?: string | undefined;
    declaringType?: Type;
    reflectedType?: Type;
    module?: Module;
    readonly customAttributes?: CustomAttributeData[] | undefined;
    readonly isCollectible?: boolean;
    readonly metadataToken?: number;
    memberType?: MemberTypes;
    attributes?: FieldAttributes;
    fieldType?: Type;
    readonly isInitOnly?: boolean;
    readonly isLiteral?: boolean;
    readonly isNotSerialized?: boolean;
    readonly isPinvokeImpl?: boolean;
    readonly isSpecialName?: boolean;
    readonly isStatic?: boolean;
    readonly isAssembly?: boolean;
    readonly isFamily?: boolean;
    readonly isFamilyAndAssembly?: boolean;
    readonly isFamilyOrAssembly?: boolean;
    readonly isPrivate?: boolean;
    readonly isPublic?: boolean;
    readonly isSecurityCritical?: boolean;
    readonly isSecuritySafeCritical?: boolean;
    readonly isSecurityTransparent?: boolean;
    fieldHandle?: RuntimeFieldHandle;

    constructor(data?: IFieldInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).name = _data["Name"];
            this.declaringType = _data["DeclaringType"] ? Type.fromJS(_data["DeclaringType"]) : <any>undefined;
            this.reflectedType = _data["ReflectedType"] ? Type.fromJS(_data["ReflectedType"]) : <any>undefined;
            this.module = _data["Module"] ? Module.fromJS(_data["Module"]) : <any>undefined;
            if (Array.isArray(_data["CustomAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["CustomAttributes"])
                    (<any>this).customAttributes!.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).isCollectible = _data["IsCollectible"];
            (<any>this).metadataToken = _data["MetadataToken"];
            this.memberType = _data["MemberType"];
            this.attributes = _data["Attributes"];
            this.fieldType = _data["FieldType"] ? Type.fromJS(_data["FieldType"]) : <any>undefined;
            (<any>this).isInitOnly = _data["IsInitOnly"];
            (<any>this).isLiteral = _data["IsLiteral"];
            (<any>this).isNotSerialized = _data["IsNotSerialized"];
            (<any>this).isPinvokeImpl = _data["IsPinvokeImpl"];
            (<any>this).isSpecialName = _data["IsSpecialName"];
            (<any>this).isStatic = _data["IsStatic"];
            (<any>this).isAssembly = _data["IsAssembly"];
            (<any>this).isFamily = _data["IsFamily"];
            (<any>this).isFamilyAndAssembly = _data["IsFamilyAndAssembly"];
            (<any>this).isFamilyOrAssembly = _data["IsFamilyOrAssembly"];
            (<any>this).isPrivate = _data["IsPrivate"];
            (<any>this).isPublic = _data["IsPublic"];
            (<any>this).isSecurityCritical = _data["IsSecurityCritical"];
            (<any>this).isSecuritySafeCritical = _data["IsSecuritySafeCritical"];
            (<any>this).isSecurityTransparent = _data["IsSecurityTransparent"];
            this.fieldHandle = _data["FieldHandle"] ? RuntimeFieldHandle.fromJS(_data["FieldHandle"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FieldInfo {
        data = typeof data === 'object' ? data : {};
        let result = new FieldInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Name"] = this.name;
        data["DeclaringType"] = this.declaringType ? this.declaringType.toJSON() : <any>undefined;
        data["ReflectedType"] = this.reflectedType ? this.reflectedType.toJSON() : <any>undefined;
        data["Module"] = this.module ? this.module.toJSON() : <any>undefined;
        if (Array.isArray(this.customAttributes)) {
            data["CustomAttributes"] = [];
            for (let item of this.customAttributes)
                data["CustomAttributes"].push(item.toJSON());
        }
        data["IsCollectible"] = this.isCollectible;
        data["MetadataToken"] = this.metadataToken;
        data["MemberType"] = this.memberType;
        data["Attributes"] = this.attributes;
        data["FieldType"] = this.fieldType ? this.fieldType.toJSON() : <any>undefined;
        data["IsInitOnly"] = this.isInitOnly;
        data["IsLiteral"] = this.isLiteral;
        data["IsNotSerialized"] = this.isNotSerialized;
        data["IsPinvokeImpl"] = this.isPinvokeImpl;
        data["IsSpecialName"] = this.isSpecialName;
        data["IsStatic"] = this.isStatic;
        data["IsAssembly"] = this.isAssembly;
        data["IsFamily"] = this.isFamily;
        data["IsFamilyAndAssembly"] = this.isFamilyAndAssembly;
        data["IsFamilyOrAssembly"] = this.isFamilyOrAssembly;
        data["IsPrivate"] = this.isPrivate;
        data["IsPublic"] = this.isPublic;
        data["IsSecurityCritical"] = this.isSecurityCritical;
        data["IsSecuritySafeCritical"] = this.isSecuritySafeCritical;
        data["IsSecurityTransparent"] = this.isSecurityTransparent;
        data["FieldHandle"] = this.fieldHandle ? this.fieldHandle.toJSON() : <any>undefined;
        return data;
    }
}

export interface IFieldInfo {
    name?: string | undefined;
    declaringType?: Type;
    reflectedType?: Type;
    module?: Module;
    customAttributes?: CustomAttributeData[] | undefined;
    isCollectible?: boolean;
    metadataToken?: number;
    memberType?: MemberTypes;
    attributes?: FieldAttributes;
    fieldType?: Type;
    isInitOnly?: boolean;
    isLiteral?: boolean;
    isNotSerialized?: boolean;
    isPinvokeImpl?: boolean;
    isSpecialName?: boolean;
    isStatic?: boolean;
    isAssembly?: boolean;
    isFamily?: boolean;
    isFamilyAndAssembly?: boolean;
    isFamilyOrAssembly?: boolean;
    isPrivate?: boolean;
    isPublic?: boolean;
    isSecurityCritical?: boolean;
    isSecuritySafeCritical?: boolean;
    isSecurityTransparent?: boolean;
    fieldHandle?: RuntimeFieldHandle;
}

export class FilterDescriptor implements IFilterDescriptor {
    filter?: IFilterMetadata;
    order?: number;
    readonly scope?: number;

    constructor(data?: IFilterDescriptor) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.filter = _data["Filter"] ? IFilterMetadata.fromJS(_data["Filter"]) : <any>undefined;
            this.order = _data["Order"];
            (<any>this).scope = _data["Scope"];
        }
    }

    static fromJS(data: any): FilterDescriptor {
        data = typeof data === 'object' ? data : {};
        let result = new FilterDescriptor();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        data["Order"] = this.order;
        data["Scope"] = this.scope;
        return data;
    }
}

export interface IFilterDescriptor {
    filter?: IFilterMetadata;
    order?: number;
    scope?: number;
}

export class FormContext implements IFormContext {
    readonly formData?: { [key: string]: any; } | undefined;
    hasAntiforgeryToken?: boolean;
    readonly hasFormData?: boolean;
    readonly hasEndOfFormContent?: boolean;
    readonly endOfFormContent?: IHtmlContent[] | undefined;
    canRenderAtEndOfForm?: boolean;

    constructor(data?: IFormContext) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["FormData"]) {
                (<any>this).formData = {} as any;
                for (let key in _data["FormData"]) {
                    if (_data["FormData"].hasOwnProperty(key))
                        (<any>(<any>this).formData)![key] = _data["FormData"][key];
                }
            }
            this.hasAntiforgeryToken = _data["HasAntiforgeryToken"];
            (<any>this).hasFormData = _data["HasFormData"];
            (<any>this).hasEndOfFormContent = _data["HasEndOfFormContent"];
            if (Array.isArray(_data["EndOfFormContent"])) {
                (<any>this).endOfFormContent = [] as any;
                for (let item of _data["EndOfFormContent"])
                    (<any>this).endOfFormContent!.push(IHtmlContent.fromJS(item));
            }
            this.canRenderAtEndOfForm = _data["CanRenderAtEndOfForm"];
        }
    }

    static fromJS(data: any): FormContext {
        data = typeof data === 'object' ? data : {};
        let result = new FormContext();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.formData) {
            data["FormData"] = {};
            for (let key in this.formData) {
                if (this.formData.hasOwnProperty(key))
                    (<any>data["FormData"])[key] = this.formData[key];
            }
        }
        data["HasAntiforgeryToken"] = this.hasAntiforgeryToken;
        data["HasFormData"] = this.hasFormData;
        data["HasEndOfFormContent"] = this.hasEndOfFormContent;
        if (Array.isArray(this.endOfFormContent)) {
            data["EndOfFormContent"] = [];
            for (let item of this.endOfFormContent)
                data["EndOfFormContent"].push(item.toJSON());
        }
        data["CanRenderAtEndOfForm"] = this.canRenderAtEndOfForm;
        return data;
    }
}

export interface IFormContext {
    formData?: { [key: string]: any; } | undefined;
    hasAntiforgeryToken?: boolean;
    hasFormData?: boolean;
    hasEndOfFormContent?: boolean;
    endOfFormContent?: IHtmlContent[] | undefined;
    canRenderAtEndOfForm?: boolean;
}

export class Gbp implements IGbp {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IGbp) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): Gbp {
        data = typeof data === 'object' ? data : {};
        let result = new Gbp();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IGbp {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class Gender implements IGender {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;

    constructor(data?: IGender) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.createdOn = _data["CreatedOn"] ? moment(_data["CreatedOn"].toString()) : <any>undefined;
            this.createdById = _data["CreatedById"];
            this.createdBy = _data["CreatedBy"] ? User.fromJS(_data["CreatedBy"]) : <any>undefined;
            this.updatedOn = _data["UpdatedOn"] ? moment(_data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedById = _data["UpdatedById"];
            this.updatedBy = _data["UpdatedBy"] ? User.fromJS(_data["UpdatedBy"]) : <any>undefined;
            this.deletedOn = _data["DeletedOn"] ? moment(_data["DeletedOn"].toString()) : <any>undefined;
            this.deletedById = _data["DeletedById"];
            this.deletedBy = _data["DeletedBy"] ? User.fromJS(_data["DeletedBy"]) : <any>undefined;
            this.isDeleted = _data["IsDeleted"];
            this.code = _data["Code"];
            this.description = _data["Description"];
            this.displayOrder = _data["DisplayOrder"];
            this.isActive = _data["IsActive"];
        }
    }

    static fromJS(data: any): Gender {
        data = typeof data === 'object' ? data : {};
        let result = new Gender();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedById"] = this.createdById;
        data["CreatedBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["DeletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        data["DeletedById"] = this.deletedById;
        data["DeletedBy"] = this.deletedBy ? this.deletedBy.toJSON() : <any>undefined;
        data["IsDeleted"] = this.isDeleted;
        data["Code"] = this.code;
        data["Description"] = this.description;
        data["DisplayOrder"] = this.displayOrder;
        data["IsActive"] = this.isActive;
        return data;
    }
}

export interface IGender {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;
}

export class GenderModel implements IGenderModel {
    id?: number;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;

    constructor(data?: IGenderModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.code = _data["Code"];
            this.description = _data["Description"];
            this.displayOrder = _data["DisplayOrder"];
            this.isActive = _data["IsActive"];
        }
    }

    static fromJS(data: any): GenderModel {
        data = typeof data === 'object' ? data : {};
        let result = new GenderModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Code"] = this.code;
        data["Description"] = this.description;
        data["DisplayOrder"] = this.displayOrder;
        data["IsActive"] = this.isActive;
        return data;
    }
}

export interface IGenderModel {
    id?: number;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;
}

export enum GenericParameterAttributes {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _8 = 8,
    _16 = 16,
    _28 = 28,
}

export class Group implements IGroup {
    id?: number;
    name!: string;
    description?: string | undefined;
    isDeleted?: boolean;

    constructor(data?: IGroup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.name = _data["Name"];
            this.description = _data["Description"];
            this.isDeleted = _data["IsDeleted"];
        }
    }

    static fromJS(data: any): Group {
        data = typeof data === 'object' ? data : {};
        let result = new Group();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Name"] = this.name;
        data["Description"] = this.description;
        data["IsDeleted"] = this.isDeleted;
        return data;
    }
}

export interface IGroup {
    id?: number;
    name: string;
    description?: string | undefined;
    isDeleted?: boolean;
}

export class Gumus implements IGumus {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IGumus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): Gumus {
        data = typeof data === 'object' ? data : {};
        let result = new Gumus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IGumus {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class Gumuseur implements IGumuseur {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IGumuseur) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): Gumuseur {
        data = typeof data === 'object' ? data : {};
        let result = new Gumuseur();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IGumuseur {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class Gumusfix implements IGumusfix {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IGumusfix) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): Gumusfix {
        data = typeof data === 'object' ? data : {};
        let result = new Gumusfix();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IGumusfix {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class Gumusserbest implements IGumusserbest {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IGumusserbest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): Gumusserbest {
        data = typeof data === 'object' ? data : {};
        let result = new Gumusserbest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IGumusserbest {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class Gumususd implements IGumususd {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IGumususd) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): Gumususd {
        data = typeof data === 'object' ? data : {};
        let result = new Gumususd();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IGumususd {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class HostString implements IHostString {
    readonly value?: string | undefined;
    readonly hasValue?: boolean;
    readonly host?: string | undefined;
    readonly port?: number | undefined;

    constructor(data?: IHostString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).value = _data["Value"];
            (<any>this).hasValue = _data["HasValue"];
            (<any>this).host = _data["Host"];
            (<any>this).port = _data["Port"];
        }
    }

    static fromJS(data: any): HostString {
        data = typeof data === 'object' ? data : {};
        let result = new HostString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Value"] = this.value;
        data["HasValue"] = this.hasValue;
        data["Host"] = this.host;
        data["Port"] = this.port;
        return data;
    }
}

export interface IHostString {
    value?: string | undefined;
    hasValue?: boolean;
    host?: string | undefined;
    port?: number | undefined;
}

export enum Html5DateRenderingMode {
    _0 = 0,
    _1 = 1,
}

export class HtmlEncoder implements IHtmlEncoder {
    readonly maxOutputCharactersPerInputCharacter?: number;

    constructor(data?: IHtmlEncoder) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).maxOutputCharactersPerInputCharacter = _data["MaxOutputCharactersPerInputCharacter"];
        }
    }

    static fromJS(data: any): HtmlEncoder {
        data = typeof data === 'object' ? data : {};
        let result = new HtmlEncoder();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["MaxOutputCharactersPerInputCharacter"] = this.maxOutputCharactersPerInputCharacter;
        return data;
    }
}

export interface IHtmlEncoder {
    maxOutputCharactersPerInputCharacter?: number;
}

export class HttpContext implements IHttpContext {
    readonly features?: TypeObjectKeyValuePair[] | undefined;
    request?: HttpRequest;
    response?: HttpResponse;
    connection?: ConnectionInfo;
    webSockets?: WebSocketManager;
    user?: ClaimsPrincipal;
    items?: { [key: string]: any; } | undefined;
    requestServices?: IServiceProvider;
    requestAborted?: CancellationToken;
    traceIdentifier?: string | undefined;
    session?: ISession;

    constructor(data?: IHttpContext) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["Features"])) {
                (<any>this).features = [] as any;
                for (let item of _data["Features"])
                    (<any>this).features!.push(TypeObjectKeyValuePair.fromJS(item));
            }
            this.request = _data["Request"] ? HttpRequest.fromJS(_data["Request"]) : <any>undefined;
            this.response = _data["Response"] ? HttpResponse.fromJS(_data["Response"]) : <any>undefined;
            this.connection = _data["Connection"] ? ConnectionInfo.fromJS(_data["Connection"]) : <any>undefined;
            this.webSockets = _data["WebSockets"] ? WebSocketManager.fromJS(_data["WebSockets"]) : <any>undefined;
            this.user = _data["User"] ? ClaimsPrincipal.fromJS(_data["User"]) : <any>undefined;
            if (_data["Items"]) {
                this.items = {} as any;
                for (let key in _data["Items"]) {
                    if (_data["Items"].hasOwnProperty(key))
                        (<any>this.items)![key] = _data["Items"][key];
                }
            }
            this.requestServices = _data["RequestServices"] ? IServiceProvider.fromJS(_data["RequestServices"]) : <any>undefined;
            this.requestAborted = _data["RequestAborted"] ? CancellationToken.fromJS(_data["RequestAborted"]) : <any>undefined;
            this.traceIdentifier = _data["TraceIdentifier"];
            this.session = _data["Session"] ? ISession.fromJS(_data["Session"]) : <any>undefined;
        }
    }

    static fromJS(data: any): HttpContext {
        data = typeof data === 'object' ? data : {};
        let result = new HttpContext();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.features)) {
            data["Features"] = [];
            for (let item of this.features)
                data["Features"].push(item.toJSON());
        }
        data["Request"] = this.request ? this.request.toJSON() : <any>undefined;
        data["Response"] = this.response ? this.response.toJSON() : <any>undefined;
        data["Connection"] = this.connection ? this.connection.toJSON() : <any>undefined;
        data["WebSockets"] = this.webSockets ? this.webSockets.toJSON() : <any>undefined;
        data["User"] = this.user ? this.user.toJSON() : <any>undefined;
        if (this.items) {
            data["Items"] = {};
            for (let key in this.items) {
                if (this.items.hasOwnProperty(key))
                    (<any>data["Items"])[key] = this.items[key];
            }
        }
        data["RequestServices"] = this.requestServices ? this.requestServices.toJSON() : <any>undefined;
        data["RequestAborted"] = this.requestAborted ? this.requestAborted.toJSON() : <any>undefined;
        data["TraceIdentifier"] = this.traceIdentifier;
        data["Session"] = this.session ? this.session.toJSON() : <any>undefined;
        return data;
    }
}

export interface IHttpContext {
    features?: TypeObjectKeyValuePair[] | undefined;
    request?: HttpRequest;
    response?: HttpResponse;
    connection?: ConnectionInfo;
    webSockets?: WebSocketManager;
    user?: ClaimsPrincipal;
    items?: { [key: string]: any; } | undefined;
    requestServices?: IServiceProvider;
    requestAborted?: CancellationToken;
    traceIdentifier?: string | undefined;
    session?: ISession;
}

export class HttpRequest implements IHttpRequest {
    httpContext?: HttpContext;
    method?: string | undefined;
    scheme?: string | undefined;
    isHttps?: boolean;
    host?: HostString;
    pathBase?: PathString;
    path?: PathString;
    queryString?: QueryString;
    query?: StringStringValuesKeyValuePair[] | undefined;
    protocol?: string | undefined;
    readonly headers?: { [key: string]: string[]; } | undefined;
    cookies?: StringStringKeyValuePair[] | undefined;
    contentLength?: number | undefined;
    contentType?: string | undefined;
    body?: Stream;
    bodyReader?: PipeReader;
    readonly hasFormContentType?: boolean;
    form?: StringStringValuesKeyValuePair[] | undefined;
    routeValues?: { [key: string]: any; } | undefined;

    constructor(data?: IHttpRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.httpContext = _data["HttpContext"] ? HttpContext.fromJS(_data["HttpContext"]) : <any>undefined;
            this.method = _data["Method"];
            this.scheme = _data["Scheme"];
            this.isHttps = _data["IsHttps"];
            this.host = _data["Host"] ? HostString.fromJS(_data["Host"]) : <any>undefined;
            this.pathBase = _data["PathBase"] ? PathString.fromJS(_data["PathBase"]) : <any>undefined;
            this.path = _data["Path"] ? PathString.fromJS(_data["Path"]) : <any>undefined;
            this.queryString = _data["QueryString"] ? QueryString.fromJS(_data["QueryString"]) : <any>undefined;
            if (Array.isArray(_data["Query"])) {
                this.query = [] as any;
                for (let item of _data["Query"])
                    this.query!.push(StringStringValuesKeyValuePair.fromJS(item));
            }
            this.protocol = _data["Protocol"];
            if (_data["Headers"]) {
                (<any>this).headers = {} as any;
                for (let key in _data["Headers"]) {
                    if (_data["Headers"].hasOwnProperty(key))
                        (<any>(<any>this).headers)![key] = _data["Headers"][key] !== undefined ? _data["Headers"][key] : [];
                }
            }
            if (Array.isArray(_data["Cookies"])) {
                this.cookies = [] as any;
                for (let item of _data["Cookies"])
                    this.cookies!.push(StringStringKeyValuePair.fromJS(item));
            }
            this.contentLength = _data["ContentLength"];
            this.contentType = _data["ContentType"];
            this.body = _data["Body"] ? Stream.fromJS(_data["Body"]) : <any>undefined;
            this.bodyReader = _data["BodyReader"] ? PipeReader.fromJS(_data["BodyReader"]) : <any>undefined;
            (<any>this).hasFormContentType = _data["HasFormContentType"];
            if (Array.isArray(_data["Form"])) {
                this.form = [] as any;
                for (let item of _data["Form"])
                    this.form!.push(StringStringValuesKeyValuePair.fromJS(item));
            }
            if (_data["RouteValues"]) {
                this.routeValues = {} as any;
                for (let key in _data["RouteValues"]) {
                    if (_data["RouteValues"].hasOwnProperty(key))
                        (<any>this.routeValues)![key] = _data["RouteValues"][key];
                }
            }
        }
    }

    static fromJS(data: any): HttpRequest {
        data = typeof data === 'object' ? data : {};
        let result = new HttpRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["HttpContext"] = this.httpContext ? this.httpContext.toJSON() : <any>undefined;
        data["Method"] = this.method;
        data["Scheme"] = this.scheme;
        data["IsHttps"] = this.isHttps;
        data["Host"] = this.host ? this.host.toJSON() : <any>undefined;
        data["PathBase"] = this.pathBase ? this.pathBase.toJSON() : <any>undefined;
        data["Path"] = this.path ? this.path.toJSON() : <any>undefined;
        data["QueryString"] = this.queryString ? this.queryString.toJSON() : <any>undefined;
        if (Array.isArray(this.query)) {
            data["Query"] = [];
            for (let item of this.query)
                data["Query"].push(item.toJSON());
        }
        data["Protocol"] = this.protocol;
        if (this.headers) {
            data["Headers"] = {};
            for (let key in this.headers) {
                if (this.headers.hasOwnProperty(key))
                    (<any>data["Headers"])[key] = this.headers[key];
            }
        }
        if (Array.isArray(this.cookies)) {
            data["Cookies"] = [];
            for (let item of this.cookies)
                data["Cookies"].push(item.toJSON());
        }
        data["ContentLength"] = this.contentLength;
        data["ContentType"] = this.contentType;
        data["Body"] = this.body ? this.body.toJSON() : <any>undefined;
        data["BodyReader"] = this.bodyReader ? this.bodyReader.toJSON() : <any>undefined;
        data["HasFormContentType"] = this.hasFormContentType;
        if (Array.isArray(this.form)) {
            data["Form"] = [];
            for (let item of this.form)
                data["Form"].push(item.toJSON());
        }
        if (this.routeValues) {
            data["RouteValues"] = {};
            for (let key in this.routeValues) {
                if (this.routeValues.hasOwnProperty(key))
                    (<any>data["RouteValues"])[key] = this.routeValues[key];
            }
        }
        return data;
    }
}

export interface IHttpRequest {
    httpContext?: HttpContext;
    method?: string | undefined;
    scheme?: string | undefined;
    isHttps?: boolean;
    host?: HostString;
    pathBase?: PathString;
    path?: PathString;
    queryString?: QueryString;
    query?: StringStringValuesKeyValuePair[] | undefined;
    protocol?: string | undefined;
    headers?: { [key: string]: string[]; } | undefined;
    cookies?: StringStringKeyValuePair[] | undefined;
    contentLength?: number | undefined;
    contentType?: string | undefined;
    body?: Stream;
    bodyReader?: PipeReader;
    hasFormContentType?: boolean;
    form?: StringStringValuesKeyValuePair[] | undefined;
    routeValues?: { [key: string]: any; } | undefined;
}

export class HttpResponse implements IHttpResponse {
    httpContext?: HttpContext;
    statusCode?: number;
    readonly headers?: { [key: string]: string[]; } | undefined;
    body?: Stream;
    bodyWriter?: PipeWriter;
    contentLength?: number | undefined;
    contentType?: string | undefined;
    cookies?: IResponseCookies;
    readonly hasStarted?: boolean;

    constructor(data?: IHttpResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.httpContext = _data["HttpContext"] ? HttpContext.fromJS(_data["HttpContext"]) : <any>undefined;
            this.statusCode = _data["StatusCode"];
            if (_data["Headers"]) {
                (<any>this).headers = {} as any;
                for (let key in _data["Headers"]) {
                    if (_data["Headers"].hasOwnProperty(key))
                        (<any>(<any>this).headers)![key] = _data["Headers"][key] !== undefined ? _data["Headers"][key] : [];
                }
            }
            this.body = _data["Body"] ? Stream.fromJS(_data["Body"]) : <any>undefined;
            this.bodyWriter = _data["BodyWriter"] ? PipeWriter.fromJS(_data["BodyWriter"]) : <any>undefined;
            this.contentLength = _data["ContentLength"];
            this.contentType = _data["ContentType"];
            this.cookies = _data["Cookies"] ? IResponseCookies.fromJS(_data["Cookies"]) : <any>undefined;
            (<any>this).hasStarted = _data["HasStarted"];
        }
    }

    static fromJS(data: any): HttpResponse {
        data = typeof data === 'object' ? data : {};
        let result = new HttpResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["HttpContext"] = this.httpContext ? this.httpContext.toJSON() : <any>undefined;
        data["StatusCode"] = this.statusCode;
        if (this.headers) {
            data["Headers"] = {};
            for (let key in this.headers) {
                if (this.headers.hasOwnProperty(key))
                    (<any>data["Headers"])[key] = this.headers[key];
            }
        }
        data["Body"] = this.body ? this.body.toJSON() : <any>undefined;
        data["BodyWriter"] = this.bodyWriter ? this.bodyWriter.toJSON() : <any>undefined;
        data["ContentLength"] = this.contentLength;
        data["ContentType"] = this.contentType;
        data["Cookies"] = this.cookies ? this.cookies.toJSON() : <any>undefined;
        data["HasStarted"] = this.hasStarted;
        return data;
    }
}

export interface IHttpResponse {
    httpContext?: HttpContext;
    statusCode?: number;
    headers?: { [key: string]: string[]; } | undefined;
    body?: Stream;
    bodyWriter?: PipeWriter;
    contentLength?: number | undefined;
    contentType?: string | undefined;
    cookies?: IResponseCookies;
    hasStarted?: boolean;
}

export class IActionConstraintMetadata implements IIActionConstraintMetadata {

    constructor(data?: IIActionConstraintMetadata) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): IActionConstraintMetadata {
        data = typeof data === 'object' ? data : {};
        let result = new IActionConstraintMetadata();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IIActionConstraintMetadata {
}

export class ICustomAttributeProvider implements IICustomAttributeProvider {

    constructor(data?: IICustomAttributeProvider) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): ICustomAttributeProvider {
        data = typeof data === 'object' ? data : {};
        let result = new ICustomAttributeProvider();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IICustomAttributeProvider {
}

export class IFilterMetadata implements IIFilterMetadata {

    constructor(data?: IIFilterMetadata) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): IFilterMetadata {
        data = typeof data === 'object' ? data : {};
        let result = new IFilterMetadata();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IIFilterMetadata {
}

export class IFormatProvider implements IIFormatProvider {

    constructor(data?: IIFormatProvider) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): IFormatProvider {
        data = typeof data === 'object' ? data : {};
        let result = new IFormatProvider();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IIFormatProvider {
}

export class IHtmlContent implements IIHtmlContent {

    constructor(data?: IIHtmlContent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): IHtmlContent {
        data = typeof data === 'object' ? data : {};
        let result = new IHtmlContent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IIHtmlContent {
}

export class IHtmlHelper implements IIHtmlHelper {
    html5DateRenderingMode?: Html5DateRenderingMode;
    readonly idAttributeDotReplacement?: string | undefined;
    metadataProvider?: IModelMetadataProvider;
    readonly viewBag?: any | undefined;
    viewContext?: ViewContext;
    readonly viewData?: { [key: string]: any; } | undefined;
    readonly tempData?: { [key: string]: any; } | undefined;
    urlEncoder?: UrlEncoder;

    constructor(data?: IIHtmlHelper) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.html5DateRenderingMode = _data["Html5DateRenderingMode"];
            (<any>this).idAttributeDotReplacement = _data["IdAttributeDotReplacement"];
            this.metadataProvider = _data["MetadataProvider"] ? IModelMetadataProvider.fromJS(_data["MetadataProvider"]) : <any>undefined;
            (<any>this).viewBag = _data["ViewBag"];
            this.viewContext = _data["ViewContext"] ? ViewContext.fromJS(_data["ViewContext"]) : <any>undefined;
            if (_data["ViewData"]) {
                (<any>this).viewData = {} as any;
                for (let key in _data["ViewData"]) {
                    if (_data["ViewData"].hasOwnProperty(key))
                        (<any>(<any>this).viewData)![key] = _data["ViewData"][key];
                }
            }
            if (_data["TempData"]) {
                (<any>this).tempData = {} as any;
                for (let key in _data["TempData"]) {
                    if (_data["TempData"].hasOwnProperty(key))
                        (<any>(<any>this).tempData)![key] = _data["TempData"][key];
                }
            }
            this.urlEncoder = _data["UrlEncoder"] ? UrlEncoder.fromJS(_data["UrlEncoder"]) : <any>undefined;
        }
    }

    static fromJS(data: any): IHtmlHelper {
        data = typeof data === 'object' ? data : {};
        let result = new IHtmlHelper();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Html5DateRenderingMode"] = this.html5DateRenderingMode;
        data["IdAttributeDotReplacement"] = this.idAttributeDotReplacement;
        data["MetadataProvider"] = this.metadataProvider ? this.metadataProvider.toJSON() : <any>undefined;
        data["ViewBag"] = this.viewBag;
        data["ViewContext"] = this.viewContext ? this.viewContext.toJSON() : <any>undefined;
        if (this.viewData) {
            data["ViewData"] = {};
            for (let key in this.viewData) {
                if (this.viewData.hasOwnProperty(key))
                    (<any>data["ViewData"])[key] = this.viewData[key];
            }
        }
        if (this.tempData) {
            data["TempData"] = {};
            for (let key in this.tempData) {
                if (this.tempData.hasOwnProperty(key))
                    (<any>data["TempData"])[key] = this.tempData[key];
            }
        }
        data["UrlEncoder"] = this.urlEncoder ? this.urlEncoder.toJSON() : <any>undefined;
        return data;
    }
}

export interface IIHtmlHelper {
    html5DateRenderingMode?: Html5DateRenderingMode;
    idAttributeDotReplacement?: string | undefined;
    metadataProvider?: IModelMetadataProvider;
    viewBag?: any | undefined;
    viewContext?: ViewContext;
    viewData?: { [key: string]: any; } | undefined;
    tempData?: { [key: string]: any; } | undefined;
    urlEncoder?: UrlEncoder;
}

export class IIdentity implements IIIdentity {
    readonly name?: string | undefined;
    readonly authenticationType?: string | undefined;
    readonly isAuthenticated?: boolean;

    constructor(data?: IIIdentity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).name = _data["Name"];
            (<any>this).authenticationType = _data["AuthenticationType"];
            (<any>this).isAuthenticated = _data["IsAuthenticated"];
        }
    }

    static fromJS(data: any): IIdentity {
        data = typeof data === 'object' ? data : {};
        let result = new IIdentity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Name"] = this.name;
        data["AuthenticationType"] = this.authenticationType;
        data["IsAuthenticated"] = this.isAuthenticated;
        return data;
    }
}

export interface IIIdentity {
    name?: string | undefined;
    authenticationType?: string | undefined;
    isAuthenticated?: boolean;
}

export class IJavaScriptInitializer implements IIJavaScriptInitializer {

    constructor(data?: IIJavaScriptInitializer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): IJavaScriptInitializer {
        data = typeof data === 'object' ? data : {};
        let result = new IJavaScriptInitializer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IIJavaScriptInitializer {
}

export class Iko01 implements IIko01 {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IIko01) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): Iko01 {
        data = typeof data === 'object' ? data : {};
        let result = new Iko01();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IIko01 {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class Iko02 implements IIko02 {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IIko02) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): Iko02 {
        data = typeof data === 'object' ? data : {};
        let result = new Iko02();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IIko02 {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class Iko03 implements IIko03 {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IIko03) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): Iko03 {
        data = typeof data === 'object' ? data : {};
        let result = new Iko03();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IIko03 {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class Iko04 implements IIko04 {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IIko04) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): Iko04 {
        data = typeof data === 'object' ? data : {};
        let result = new Iko04();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IIko04 {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class Iko05 implements IIko05 {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IIko05) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): Iko05 {
        data = typeof data === 'object' ? data : {};
        let result = new Iko05();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IIko05 {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class Iko06 implements IIko06 {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IIko06) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): Iko06 {
        data = typeof data === 'object' ? data : {};
        let result = new Iko06();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IIko06 {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class Iko07 implements IIko07 {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IIko07) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): Iko07 {
        data = typeof data === 'object' ? data : {};
        let result = new Iko07();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IIko07 {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class Iko08 implements IIko08 {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IIko08) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): Iko08 {
        data = typeof data === 'object' ? data : {};
        let result = new Iko08();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IIko08 {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class Iko09 implements IIko09 {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IIko09) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): Iko09 {
        data = typeof data === 'object' ? data : {};
        let result = new Iko09();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IIko09 {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class Iko10 implements IIko10 {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IIko10) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): Iko10 {
        data = typeof data === 'object' ? data : {};
        let result = new Iko10();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IIko10 {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class Iko11 implements IIko11 {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IIko11) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): Iko11 {
        data = typeof data === 'object' ? data : {};
        let result = new Iko11();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IIko11 {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class Iko12 implements IIko12 {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IIko12) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): Iko12 {
        data = typeof data === 'object' ? data : {};
        let result = new Iko12();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IIko12 {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class IModelMetadataProvider implements IIModelMetadataProvider {

    constructor(data?: IIModelMetadataProvider) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): IModelMetadataProvider {
        data = typeof data === 'object' ? data : {};
        let result = new IModelMetadataProvider();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IIModelMetadataProvider {
}

export class IntPtr implements IIntPtr {

    constructor(data?: IIntPtr) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): IntPtr {
        data = typeof data === 'object' ? data : {};
        let result = new IntPtr();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IIntPtr {
}

export class InvoiceStatus implements IInvoiceStatus {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;

    constructor(data?: IInvoiceStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.createdOn = _data["CreatedOn"] ? moment(_data["CreatedOn"].toString()) : <any>undefined;
            this.createdById = _data["CreatedById"];
            this.createdBy = _data["CreatedBy"] ? User.fromJS(_data["CreatedBy"]) : <any>undefined;
            this.updatedOn = _data["UpdatedOn"] ? moment(_data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedById = _data["UpdatedById"];
            this.updatedBy = _data["UpdatedBy"] ? User.fromJS(_data["UpdatedBy"]) : <any>undefined;
            this.deletedOn = _data["DeletedOn"] ? moment(_data["DeletedOn"].toString()) : <any>undefined;
            this.deletedById = _data["DeletedById"];
            this.deletedBy = _data["DeletedBy"] ? User.fromJS(_data["DeletedBy"]) : <any>undefined;
            this.isDeleted = _data["IsDeleted"];
            this.code = _data["Code"];
            this.description = _data["Description"];
            this.displayOrder = _data["DisplayOrder"];
            this.isActive = _data["IsActive"];
        }
    }

    static fromJS(data: any): InvoiceStatus {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedById"] = this.createdById;
        data["CreatedBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["DeletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        data["DeletedById"] = this.deletedById;
        data["DeletedBy"] = this.deletedBy ? this.deletedBy.toJSON() : <any>undefined;
        data["IsDeleted"] = this.isDeleted;
        data["Code"] = this.code;
        data["Description"] = this.description;
        data["DisplayOrder"] = this.displayOrder;
        data["IsActive"] = this.isActive;
        return data;
    }
}

export interface IInvoiceStatus {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;
}

export class IPAddress implements IIPAddress {
    addressFamily?: AddressFamily;
    scopeId?: number;
    readonly isIPv6Multicast?: boolean;
    readonly isIPv6LinkLocal?: boolean;
    readonly isIPv6SiteLocal?: boolean;
    readonly isIPv6Teredo?: boolean;
    readonly isIPv4MappedToIPv6?: boolean;
    address?: number;

    constructor(data?: IIPAddress) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.addressFamily = _data["AddressFamily"];
            this.scopeId = _data["ScopeId"];
            (<any>this).isIPv6Multicast = _data["IsIPv6Multicast"];
            (<any>this).isIPv6LinkLocal = _data["IsIPv6LinkLocal"];
            (<any>this).isIPv6SiteLocal = _data["IsIPv6SiteLocal"];
            (<any>this).isIPv6Teredo = _data["IsIPv6Teredo"];
            (<any>this).isIPv4MappedToIPv6 = _data["IsIPv4MappedToIPv6"];
            this.address = _data["Address"];
        }
    }

    static fromJS(data: any): IPAddress {
        data = typeof data === 'object' ? data : {};
        let result = new IPAddress();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["AddressFamily"] = this.addressFamily;
        data["ScopeId"] = this.scopeId;
        data["IsIPv6Multicast"] = this.isIPv6Multicast;
        data["IsIPv6LinkLocal"] = this.isIPv6LinkLocal;
        data["IsIPv6SiteLocal"] = this.isIPv6SiteLocal;
        data["IsIPv6Teredo"] = this.isIPv6Teredo;
        data["IsIPv4MappedToIPv6"] = this.isIPv4MappedToIPv6;
        data["Address"] = this.address;
        return data;
    }
}

export interface IIPAddress {
    addressFamily?: AddressFamily;
    scopeId?: number;
    isIPv6Multicast?: boolean;
    isIPv6LinkLocal?: boolean;
    isIPv6SiteLocal?: boolean;
    isIPv6Teredo?: boolean;
    isIPv4MappedToIPv6?: boolean;
    address?: number;
}

export class IPropertyFilterProvider implements IIPropertyFilterProvider {
    propertyFilter?: ModelMetadataBooleanFunc;

    constructor(data?: IIPropertyFilterProvider) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.propertyFilter = _data["PropertyFilter"] ? ModelMetadataBooleanFunc.fromJS(_data["PropertyFilter"]) : <any>undefined;
        }
    }

    static fromJS(data: any): IPropertyFilterProvider {
        data = typeof data === 'object' ? data : {};
        let result = new IPropertyFilterProvider();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["PropertyFilter"] = this.propertyFilter ? this.propertyFilter.toJSON() : <any>undefined;
        return data;
    }
}

export interface IIPropertyFilterProvider {
    propertyFilter?: ModelMetadataBooleanFunc;
}

export class IPropertyValidationFilter implements IIPropertyValidationFilter {

    constructor(data?: IIPropertyValidationFilter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): IPropertyValidationFilter {
        data = typeof data === 'object' ? data : {};
        let result = new IPropertyValidationFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IIPropertyValidationFilter {
}

export class IResponseCookies implements IIResponseCookies {

    constructor(data?: IIResponseCookies) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): IResponseCookies {
        data = typeof data === 'object' ? data : {};
        let result = new IResponseCookies();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IIResponseCookies {
}

export class IRouter implements IIRouter {

    constructor(data?: IIRouter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): IRouter {
        data = typeof data === 'object' ? data : {};
        let result = new IRouter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IIRouter {
}

export class IServiceProvider implements IIServiceProvider {

    constructor(data?: IIServiceProvider) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): IServiceProvider {
        data = typeof data === 'object' ? data : {};
        let result = new IServiceProvider();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IIServiceProvider {
}

export class ISession implements IISession {
    readonly isAvailable?: boolean;
    readonly id?: string | undefined;
    readonly keys?: string[] | undefined;

    constructor(data?: IISession) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isAvailable = _data["IsAvailable"];
            (<any>this).id = _data["Id"];
            if (Array.isArray(_data["Keys"])) {
                (<any>this).keys = [] as any;
                for (let item of _data["Keys"])
                    (<any>this).keys!.push(item);
            }
        }
    }

    static fromJS(data: any): ISession {
        data = typeof data === 'object' ? data : {};
        let result = new ISession();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["IsAvailable"] = this.isAvailable;
        data["Id"] = this.id;
        if (Array.isArray(this.keys)) {
            data["Keys"] = [];
            for (let item of this.keys)
                data["Keys"].push(item);
        }
        return data;
    }
}

export interface IISession {
    isAvailable?: boolean;
    id?: string | undefined;
    keys?: string[] | undefined;
}

export class IUrlGenerator implements IIUrlGenerator {

    constructor(data?: IIUrlGenerator) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): IUrlGenerator {
        data = typeof data === 'object' ? data : {};
        let result = new IUrlGenerator();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IIUrlGenerator {
}

export class IValueProvider implements IIValueProvider {

    constructor(data?: IIValueProvider) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): IValueProvider {
        data = typeof data === 'object' ? data : {};
        let result = new IValueProvider();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IIValueProvider {
}

export class IView implements IIView {
    readonly path?: string | undefined;

    constructor(data?: IIView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).path = _data["Path"];
        }
    }

    static fromJS(data: any): IView {
        data = typeof data === 'object' ? data : {};
        let result = new IView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Path"] = this.path;
        return data;
    }
}

export interface IIView {
    path?: string | undefined;
}

export class Jpy implements IJpy {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IJpy) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): Jpy {
        data = typeof data === 'object' ? data : {};
        let result = new Jpy();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IJpy {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class KeySizes implements IKeySizes {
    readonly minSize?: number;
    readonly maxSize?: number;
    readonly skipSize?: number;

    constructor(data?: IKeySizes) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).minSize = _data["MinSize"];
            (<any>this).maxSize = _data["MaxSize"];
            (<any>this).skipSize = _data["SkipSize"];
        }
    }

    static fromJS(data: any): KeySizes {
        data = typeof data === 'object' ? data : {};
        let result = new KeySizes();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["MinSize"] = this.minSize;
        data["MaxSize"] = this.maxSize;
        data["SkipSize"] = this.skipSize;
        return data;
    }
}

export interface IKeySizes {
    minSize?: number;
    maxSize?: number;
    skipSize?: number;
}

export class KnowledgeBase implements IKnowledgeBase {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    title!: string;
    subTitle?: string | undefined;
    slug?: string | undefined;
    metaKeywords?: string | undefined;
    metaDescription?: string | undefined;
    body?: string | undefined;
    mediaId?: number | undefined;
    media?: Media;
    isPublished?: boolean;
    publishedOn?: moment.Moment | undefined;
    publishedTill?: moment.Moment | undefined;
    categoryId?: number | undefined;
    category?: KnowledgeBaseCategory;

    constructor(data?: IKnowledgeBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.createdOn = _data["CreatedOn"] ? moment(_data["CreatedOn"].toString()) : <any>undefined;
            this.createdById = _data["CreatedById"];
            this.createdBy = _data["CreatedBy"] ? User.fromJS(_data["CreatedBy"]) : <any>undefined;
            this.updatedOn = _data["UpdatedOn"] ? moment(_data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedById = _data["UpdatedById"];
            this.updatedBy = _data["UpdatedBy"] ? User.fromJS(_data["UpdatedBy"]) : <any>undefined;
            this.deletedOn = _data["DeletedOn"] ? moment(_data["DeletedOn"].toString()) : <any>undefined;
            this.deletedById = _data["DeletedById"];
            this.deletedBy = _data["DeletedBy"] ? User.fromJS(_data["DeletedBy"]) : <any>undefined;
            this.isDeleted = _data["IsDeleted"];
            this.title = _data["Title"];
            this.subTitle = _data["SubTitle"];
            this.slug = _data["Slug"];
            this.metaKeywords = _data["MetaKeywords"];
            this.metaDescription = _data["MetaDescription"];
            this.body = _data["Body"];
            this.mediaId = _data["MediaId"];
            this.media = _data["Media"] ? Media.fromJS(_data["Media"]) : <any>undefined;
            this.isPublished = _data["IsPublished"];
            this.publishedOn = _data["PublishedOn"] ? moment(_data["PublishedOn"].toString()) : <any>undefined;
            this.publishedTill = _data["PublishedTill"] ? moment(_data["PublishedTill"].toString()) : <any>undefined;
            this.categoryId = _data["CategoryId"];
            this.category = _data["Category"] ? KnowledgeBaseCategory.fromJS(_data["Category"]) : <any>undefined;
        }
    }

    static fromJS(data: any): KnowledgeBase {
        data = typeof data === 'object' ? data : {};
        let result = new KnowledgeBase();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedById"] = this.createdById;
        data["CreatedBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["DeletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        data["DeletedById"] = this.deletedById;
        data["DeletedBy"] = this.deletedBy ? this.deletedBy.toJSON() : <any>undefined;
        data["IsDeleted"] = this.isDeleted;
        data["Title"] = this.title;
        data["SubTitle"] = this.subTitle;
        data["Slug"] = this.slug;
        data["MetaKeywords"] = this.metaKeywords;
        data["MetaDescription"] = this.metaDescription;
        data["Body"] = this.body;
        data["MediaId"] = this.mediaId;
        data["Media"] = this.media ? this.media.toJSON() : <any>undefined;
        data["IsPublished"] = this.isPublished;
        data["PublishedOn"] = this.publishedOn ? this.publishedOn.toISOString() : <any>undefined;
        data["PublishedTill"] = this.publishedTill ? this.publishedTill.toISOString() : <any>undefined;
        data["CategoryId"] = this.categoryId;
        data["Category"] = this.category ? this.category.toJSON() : <any>undefined;
        return data;
    }
}

export interface IKnowledgeBase {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    title: string;
    subTitle?: string | undefined;
    slug?: string | undefined;
    metaKeywords?: string | undefined;
    metaDescription?: string | undefined;
    body?: string | undefined;
    mediaId?: number | undefined;
    media?: Media;
    isPublished?: boolean;
    publishedOn?: moment.Moment | undefined;
    publishedTill?: moment.Moment | undefined;
    categoryId?: number | undefined;
    category?: KnowledgeBaseCategory;
}

export class KnowledgeBaseCategory implements IKnowledgeBaseCategory {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    name?: string | undefined;
    mediaId?: number | undefined;
    media?: Media;

    constructor(data?: IKnowledgeBaseCategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.createdOn = _data["CreatedOn"] ? moment(_data["CreatedOn"].toString()) : <any>undefined;
            this.createdById = _data["CreatedById"];
            this.createdBy = _data["CreatedBy"] ? User.fromJS(_data["CreatedBy"]) : <any>undefined;
            this.updatedOn = _data["UpdatedOn"] ? moment(_data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedById = _data["UpdatedById"];
            this.updatedBy = _data["UpdatedBy"] ? User.fromJS(_data["UpdatedBy"]) : <any>undefined;
            this.deletedOn = _data["DeletedOn"] ? moment(_data["DeletedOn"].toString()) : <any>undefined;
            this.deletedById = _data["DeletedById"];
            this.deletedBy = _data["DeletedBy"] ? User.fromJS(_data["DeletedBy"]) : <any>undefined;
            this.isDeleted = _data["IsDeleted"];
            this.name = _data["Name"];
            this.mediaId = _data["MediaId"];
            this.media = _data["Media"] ? Media.fromJS(_data["Media"]) : <any>undefined;
        }
    }

    static fromJS(data: any): KnowledgeBaseCategory {
        data = typeof data === 'object' ? data : {};
        let result = new KnowledgeBaseCategory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedById"] = this.createdById;
        data["CreatedBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["DeletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        data["DeletedById"] = this.deletedById;
        data["DeletedBy"] = this.deletedBy ? this.deletedBy.toJSON() : <any>undefined;
        data["IsDeleted"] = this.isDeleted;
        data["Name"] = this.name;
        data["MediaId"] = this.mediaId;
        data["Media"] = this.media ? this.media.toJSON() : <any>undefined;
        return data;
    }
}

export interface IKnowledgeBaseCategory {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    name?: string | undefined;
    mediaId?: number | undefined;
    media?: Media;
}

export enum LayoutKind {
    _0 = 0,
    _2 = 2,
    _3 = 3,
}

export class MarketModel implements IMarketModel {
    altin?: Altin;
    altingr?: Altingr;
    altinkgtl?: Altinkgtl;
    altinkgusd?: Altinkgusd;
    ons?: Ons;
    gumusserbest?: Gumusserbest;
    gumususd?: Gumususd;
    gumuseur?: Gumuseur;
    gumus?: Gumus;
    altinusd?: Altinusd;
    altincum?: Altincum;
    altingldt?: Altingldt;
    altingldy?: Altingldy;
    altingldc?: Altingldc;
    altinres?: Altinres;
    altinresk?: Altinresk;
    usd?: Usd;
    euro?: Euro;
    eurtry?: Eurtry;
    gbp?: Gbp;
    jpy?: Jpy;
    cad?: Cad;
    aud?: Aud;
    nok?: Nok;
    dkk?: Dkk;
    sek?: Sek;
    sar?: Sar;
    chf?: Chf;
    platin?: Platin;
    paladyum?: Paladyum;
    cyp?: Cyp;
    gumusfix?: Gumusfix;
    altinfixUsdAm?: AltinfixUsdAm;
    altinfixUsdPm?: AltinfixUsdPm;
    altinfixEurAm?: AltinfixEurAm;
    altinfixEurPm?: AltinfixEurPm;
    altinfixGbpAm?: AltinfixGbpAm;
    altinfixGbpPm?: AltinfixGbpPm;
    platinfixAm?: PlatinfixAm;
    platinfixPm?: PlatinfixPm;
    paladyumfixAm?: PaladyumfixAm;
    paladyumfixPm?: PaladyumfixPm;
    rodyumfix?: Rodyumfix;
    iko01?: Iko01;
    iko02?: Iko02;
    iko03?: Iko03;
    iko04?: Iko04;
    iko05?: Iko05;
    iko06?: Iko06;
    iko07?: Iko07;
    iko08?: Iko08;
    iko09?: Iko09;
    iko10?: Iko10;
    iko11?: Iko11;
    iko12?: Iko12;

    constructor(data?: IMarketModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.altin = _data["Altin"] ? Altin.fromJS(_data["Altin"]) : <any>undefined;
            this.altingr = _data["Altingr"] ? Altingr.fromJS(_data["Altingr"]) : <any>undefined;
            this.altinkgtl = _data["Altinkgtl"] ? Altinkgtl.fromJS(_data["Altinkgtl"]) : <any>undefined;
            this.altinkgusd = _data["Altinkgusd"] ? Altinkgusd.fromJS(_data["Altinkgusd"]) : <any>undefined;
            this.ons = _data["Ons"] ? Ons.fromJS(_data["Ons"]) : <any>undefined;
            this.gumusserbest = _data["Gumusserbest"] ? Gumusserbest.fromJS(_data["Gumusserbest"]) : <any>undefined;
            this.gumususd = _data["Gumususd"] ? Gumususd.fromJS(_data["Gumususd"]) : <any>undefined;
            this.gumuseur = _data["Gumuseur"] ? Gumuseur.fromJS(_data["Gumuseur"]) : <any>undefined;
            this.gumus = _data["Gumus"] ? Gumus.fromJS(_data["Gumus"]) : <any>undefined;
            this.altinusd = _data["Altinusd"] ? Altinusd.fromJS(_data["Altinusd"]) : <any>undefined;
            this.altincum = _data["Altincum"] ? Altincum.fromJS(_data["Altincum"]) : <any>undefined;
            this.altingldt = _data["Altingldt"] ? Altingldt.fromJS(_data["Altingldt"]) : <any>undefined;
            this.altingldy = _data["Altingldy"] ? Altingldy.fromJS(_data["Altingldy"]) : <any>undefined;
            this.altingldc = _data["Altingldc"] ? Altingldc.fromJS(_data["Altingldc"]) : <any>undefined;
            this.altinres = _data["Altinres"] ? Altinres.fromJS(_data["Altinres"]) : <any>undefined;
            this.altinresk = _data["Altinresk"] ? Altinresk.fromJS(_data["Altinresk"]) : <any>undefined;
            this.usd = _data["Usd"] ? Usd.fromJS(_data["Usd"]) : <any>undefined;
            this.euro = _data["Euro"] ? Euro.fromJS(_data["Euro"]) : <any>undefined;
            this.eurtry = _data["Eurtry"] ? Eurtry.fromJS(_data["Eurtry"]) : <any>undefined;
            this.gbp = _data["Gbp"] ? Gbp.fromJS(_data["Gbp"]) : <any>undefined;
            this.jpy = _data["Jpy"] ? Jpy.fromJS(_data["Jpy"]) : <any>undefined;
            this.cad = _data["Cad"] ? Cad.fromJS(_data["Cad"]) : <any>undefined;
            this.aud = _data["Aud"] ? Aud.fromJS(_data["Aud"]) : <any>undefined;
            this.nok = _data["Nok"] ? Nok.fromJS(_data["Nok"]) : <any>undefined;
            this.dkk = _data["Dkk"] ? Dkk.fromJS(_data["Dkk"]) : <any>undefined;
            this.sek = _data["Sek"] ? Sek.fromJS(_data["Sek"]) : <any>undefined;
            this.sar = _data["Sar"] ? Sar.fromJS(_data["Sar"]) : <any>undefined;
            this.chf = _data["Chf"] ? Chf.fromJS(_data["Chf"]) : <any>undefined;
            this.platin = _data["Platin"] ? Platin.fromJS(_data["Platin"]) : <any>undefined;
            this.paladyum = _data["Paladyum"] ? Paladyum.fromJS(_data["Paladyum"]) : <any>undefined;
            this.cyp = _data["Cyp"] ? Cyp.fromJS(_data["Cyp"]) : <any>undefined;
            this.gumusfix = _data["Gumusfix"] ? Gumusfix.fromJS(_data["Gumusfix"]) : <any>undefined;
            this.altinfixUsdAm = _data["AltinfixUsdAm"] ? AltinfixUsdAm.fromJS(_data["AltinfixUsdAm"]) : <any>undefined;
            this.altinfixUsdPm = _data["AltinfixUsdPm"] ? AltinfixUsdPm.fromJS(_data["AltinfixUsdPm"]) : <any>undefined;
            this.altinfixEurAm = _data["AltinfixEurAm"] ? AltinfixEurAm.fromJS(_data["AltinfixEurAm"]) : <any>undefined;
            this.altinfixEurPm = _data["AltinfixEurPm"] ? AltinfixEurPm.fromJS(_data["AltinfixEurPm"]) : <any>undefined;
            this.altinfixGbpAm = _data["AltinfixGbpAm"] ? AltinfixGbpAm.fromJS(_data["AltinfixGbpAm"]) : <any>undefined;
            this.altinfixGbpPm = _data["AltinfixGbpPm"] ? AltinfixGbpPm.fromJS(_data["AltinfixGbpPm"]) : <any>undefined;
            this.platinfixAm = _data["PlatinfixAm"] ? PlatinfixAm.fromJS(_data["PlatinfixAm"]) : <any>undefined;
            this.platinfixPm = _data["PlatinfixPm"] ? PlatinfixPm.fromJS(_data["PlatinfixPm"]) : <any>undefined;
            this.paladyumfixAm = _data["PaladyumfixAm"] ? PaladyumfixAm.fromJS(_data["PaladyumfixAm"]) : <any>undefined;
            this.paladyumfixPm = _data["PaladyumfixPm"] ? PaladyumfixPm.fromJS(_data["PaladyumfixPm"]) : <any>undefined;
            this.rodyumfix = _data["Rodyumfix"] ? Rodyumfix.fromJS(_data["Rodyumfix"]) : <any>undefined;
            this.iko01 = _data["Iko01"] ? Iko01.fromJS(_data["Iko01"]) : <any>undefined;
            this.iko02 = _data["Iko02"] ? Iko02.fromJS(_data["Iko02"]) : <any>undefined;
            this.iko03 = _data["Iko03"] ? Iko03.fromJS(_data["Iko03"]) : <any>undefined;
            this.iko04 = _data["Iko04"] ? Iko04.fromJS(_data["Iko04"]) : <any>undefined;
            this.iko05 = _data["Iko05"] ? Iko05.fromJS(_data["Iko05"]) : <any>undefined;
            this.iko06 = _data["Iko06"] ? Iko06.fromJS(_data["Iko06"]) : <any>undefined;
            this.iko07 = _data["Iko07"] ? Iko07.fromJS(_data["Iko07"]) : <any>undefined;
            this.iko08 = _data["Iko08"] ? Iko08.fromJS(_data["Iko08"]) : <any>undefined;
            this.iko09 = _data["Iko09"] ? Iko09.fromJS(_data["Iko09"]) : <any>undefined;
            this.iko10 = _data["Iko10"] ? Iko10.fromJS(_data["Iko10"]) : <any>undefined;
            this.iko11 = _data["Iko11"] ? Iko11.fromJS(_data["Iko11"]) : <any>undefined;
            this.iko12 = _data["Iko12"] ? Iko12.fromJS(_data["Iko12"]) : <any>undefined;
        }
    }

    static fromJS(data: any): MarketModel {
        data = typeof data === 'object' ? data : {};
        let result = new MarketModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Altin"] = this.altin ? this.altin.toJSON() : <any>undefined;
        data["Altingr"] = this.altingr ? this.altingr.toJSON() : <any>undefined;
        data["Altinkgtl"] = this.altinkgtl ? this.altinkgtl.toJSON() : <any>undefined;
        data["Altinkgusd"] = this.altinkgusd ? this.altinkgusd.toJSON() : <any>undefined;
        data["Ons"] = this.ons ? this.ons.toJSON() : <any>undefined;
        data["Gumusserbest"] = this.gumusserbest ? this.gumusserbest.toJSON() : <any>undefined;
        data["Gumususd"] = this.gumususd ? this.gumususd.toJSON() : <any>undefined;
        data["Gumuseur"] = this.gumuseur ? this.gumuseur.toJSON() : <any>undefined;
        data["Gumus"] = this.gumus ? this.gumus.toJSON() : <any>undefined;
        data["Altinusd"] = this.altinusd ? this.altinusd.toJSON() : <any>undefined;
        data["Altincum"] = this.altincum ? this.altincum.toJSON() : <any>undefined;
        data["Altingldt"] = this.altingldt ? this.altingldt.toJSON() : <any>undefined;
        data["Altingldy"] = this.altingldy ? this.altingldy.toJSON() : <any>undefined;
        data["Altingldc"] = this.altingldc ? this.altingldc.toJSON() : <any>undefined;
        data["Altinres"] = this.altinres ? this.altinres.toJSON() : <any>undefined;
        data["Altinresk"] = this.altinresk ? this.altinresk.toJSON() : <any>undefined;
        data["Usd"] = this.usd ? this.usd.toJSON() : <any>undefined;
        data["Euro"] = this.euro ? this.euro.toJSON() : <any>undefined;
        data["Eurtry"] = this.eurtry ? this.eurtry.toJSON() : <any>undefined;
        data["Gbp"] = this.gbp ? this.gbp.toJSON() : <any>undefined;
        data["Jpy"] = this.jpy ? this.jpy.toJSON() : <any>undefined;
        data["Cad"] = this.cad ? this.cad.toJSON() : <any>undefined;
        data["Aud"] = this.aud ? this.aud.toJSON() : <any>undefined;
        data["Nok"] = this.nok ? this.nok.toJSON() : <any>undefined;
        data["Dkk"] = this.dkk ? this.dkk.toJSON() : <any>undefined;
        data["Sek"] = this.sek ? this.sek.toJSON() : <any>undefined;
        data["Sar"] = this.sar ? this.sar.toJSON() : <any>undefined;
        data["Chf"] = this.chf ? this.chf.toJSON() : <any>undefined;
        data["Platin"] = this.platin ? this.platin.toJSON() : <any>undefined;
        data["Paladyum"] = this.paladyum ? this.paladyum.toJSON() : <any>undefined;
        data["Cyp"] = this.cyp ? this.cyp.toJSON() : <any>undefined;
        data["Gumusfix"] = this.gumusfix ? this.gumusfix.toJSON() : <any>undefined;
        data["AltinfixUsdAm"] = this.altinfixUsdAm ? this.altinfixUsdAm.toJSON() : <any>undefined;
        data["AltinfixUsdPm"] = this.altinfixUsdPm ? this.altinfixUsdPm.toJSON() : <any>undefined;
        data["AltinfixEurAm"] = this.altinfixEurAm ? this.altinfixEurAm.toJSON() : <any>undefined;
        data["AltinfixEurPm"] = this.altinfixEurPm ? this.altinfixEurPm.toJSON() : <any>undefined;
        data["AltinfixGbpAm"] = this.altinfixGbpAm ? this.altinfixGbpAm.toJSON() : <any>undefined;
        data["AltinfixGbpPm"] = this.altinfixGbpPm ? this.altinfixGbpPm.toJSON() : <any>undefined;
        data["PlatinfixAm"] = this.platinfixAm ? this.platinfixAm.toJSON() : <any>undefined;
        data["PlatinfixPm"] = this.platinfixPm ? this.platinfixPm.toJSON() : <any>undefined;
        data["PaladyumfixAm"] = this.paladyumfixAm ? this.paladyumfixAm.toJSON() : <any>undefined;
        data["PaladyumfixPm"] = this.paladyumfixPm ? this.paladyumfixPm.toJSON() : <any>undefined;
        data["Rodyumfix"] = this.rodyumfix ? this.rodyumfix.toJSON() : <any>undefined;
        data["Iko01"] = this.iko01 ? this.iko01.toJSON() : <any>undefined;
        data["Iko02"] = this.iko02 ? this.iko02.toJSON() : <any>undefined;
        data["Iko03"] = this.iko03 ? this.iko03.toJSON() : <any>undefined;
        data["Iko04"] = this.iko04 ? this.iko04.toJSON() : <any>undefined;
        data["Iko05"] = this.iko05 ? this.iko05.toJSON() : <any>undefined;
        data["Iko06"] = this.iko06 ? this.iko06.toJSON() : <any>undefined;
        data["Iko07"] = this.iko07 ? this.iko07.toJSON() : <any>undefined;
        data["Iko08"] = this.iko08 ? this.iko08.toJSON() : <any>undefined;
        data["Iko09"] = this.iko09 ? this.iko09.toJSON() : <any>undefined;
        data["Iko10"] = this.iko10 ? this.iko10.toJSON() : <any>undefined;
        data["Iko11"] = this.iko11 ? this.iko11.toJSON() : <any>undefined;
        data["Iko12"] = this.iko12 ? this.iko12.toJSON() : <any>undefined;
        return data;
    }
}

export interface IMarketModel {
    altin?: Altin;
    altingr?: Altingr;
    altinkgtl?: Altinkgtl;
    altinkgusd?: Altinkgusd;
    ons?: Ons;
    gumusserbest?: Gumusserbest;
    gumususd?: Gumususd;
    gumuseur?: Gumuseur;
    gumus?: Gumus;
    altinusd?: Altinusd;
    altincum?: Altincum;
    altingldt?: Altingldt;
    altingldy?: Altingldy;
    altingldc?: Altingldc;
    altinres?: Altinres;
    altinresk?: Altinresk;
    usd?: Usd;
    euro?: Euro;
    eurtry?: Eurtry;
    gbp?: Gbp;
    jpy?: Jpy;
    cad?: Cad;
    aud?: Aud;
    nok?: Nok;
    dkk?: Dkk;
    sek?: Sek;
    sar?: Sar;
    chf?: Chf;
    platin?: Platin;
    paladyum?: Paladyum;
    cyp?: Cyp;
    gumusfix?: Gumusfix;
    altinfixUsdAm?: AltinfixUsdAm;
    altinfixUsdPm?: AltinfixUsdPm;
    altinfixEurAm?: AltinfixEurAm;
    altinfixEurPm?: AltinfixEurPm;
    altinfixGbpAm?: AltinfixGbpAm;
    altinfixGbpPm?: AltinfixGbpPm;
    platinfixAm?: PlatinfixAm;
    platinfixPm?: PlatinfixPm;
    paladyumfixAm?: PaladyumfixAm;
    paladyumfixPm?: PaladyumfixPm;
    rodyumfix?: Rodyumfix;
    iko01?: Iko01;
    iko02?: Iko02;
    iko03?: Iko03;
    iko04?: Iko04;
    iko05?: Iko05;
    iko06?: Iko06;
    iko07?: Iko07;
    iko08?: Iko08;
    iko09?: Iko09;
    iko10?: Iko10;
    iko11?: Iko11;
    iko12?: Iko12;
}

export class MatriksEconomyNewsModel implements IMatriksEconomyNewsModel {
    data?: Data;
    error?: ErrorDto;

    constructor(data?: IMatriksEconomyNewsModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["Data"] ? Data.fromJS(_data["Data"]) : <any>undefined;
            this.error = _data["Error"] ? ErrorDto.fromJS(_data["Error"]) : <any>undefined;
        }
    }

    static fromJS(data: any): MatriksEconomyNewsModel {
        data = typeof data === 'object' ? data : {};
        let result = new MatriksEconomyNewsModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["Error"] = this.error ? this.error.toJSON() : <any>undefined;
        return data;
    }
}

export interface IMatriksEconomyNewsModel {
    data?: Data;
    error?: ErrorDto;
}

export class MatriksNewsModel implements IMatriksNewsModel {
    data?: MatriksNewsModelData[] | undefined;

    constructor(data?: IMatriksNewsModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["Data"])) {
                this.data = [] as any;
                for (let item of _data["Data"])
                    this.data!.push(MatriksNewsModelData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MatriksNewsModel {
        data = typeof data === 'object' ? data : {};
        let result = new MatriksNewsModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["Data"] = [];
            for (let item of this.data)
                data["Data"].push(item.toJSON());
        }
        return data;
    }
}

export interface IMatriksNewsModel {
    data?: MatriksNewsModelData[] | undefined;
}

export class MatriksNewsModelData implements IMatriksNewsModelData {
    id?: string | undefined;
    kaynak?: string | undefined;
    tip?: string | undefined;
    haberno?: string | undefined;
    baslik?: string | undefined;
    icerik?: string | undefined;
    tarih?: string | undefined;
    c?: string | undefined;

    constructor(data?: IMatriksNewsModelData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.kaynak = _data["Kaynak"];
            this.tip = _data["Tip"];
            this.haberno = _data["Haberno"];
            this.baslik = _data["Baslik"];
            this.icerik = _data["Icerik"];
            this.tarih = _data["Tarih"];
            this.c = _data["C"];
        }
    }

    static fromJS(data: any): MatriksNewsModelData {
        data = typeof data === 'object' ? data : {};
        let result = new MatriksNewsModelData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Kaynak"] = this.kaynak;
        data["Tip"] = this.tip;
        data["Haberno"] = this.haberno;
        data["Baslik"] = this.baslik;
        data["Icerik"] = this.icerik;
        data["Tarih"] = this.tarih;
        data["C"] = this.c;
        return data;
    }
}

export interface IMatriksNewsModelData {
    id?: string | undefined;
    kaynak?: string | undefined;
    tip?: string | undefined;
    haberno?: string | undefined;
    baslik?: string | undefined;
    icerik?: string | undefined;
    tarih?: string | undefined;
    c?: string | undefined;
}

export class Media implements IMedia {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    caption?: string | undefined;
    fileSize?: number;
    fileName?: string | undefined;
    mediaTypeId?: number;
    mediaType?: MediaType;

    constructor(data?: IMedia) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.createdOn = _data["CreatedOn"] ? moment(_data["CreatedOn"].toString()) : <any>undefined;
            this.createdById = _data["CreatedById"];
            this.createdBy = _data["CreatedBy"] ? User.fromJS(_data["CreatedBy"]) : <any>undefined;
            this.updatedOn = _data["UpdatedOn"] ? moment(_data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedById = _data["UpdatedById"];
            this.updatedBy = _data["UpdatedBy"] ? User.fromJS(_data["UpdatedBy"]) : <any>undefined;
            this.deletedOn = _data["DeletedOn"] ? moment(_data["DeletedOn"].toString()) : <any>undefined;
            this.deletedById = _data["DeletedById"];
            this.deletedBy = _data["DeletedBy"] ? User.fromJS(_data["DeletedBy"]) : <any>undefined;
            this.isDeleted = _data["IsDeleted"];
            this.caption = _data["Caption"];
            this.fileSize = _data["FileSize"];
            this.fileName = _data["FileName"];
            this.mediaTypeId = _data["MediaTypeId"];
            this.mediaType = _data["MediaType"] ? MediaType.fromJS(_data["MediaType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Media {
        data = typeof data === 'object' ? data : {};
        let result = new Media();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedById"] = this.createdById;
        data["CreatedBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["DeletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        data["DeletedById"] = this.deletedById;
        data["DeletedBy"] = this.deletedBy ? this.deletedBy.toJSON() : <any>undefined;
        data["IsDeleted"] = this.isDeleted;
        data["Caption"] = this.caption;
        data["FileSize"] = this.fileSize;
        data["FileName"] = this.fileName;
        data["MediaTypeId"] = this.mediaTypeId;
        data["MediaType"] = this.mediaType ? this.mediaType.toJSON() : <any>undefined;
        return data;
    }
}

export interface IMedia {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    caption?: string | undefined;
    fileSize?: number;
    fileName?: string | undefined;
    mediaTypeId?: number;
    mediaType?: MediaType;
}

export class MediaType implements IMediaType {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;

    constructor(data?: IMediaType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.createdOn = _data["CreatedOn"] ? moment(_data["CreatedOn"].toString()) : <any>undefined;
            this.createdById = _data["CreatedById"];
            this.createdBy = _data["CreatedBy"] ? User.fromJS(_data["CreatedBy"]) : <any>undefined;
            this.updatedOn = _data["UpdatedOn"] ? moment(_data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedById = _data["UpdatedById"];
            this.updatedBy = _data["UpdatedBy"] ? User.fromJS(_data["UpdatedBy"]) : <any>undefined;
            this.deletedOn = _data["DeletedOn"] ? moment(_data["DeletedOn"].toString()) : <any>undefined;
            this.deletedById = _data["DeletedById"];
            this.deletedBy = _data["DeletedBy"] ? User.fromJS(_data["DeletedBy"]) : <any>undefined;
            this.isDeleted = _data["IsDeleted"];
            this.code = _data["Code"];
            this.description = _data["Description"];
            this.displayOrder = _data["DisplayOrder"];
            this.isActive = _data["IsActive"];
        }
    }

    static fromJS(data: any): MediaType {
        data = typeof data === 'object' ? data : {};
        let result = new MediaType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedById"] = this.createdById;
        data["CreatedBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["DeletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        data["DeletedById"] = this.deletedById;
        data["DeletedBy"] = this.deletedBy ? this.deletedBy.toJSON() : <any>undefined;
        data["IsDeleted"] = this.isDeleted;
        data["Code"] = this.code;
        data["Description"] = this.description;
        data["DisplayOrder"] = this.displayOrder;
        data["IsActive"] = this.isActive;
        return data;
    }
}

export interface IMediaType {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;
}

export class MemberInfo implements IMemberInfo {
    memberType?: MemberTypes;
    declaringType?: Type;
    reflectedType?: Type;
    readonly name?: string | undefined;
    module?: Module;
    readonly customAttributes?: CustomAttributeData[] | undefined;
    readonly isCollectible?: boolean;
    readonly metadataToken?: number;

    constructor(data?: IMemberInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberType = _data["MemberType"];
            this.declaringType = _data["DeclaringType"] ? Type.fromJS(_data["DeclaringType"]) : <any>undefined;
            this.reflectedType = _data["ReflectedType"] ? Type.fromJS(_data["ReflectedType"]) : <any>undefined;
            (<any>this).name = _data["Name"];
            this.module = _data["Module"] ? Module.fromJS(_data["Module"]) : <any>undefined;
            if (Array.isArray(_data["CustomAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["CustomAttributes"])
                    (<any>this).customAttributes!.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).isCollectible = _data["IsCollectible"];
            (<any>this).metadataToken = _data["MetadataToken"];
        }
    }

    static fromJS(data: any): MemberInfo {
        data = typeof data === 'object' ? data : {};
        let result = new MemberInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["MemberType"] = this.memberType;
        data["DeclaringType"] = this.declaringType ? this.declaringType.toJSON() : <any>undefined;
        data["ReflectedType"] = this.reflectedType ? this.reflectedType.toJSON() : <any>undefined;
        data["Name"] = this.name;
        data["Module"] = this.module ? this.module.toJSON() : <any>undefined;
        if (Array.isArray(this.customAttributes)) {
            data["CustomAttributes"] = [];
            for (let item of this.customAttributes)
                data["CustomAttributes"].push(item.toJSON());
        }
        data["IsCollectible"] = this.isCollectible;
        data["MetadataToken"] = this.metadataToken;
        return data;
    }
}

export interface IMemberInfo {
    memberType?: MemberTypes;
    declaringType?: Type;
    reflectedType?: Type;
    name?: string | undefined;
    module?: Module;
    customAttributes?: CustomAttributeData[] | undefined;
    isCollectible?: boolean;
    metadataToken?: number;
}

export enum MemberTypes {
    _1 = 1,
    _2 = 2,
    _4 = 4,
    _8 = 8,
    _16 = 16,
    _32 = 32,
    _64 = 64,
    _128 = 128,
    _191 = 191,
}

export enum MethodAttributes {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _8 = 8,
    _16 = 16,
    _32 = 32,
    _64 = 64,
    _128 = 128,
    _256 = 256,
    _512 = 512,
    _1024 = 1024,
    _2048 = 2048,
    _4096 = 4096,
    _8192 = 8192,
    _16384 = 16384,
    _32768 = 32768,
    _53248 = 53248,
}

export class MethodBase implements IMethodBase {
    memberType?: MemberTypes;
    readonly name?: string | undefined;
    declaringType?: Type;
    reflectedType?: Type;
    module?: Module;
    readonly customAttributes?: CustomAttributeData[] | undefined;
    readonly isCollectible?: boolean;
    readonly metadataToken?: number;
    attributes?: MethodAttributes;
    methodImplementationFlags?: MethodImplAttributes;
    callingConvention?: CallingConventions;
    readonly isAbstract?: boolean;
    readonly isConstructor?: boolean;
    readonly isFinal?: boolean;
    readonly isHideBySig?: boolean;
    readonly isSpecialName?: boolean;
    readonly isStatic?: boolean;
    readonly isVirtual?: boolean;
    readonly isAssembly?: boolean;
    readonly isFamily?: boolean;
    readonly isFamilyAndAssembly?: boolean;
    readonly isFamilyOrAssembly?: boolean;
    readonly isPrivate?: boolean;
    readonly isPublic?: boolean;
    readonly isConstructedGenericMethod?: boolean;
    readonly isGenericMethod?: boolean;
    readonly isGenericMethodDefinition?: boolean;
    readonly containsGenericParameters?: boolean;
    methodHandle?: RuntimeMethodHandle;
    readonly isSecurityCritical?: boolean;
    readonly isSecuritySafeCritical?: boolean;
    readonly isSecurityTransparent?: boolean;

    constructor(data?: IMethodBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberType = _data["MemberType"];
            (<any>this).name = _data["Name"];
            this.declaringType = _data["DeclaringType"] ? Type.fromJS(_data["DeclaringType"]) : <any>undefined;
            this.reflectedType = _data["ReflectedType"] ? Type.fromJS(_data["ReflectedType"]) : <any>undefined;
            this.module = _data["Module"] ? Module.fromJS(_data["Module"]) : <any>undefined;
            if (Array.isArray(_data["CustomAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["CustomAttributes"])
                    (<any>this).customAttributes!.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).isCollectible = _data["IsCollectible"];
            (<any>this).metadataToken = _data["MetadataToken"];
            this.attributes = _data["Attributes"];
            this.methodImplementationFlags = _data["MethodImplementationFlags"];
            this.callingConvention = _data["CallingConvention"];
            (<any>this).isAbstract = _data["IsAbstract"];
            (<any>this).isConstructor = _data["IsConstructor"];
            (<any>this).isFinal = _data["IsFinal"];
            (<any>this).isHideBySig = _data["IsHideBySig"];
            (<any>this).isSpecialName = _data["IsSpecialName"];
            (<any>this).isStatic = _data["IsStatic"];
            (<any>this).isVirtual = _data["IsVirtual"];
            (<any>this).isAssembly = _data["IsAssembly"];
            (<any>this).isFamily = _data["IsFamily"];
            (<any>this).isFamilyAndAssembly = _data["IsFamilyAndAssembly"];
            (<any>this).isFamilyOrAssembly = _data["IsFamilyOrAssembly"];
            (<any>this).isPrivate = _data["IsPrivate"];
            (<any>this).isPublic = _data["IsPublic"];
            (<any>this).isConstructedGenericMethod = _data["IsConstructedGenericMethod"];
            (<any>this).isGenericMethod = _data["IsGenericMethod"];
            (<any>this).isGenericMethodDefinition = _data["IsGenericMethodDefinition"];
            (<any>this).containsGenericParameters = _data["ContainsGenericParameters"];
            this.methodHandle = _data["MethodHandle"] ? RuntimeMethodHandle.fromJS(_data["MethodHandle"]) : <any>undefined;
            (<any>this).isSecurityCritical = _data["IsSecurityCritical"];
            (<any>this).isSecuritySafeCritical = _data["IsSecuritySafeCritical"];
            (<any>this).isSecurityTransparent = _data["IsSecurityTransparent"];
        }
    }

    static fromJS(data: any): MethodBase {
        data = typeof data === 'object' ? data : {};
        let result = new MethodBase();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["MemberType"] = this.memberType;
        data["Name"] = this.name;
        data["DeclaringType"] = this.declaringType ? this.declaringType.toJSON() : <any>undefined;
        data["ReflectedType"] = this.reflectedType ? this.reflectedType.toJSON() : <any>undefined;
        data["Module"] = this.module ? this.module.toJSON() : <any>undefined;
        if (Array.isArray(this.customAttributes)) {
            data["CustomAttributes"] = [];
            for (let item of this.customAttributes)
                data["CustomAttributes"].push(item.toJSON());
        }
        data["IsCollectible"] = this.isCollectible;
        data["MetadataToken"] = this.metadataToken;
        data["Attributes"] = this.attributes;
        data["MethodImplementationFlags"] = this.methodImplementationFlags;
        data["CallingConvention"] = this.callingConvention;
        data["IsAbstract"] = this.isAbstract;
        data["IsConstructor"] = this.isConstructor;
        data["IsFinal"] = this.isFinal;
        data["IsHideBySig"] = this.isHideBySig;
        data["IsSpecialName"] = this.isSpecialName;
        data["IsStatic"] = this.isStatic;
        data["IsVirtual"] = this.isVirtual;
        data["IsAssembly"] = this.isAssembly;
        data["IsFamily"] = this.isFamily;
        data["IsFamilyAndAssembly"] = this.isFamilyAndAssembly;
        data["IsFamilyOrAssembly"] = this.isFamilyOrAssembly;
        data["IsPrivate"] = this.isPrivate;
        data["IsPublic"] = this.isPublic;
        data["IsConstructedGenericMethod"] = this.isConstructedGenericMethod;
        data["IsGenericMethod"] = this.isGenericMethod;
        data["IsGenericMethodDefinition"] = this.isGenericMethodDefinition;
        data["ContainsGenericParameters"] = this.containsGenericParameters;
        data["MethodHandle"] = this.methodHandle ? this.methodHandle.toJSON() : <any>undefined;
        data["IsSecurityCritical"] = this.isSecurityCritical;
        data["IsSecuritySafeCritical"] = this.isSecuritySafeCritical;
        data["IsSecurityTransparent"] = this.isSecurityTransparent;
        return data;
    }
}

export interface IMethodBase {
    memberType?: MemberTypes;
    name?: string | undefined;
    declaringType?: Type;
    reflectedType?: Type;
    module?: Module;
    customAttributes?: CustomAttributeData[] | undefined;
    isCollectible?: boolean;
    metadataToken?: number;
    attributes?: MethodAttributes;
    methodImplementationFlags?: MethodImplAttributes;
    callingConvention?: CallingConventions;
    isAbstract?: boolean;
    isConstructor?: boolean;
    isFinal?: boolean;
    isHideBySig?: boolean;
    isSpecialName?: boolean;
    isStatic?: boolean;
    isVirtual?: boolean;
    isAssembly?: boolean;
    isFamily?: boolean;
    isFamilyAndAssembly?: boolean;
    isFamilyOrAssembly?: boolean;
    isPrivate?: boolean;
    isPublic?: boolean;
    isConstructedGenericMethod?: boolean;
    isGenericMethod?: boolean;
    isGenericMethodDefinition?: boolean;
    containsGenericParameters?: boolean;
    methodHandle?: RuntimeMethodHandle;
    isSecurityCritical?: boolean;
    isSecuritySafeCritical?: boolean;
    isSecurityTransparent?: boolean;
}

export enum MethodImplAttributes {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _8 = 8,
    _16 = 16,
    _32 = 32,
    _64 = 64,
    _128 = 128,
    _256 = 256,
    _512 = 512,
    _4096 = 4096,
    _65535 = 65535,
}

export class MethodInfo implements IMethodInfo {
    readonly name?: string | undefined;
    declaringType?: Type;
    reflectedType?: Type;
    module?: Module;
    readonly customAttributes?: CustomAttributeData[] | undefined;
    readonly isCollectible?: boolean;
    readonly metadataToken?: number;
    attributes?: MethodAttributes;
    methodImplementationFlags?: MethodImplAttributes;
    callingConvention?: CallingConventions;
    readonly isAbstract?: boolean;
    readonly isConstructor?: boolean;
    readonly isFinal?: boolean;
    readonly isHideBySig?: boolean;
    readonly isSpecialName?: boolean;
    readonly isStatic?: boolean;
    readonly isVirtual?: boolean;
    readonly isAssembly?: boolean;
    readonly isFamily?: boolean;
    readonly isFamilyAndAssembly?: boolean;
    readonly isFamilyOrAssembly?: boolean;
    readonly isPrivate?: boolean;
    readonly isPublic?: boolean;
    readonly isConstructedGenericMethod?: boolean;
    readonly isGenericMethod?: boolean;
    readonly isGenericMethodDefinition?: boolean;
    readonly containsGenericParameters?: boolean;
    methodHandle?: RuntimeMethodHandle;
    readonly isSecurityCritical?: boolean;
    readonly isSecuritySafeCritical?: boolean;
    readonly isSecurityTransparent?: boolean;
    memberType?: MemberTypes;
    returnParameter?: ParameterInfo;
    returnType?: Type;
    returnTypeCustomAttributes?: ICustomAttributeProvider;

    constructor(data?: IMethodInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).name = _data["Name"];
            this.declaringType = _data["DeclaringType"] ? Type.fromJS(_data["DeclaringType"]) : <any>undefined;
            this.reflectedType = _data["ReflectedType"] ? Type.fromJS(_data["ReflectedType"]) : <any>undefined;
            this.module = _data["Module"] ? Module.fromJS(_data["Module"]) : <any>undefined;
            if (Array.isArray(_data["CustomAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["CustomAttributes"])
                    (<any>this).customAttributes!.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).isCollectible = _data["IsCollectible"];
            (<any>this).metadataToken = _data["MetadataToken"];
            this.attributes = _data["Attributes"];
            this.methodImplementationFlags = _data["MethodImplementationFlags"];
            this.callingConvention = _data["CallingConvention"];
            (<any>this).isAbstract = _data["IsAbstract"];
            (<any>this).isConstructor = _data["IsConstructor"];
            (<any>this).isFinal = _data["IsFinal"];
            (<any>this).isHideBySig = _data["IsHideBySig"];
            (<any>this).isSpecialName = _data["IsSpecialName"];
            (<any>this).isStatic = _data["IsStatic"];
            (<any>this).isVirtual = _data["IsVirtual"];
            (<any>this).isAssembly = _data["IsAssembly"];
            (<any>this).isFamily = _data["IsFamily"];
            (<any>this).isFamilyAndAssembly = _data["IsFamilyAndAssembly"];
            (<any>this).isFamilyOrAssembly = _data["IsFamilyOrAssembly"];
            (<any>this).isPrivate = _data["IsPrivate"];
            (<any>this).isPublic = _data["IsPublic"];
            (<any>this).isConstructedGenericMethod = _data["IsConstructedGenericMethod"];
            (<any>this).isGenericMethod = _data["IsGenericMethod"];
            (<any>this).isGenericMethodDefinition = _data["IsGenericMethodDefinition"];
            (<any>this).containsGenericParameters = _data["ContainsGenericParameters"];
            this.methodHandle = _data["MethodHandle"] ? RuntimeMethodHandle.fromJS(_data["MethodHandle"]) : <any>undefined;
            (<any>this).isSecurityCritical = _data["IsSecurityCritical"];
            (<any>this).isSecuritySafeCritical = _data["IsSecuritySafeCritical"];
            (<any>this).isSecurityTransparent = _data["IsSecurityTransparent"];
            this.memberType = _data["MemberType"];
            this.returnParameter = _data["ReturnParameter"] ? ParameterInfo.fromJS(_data["ReturnParameter"]) : <any>undefined;
            this.returnType = _data["ReturnType"] ? Type.fromJS(_data["ReturnType"]) : <any>undefined;
            this.returnTypeCustomAttributes = _data["ReturnTypeCustomAttributes"] ? ICustomAttributeProvider.fromJS(_data["ReturnTypeCustomAttributes"]) : <any>undefined;
        }
    }

    static fromJS(data: any): MethodInfo {
        data = typeof data === 'object' ? data : {};
        let result = new MethodInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Name"] = this.name;
        data["DeclaringType"] = this.declaringType ? this.declaringType.toJSON() : <any>undefined;
        data["ReflectedType"] = this.reflectedType ? this.reflectedType.toJSON() : <any>undefined;
        data["Module"] = this.module ? this.module.toJSON() : <any>undefined;
        if (Array.isArray(this.customAttributes)) {
            data["CustomAttributes"] = [];
            for (let item of this.customAttributes)
                data["CustomAttributes"].push(item.toJSON());
        }
        data["IsCollectible"] = this.isCollectible;
        data["MetadataToken"] = this.metadataToken;
        data["Attributes"] = this.attributes;
        data["MethodImplementationFlags"] = this.methodImplementationFlags;
        data["CallingConvention"] = this.callingConvention;
        data["IsAbstract"] = this.isAbstract;
        data["IsConstructor"] = this.isConstructor;
        data["IsFinal"] = this.isFinal;
        data["IsHideBySig"] = this.isHideBySig;
        data["IsSpecialName"] = this.isSpecialName;
        data["IsStatic"] = this.isStatic;
        data["IsVirtual"] = this.isVirtual;
        data["IsAssembly"] = this.isAssembly;
        data["IsFamily"] = this.isFamily;
        data["IsFamilyAndAssembly"] = this.isFamilyAndAssembly;
        data["IsFamilyOrAssembly"] = this.isFamilyOrAssembly;
        data["IsPrivate"] = this.isPrivate;
        data["IsPublic"] = this.isPublic;
        data["IsConstructedGenericMethod"] = this.isConstructedGenericMethod;
        data["IsGenericMethod"] = this.isGenericMethod;
        data["IsGenericMethodDefinition"] = this.isGenericMethodDefinition;
        data["ContainsGenericParameters"] = this.containsGenericParameters;
        data["MethodHandle"] = this.methodHandle ? this.methodHandle.toJSON() : <any>undefined;
        data["IsSecurityCritical"] = this.isSecurityCritical;
        data["IsSecuritySafeCritical"] = this.isSecuritySafeCritical;
        data["IsSecurityTransparent"] = this.isSecurityTransparent;
        data["MemberType"] = this.memberType;
        data["ReturnParameter"] = this.returnParameter ? this.returnParameter.toJSON() : <any>undefined;
        data["ReturnType"] = this.returnType ? this.returnType.toJSON() : <any>undefined;
        data["ReturnTypeCustomAttributes"] = this.returnTypeCustomAttributes ? this.returnTypeCustomAttributes.toJSON() : <any>undefined;
        return data;
    }
}

export interface IMethodInfo {
    name?: string | undefined;
    declaringType?: Type;
    reflectedType?: Type;
    module?: Module;
    customAttributes?: CustomAttributeData[] | undefined;
    isCollectible?: boolean;
    metadataToken?: number;
    attributes?: MethodAttributes;
    methodImplementationFlags?: MethodImplAttributes;
    callingConvention?: CallingConventions;
    isAbstract?: boolean;
    isConstructor?: boolean;
    isFinal?: boolean;
    isHideBySig?: boolean;
    isSpecialName?: boolean;
    isStatic?: boolean;
    isVirtual?: boolean;
    isAssembly?: boolean;
    isFamily?: boolean;
    isFamilyAndAssembly?: boolean;
    isFamilyOrAssembly?: boolean;
    isPrivate?: boolean;
    isPublic?: boolean;
    isConstructedGenericMethod?: boolean;
    isGenericMethod?: boolean;
    isGenericMethodDefinition?: boolean;
    containsGenericParameters?: boolean;
    methodHandle?: RuntimeMethodHandle;
    isSecurityCritical?: boolean;
    isSecuritySafeCritical?: boolean;
    isSecurityTransparent?: boolean;
    memberType?: MemberTypes;
    returnParameter?: ParameterInfo;
    returnType?: Type;
    returnTypeCustomAttributes?: ICustomAttributeProvider;
}

export class ModelBindingMessageProvider implements IModelBindingMessageProvider {
    missingBindRequiredValueAccessor?: StringStringFunc;
    missingKeyOrValueAccessor?: StringFunc;
    missingRequestBodyRequiredValueAccessor?: StringFunc;
    valueMustNotBeNullAccessor?: StringStringFunc;
    attemptedValueIsInvalidAccessor?: StringStringStringFunc;
    nonPropertyAttemptedValueIsInvalidAccessor?: StringStringFunc;
    unknownValueIsInvalidAccessor?: StringStringFunc;
    nonPropertyUnknownValueIsInvalidAccessor?: StringFunc;
    valueIsInvalidAccessor?: StringStringFunc;
    valueMustBeANumberAccessor?: StringStringFunc;
    nonPropertyValueMustBeANumberAccessor?: StringFunc;

    constructor(data?: IModelBindingMessageProvider) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.missingBindRequiredValueAccessor = _data["MissingBindRequiredValueAccessor"] ? StringStringFunc.fromJS(_data["MissingBindRequiredValueAccessor"]) : <any>undefined;
            this.missingKeyOrValueAccessor = _data["MissingKeyOrValueAccessor"] ? StringFunc.fromJS(_data["MissingKeyOrValueAccessor"]) : <any>undefined;
            this.missingRequestBodyRequiredValueAccessor = _data["MissingRequestBodyRequiredValueAccessor"] ? StringFunc.fromJS(_data["MissingRequestBodyRequiredValueAccessor"]) : <any>undefined;
            this.valueMustNotBeNullAccessor = _data["ValueMustNotBeNullAccessor"] ? StringStringFunc.fromJS(_data["ValueMustNotBeNullAccessor"]) : <any>undefined;
            this.attemptedValueIsInvalidAccessor = _data["AttemptedValueIsInvalidAccessor"] ? StringStringStringFunc.fromJS(_data["AttemptedValueIsInvalidAccessor"]) : <any>undefined;
            this.nonPropertyAttemptedValueIsInvalidAccessor = _data["NonPropertyAttemptedValueIsInvalidAccessor"] ? StringStringFunc.fromJS(_data["NonPropertyAttemptedValueIsInvalidAccessor"]) : <any>undefined;
            this.unknownValueIsInvalidAccessor = _data["UnknownValueIsInvalidAccessor"] ? StringStringFunc.fromJS(_data["UnknownValueIsInvalidAccessor"]) : <any>undefined;
            this.nonPropertyUnknownValueIsInvalidAccessor = _data["NonPropertyUnknownValueIsInvalidAccessor"] ? StringFunc.fromJS(_data["NonPropertyUnknownValueIsInvalidAccessor"]) : <any>undefined;
            this.valueIsInvalidAccessor = _data["ValueIsInvalidAccessor"] ? StringStringFunc.fromJS(_data["ValueIsInvalidAccessor"]) : <any>undefined;
            this.valueMustBeANumberAccessor = _data["ValueMustBeANumberAccessor"] ? StringStringFunc.fromJS(_data["ValueMustBeANumberAccessor"]) : <any>undefined;
            this.nonPropertyValueMustBeANumberAccessor = _data["NonPropertyValueMustBeANumberAccessor"] ? StringFunc.fromJS(_data["NonPropertyValueMustBeANumberAccessor"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ModelBindingMessageProvider {
        data = typeof data === 'object' ? data : {};
        let result = new ModelBindingMessageProvider();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["MissingBindRequiredValueAccessor"] = this.missingBindRequiredValueAccessor ? this.missingBindRequiredValueAccessor.toJSON() : <any>undefined;
        data["MissingKeyOrValueAccessor"] = this.missingKeyOrValueAccessor ? this.missingKeyOrValueAccessor.toJSON() : <any>undefined;
        data["MissingRequestBodyRequiredValueAccessor"] = this.missingRequestBodyRequiredValueAccessor ? this.missingRequestBodyRequiredValueAccessor.toJSON() : <any>undefined;
        data["ValueMustNotBeNullAccessor"] = this.valueMustNotBeNullAccessor ? this.valueMustNotBeNullAccessor.toJSON() : <any>undefined;
        data["AttemptedValueIsInvalidAccessor"] = this.attemptedValueIsInvalidAccessor ? this.attemptedValueIsInvalidAccessor.toJSON() : <any>undefined;
        data["NonPropertyAttemptedValueIsInvalidAccessor"] = this.nonPropertyAttemptedValueIsInvalidAccessor ? this.nonPropertyAttemptedValueIsInvalidAccessor.toJSON() : <any>undefined;
        data["UnknownValueIsInvalidAccessor"] = this.unknownValueIsInvalidAccessor ? this.unknownValueIsInvalidAccessor.toJSON() : <any>undefined;
        data["NonPropertyUnknownValueIsInvalidAccessor"] = this.nonPropertyUnknownValueIsInvalidAccessor ? this.nonPropertyUnknownValueIsInvalidAccessor.toJSON() : <any>undefined;
        data["ValueIsInvalidAccessor"] = this.valueIsInvalidAccessor ? this.valueIsInvalidAccessor.toJSON() : <any>undefined;
        data["ValueMustBeANumberAccessor"] = this.valueMustBeANumberAccessor ? this.valueMustBeANumberAccessor.toJSON() : <any>undefined;
        data["NonPropertyValueMustBeANumberAccessor"] = this.nonPropertyValueMustBeANumberAccessor ? this.nonPropertyValueMustBeANumberAccessor.toJSON() : <any>undefined;
        return data;
    }
}

export interface IModelBindingMessageProvider {
    missingBindRequiredValueAccessor?: StringStringFunc;
    missingKeyOrValueAccessor?: StringFunc;
    missingRequestBodyRequiredValueAccessor?: StringFunc;
    valueMustNotBeNullAccessor?: StringStringFunc;
    attemptedValueIsInvalidAccessor?: StringStringStringFunc;
    nonPropertyAttemptedValueIsInvalidAccessor?: StringStringFunc;
    unknownValueIsInvalidAccessor?: StringStringFunc;
    nonPropertyUnknownValueIsInvalidAccessor?: StringFunc;
    valueIsInvalidAccessor?: StringStringFunc;
    valueMustBeANumberAccessor?: StringStringFunc;
    nonPropertyValueMustBeANumberAccessor?: StringFunc;
}

export class ModelError implements IModelError {
    exception?: Exception;
    readonly errorMessage?: string | undefined;

    constructor(data?: IModelError) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.exception = _data["Exception"] ? Exception.fromJS(_data["Exception"]) : <any>undefined;
            (<any>this).errorMessage = _data["ErrorMessage"];
        }
    }

    static fromJS(data: any): ModelError {
        data = typeof data === 'object' ? data : {};
        let result = new ModelError();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Exception"] = this.exception ? this.exception.toJSON() : <any>undefined;
        data["ErrorMessage"] = this.errorMessage;
        return data;
    }
}

export interface IModelError {
    exception?: Exception;
    errorMessage?: string | undefined;
}

export class ModelExplorer implements IModelExplorer {
    container?: ModelExplorer;
    metadata?: ModelMetadata;
    readonly model?: any | undefined;
    modelType?: Type;
    readonly properties?: ModelExplorer[] | undefined;

    constructor(data?: IModelExplorer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.container = _data["Container"] ? ModelExplorer.fromJS(_data["Container"]) : <any>undefined;
            this.metadata = _data["Metadata"] ? ModelMetadata.fromJS(_data["Metadata"]) : <any>undefined;
            (<any>this).model = _data["Model"];
            this.modelType = _data["ModelType"] ? Type.fromJS(_data["ModelType"]) : <any>undefined;
            if (Array.isArray(_data["Properties"])) {
                (<any>this).properties = [] as any;
                for (let item of _data["Properties"])
                    (<any>this).properties!.push(ModelExplorer.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ModelExplorer {
        data = typeof data === 'object' ? data : {};
        let result = new ModelExplorer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Container"] = this.container ? this.container.toJSON() : <any>undefined;
        data["Metadata"] = this.metadata ? this.metadata.toJSON() : <any>undefined;
        data["Model"] = this.model;
        data["ModelType"] = this.modelType ? this.modelType.toJSON() : <any>undefined;
        if (Array.isArray(this.properties)) {
            data["Properties"] = [];
            for (let item of this.properties)
                data["Properties"].push(item.toJSON());
        }
        return data;
    }
}

export interface IModelExplorer {
    container?: ModelExplorer;
    metadata?: ModelMetadata;
    model?: any | undefined;
    modelType?: Type;
    properties?: ModelExplorer[] | undefined;
}

export class ModelMetadata implements IModelMetadata {
    containerType?: Type;
    containerMetadata?: ModelMetadata;
    metadataKind?: ModelMetadataKind;
    modelType?: Type;
    readonly name?: string | undefined;
    readonly parameterName?: string | undefined;
    readonly propertyName?: string | undefined;
    readonly additionalValues?: { [key: string]: any; } | undefined;
    readonly properties?: ModelMetadata[] | undefined;
    boundConstructor?: ModelMetadata;
    readonly boundConstructorParameters?: ModelMetadata[] | undefined;
    readonly binderModelName?: string | undefined;
    binderType?: Type;
    bindingSource?: BindingSource;
    readonly convertEmptyStringToNull?: boolean;
    readonly dataTypeName?: string | undefined;
    readonly description?: string | undefined;
    readonly displayFormatString?: string | undefined;
    readonly displayName?: string | undefined;
    readonly editFormatString?: string | undefined;
    elementMetadata?: ModelMetadata;
    readonly enumGroupedDisplayNamesAndValues?: EnumGroupAndNameStringKeyValuePair[] | undefined;
    readonly enumNamesAndValues?: { [key: string]: string; } | undefined;
    readonly hasNonDefaultEditFormat?: boolean;
    readonly htmlEncode?: boolean;
    readonly hideSurroundingHtml?: boolean;
    readonly isBindingAllowed?: boolean;
    readonly isBindingRequired?: boolean;
    readonly isEnum?: boolean;
    readonly isFlagsEnum?: boolean;
    readonly isReadOnly?: boolean;
    readonly isRequired?: boolean;
    modelBindingMessageProvider?: ModelBindingMessageProvider;
    readonly order?: number;
    readonly placeholder?: string | undefined;
    readonly nullDisplayText?: string | undefined;
    propertyFilterProvider?: IPropertyFilterProvider;
    readonly showForDisplay?: boolean;
    readonly showForEdit?: boolean;
    readonly simpleDisplayProperty?: string | undefined;
    readonly templateHint?: string | undefined;
    propertyValidationFilter?: IPropertyValidationFilter;
    readonly validateChildren?: boolean;
    readonly hasValidators?: boolean | undefined;
    readonly validatorMetadata?: any[] | undefined;
    elementType?: Type;
    readonly isComplexType?: boolean;
    readonly isNullableValueType?: boolean;
    readonly isCollectionType?: boolean;
    readonly isEnumerableType?: boolean;
    readonly isReferenceOrNullableType?: boolean;
    underlyingOrModelType?: Type;
    propertyGetter?: ObjectObjectFunc;
    propertySetter?: ObjectObjectAction;
    boundConstructorInvoker?: ObjectArrayObjectFunc;

    constructor(data?: IModelMetadata) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.containerType = _data["ContainerType"] ? Type.fromJS(_data["ContainerType"]) : <any>undefined;
            this.containerMetadata = _data["ContainerMetadata"] ? ModelMetadata.fromJS(_data["ContainerMetadata"]) : <any>undefined;
            this.metadataKind = _data["MetadataKind"];
            this.modelType = _data["ModelType"] ? Type.fromJS(_data["ModelType"]) : <any>undefined;
            (<any>this).name = _data["Name"];
            (<any>this).parameterName = _data["ParameterName"];
            (<any>this).propertyName = _data["PropertyName"];
            if (_data["AdditionalValues"]) {
                (<any>this).additionalValues = {} as any;
                for (let key in _data["AdditionalValues"]) {
                    if (_data["AdditionalValues"].hasOwnProperty(key))
                        (<any>(<any>this).additionalValues)![key] = _data["AdditionalValues"][key];
                }
            }
            if (Array.isArray(_data["Properties"])) {
                (<any>this).properties = [] as any;
                for (let item of _data["Properties"])
                    (<any>this).properties!.push(ModelMetadata.fromJS(item));
            }
            this.boundConstructor = _data["BoundConstructor"] ? ModelMetadata.fromJS(_data["BoundConstructor"]) : <any>undefined;
            if (Array.isArray(_data["BoundConstructorParameters"])) {
                (<any>this).boundConstructorParameters = [] as any;
                for (let item of _data["BoundConstructorParameters"])
                    (<any>this).boundConstructorParameters!.push(ModelMetadata.fromJS(item));
            }
            (<any>this).binderModelName = _data["BinderModelName"];
            this.binderType = _data["BinderType"] ? Type.fromJS(_data["BinderType"]) : <any>undefined;
            this.bindingSource = _data["BindingSource"] ? BindingSource.fromJS(_data["BindingSource"]) : <any>undefined;
            (<any>this).convertEmptyStringToNull = _data["ConvertEmptyStringToNull"];
            (<any>this).dataTypeName = _data["DataTypeName"];
            (<any>this).description = _data["Description"];
            (<any>this).displayFormatString = _data["DisplayFormatString"];
            (<any>this).displayName = _data["DisplayName"];
            (<any>this).editFormatString = _data["EditFormatString"];
            this.elementMetadata = _data["ElementMetadata"] ? ModelMetadata.fromJS(_data["ElementMetadata"]) : <any>undefined;
            if (Array.isArray(_data["EnumGroupedDisplayNamesAndValues"])) {
                (<any>this).enumGroupedDisplayNamesAndValues = [] as any;
                for (let item of _data["EnumGroupedDisplayNamesAndValues"])
                    (<any>this).enumGroupedDisplayNamesAndValues!.push(EnumGroupAndNameStringKeyValuePair.fromJS(item));
            }
            if (_data["EnumNamesAndValues"]) {
                (<any>this).enumNamesAndValues = {} as any;
                for (let key in _data["EnumNamesAndValues"]) {
                    if (_data["EnumNamesAndValues"].hasOwnProperty(key))
                        (<any>(<any>this).enumNamesAndValues)![key] = _data["EnumNamesAndValues"][key];
                }
            }
            (<any>this).hasNonDefaultEditFormat = _data["HasNonDefaultEditFormat"];
            (<any>this).htmlEncode = _data["HtmlEncode"];
            (<any>this).hideSurroundingHtml = _data["HideSurroundingHtml"];
            (<any>this).isBindingAllowed = _data["IsBindingAllowed"];
            (<any>this).isBindingRequired = _data["IsBindingRequired"];
            (<any>this).isEnum = _data["IsEnum"];
            (<any>this).isFlagsEnum = _data["IsFlagsEnum"];
            (<any>this).isReadOnly = _data["IsReadOnly"];
            (<any>this).isRequired = _data["IsRequired"];
            this.modelBindingMessageProvider = _data["ModelBindingMessageProvider"] ? ModelBindingMessageProvider.fromJS(_data["ModelBindingMessageProvider"]) : <any>undefined;
            (<any>this).order = _data["Order"];
            (<any>this).placeholder = _data["Placeholder"];
            (<any>this).nullDisplayText = _data["NullDisplayText"];
            this.propertyFilterProvider = _data["PropertyFilterProvider"] ? IPropertyFilterProvider.fromJS(_data["PropertyFilterProvider"]) : <any>undefined;
            (<any>this).showForDisplay = _data["ShowForDisplay"];
            (<any>this).showForEdit = _data["ShowForEdit"];
            (<any>this).simpleDisplayProperty = _data["SimpleDisplayProperty"];
            (<any>this).templateHint = _data["TemplateHint"];
            this.propertyValidationFilter = _data["PropertyValidationFilter"] ? IPropertyValidationFilter.fromJS(_data["PropertyValidationFilter"]) : <any>undefined;
            (<any>this).validateChildren = _data["ValidateChildren"];
            (<any>this).hasValidators = _data["HasValidators"];
            if (Array.isArray(_data["ValidatorMetadata"])) {
                (<any>this).validatorMetadata = [] as any;
                for (let item of _data["ValidatorMetadata"])
                    (<any>this).validatorMetadata!.push(item);
            }
            this.elementType = _data["ElementType"] ? Type.fromJS(_data["ElementType"]) : <any>undefined;
            (<any>this).isComplexType = _data["IsComplexType"];
            (<any>this).isNullableValueType = _data["IsNullableValueType"];
            (<any>this).isCollectionType = _data["IsCollectionType"];
            (<any>this).isEnumerableType = _data["IsEnumerableType"];
            (<any>this).isReferenceOrNullableType = _data["IsReferenceOrNullableType"];
            this.underlyingOrModelType = _data["UnderlyingOrModelType"] ? Type.fromJS(_data["UnderlyingOrModelType"]) : <any>undefined;
            this.propertyGetter = _data["PropertyGetter"] ? ObjectObjectFunc.fromJS(_data["PropertyGetter"]) : <any>undefined;
            this.propertySetter = _data["PropertySetter"] ? ObjectObjectAction.fromJS(_data["PropertySetter"]) : <any>undefined;
            this.boundConstructorInvoker = _data["BoundConstructorInvoker"] ? ObjectArrayObjectFunc.fromJS(_data["BoundConstructorInvoker"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ModelMetadata {
        data = typeof data === 'object' ? data : {};
        let result = new ModelMetadata();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ContainerType"] = this.containerType ? this.containerType.toJSON() : <any>undefined;
        data["ContainerMetadata"] = this.containerMetadata ? this.containerMetadata.toJSON() : <any>undefined;
        data["MetadataKind"] = this.metadataKind;
        data["ModelType"] = this.modelType ? this.modelType.toJSON() : <any>undefined;
        data["Name"] = this.name;
        data["ParameterName"] = this.parameterName;
        data["PropertyName"] = this.propertyName;
        if (this.additionalValues) {
            data["AdditionalValues"] = {};
            for (let key in this.additionalValues) {
                if (this.additionalValues.hasOwnProperty(key))
                    (<any>data["AdditionalValues"])[key] = this.additionalValues[key];
            }
        }
        if (Array.isArray(this.properties)) {
            data["Properties"] = [];
            for (let item of this.properties)
                data["Properties"].push(item.toJSON());
        }
        data["BoundConstructor"] = this.boundConstructor ? this.boundConstructor.toJSON() : <any>undefined;
        if (Array.isArray(this.boundConstructorParameters)) {
            data["BoundConstructorParameters"] = [];
            for (let item of this.boundConstructorParameters)
                data["BoundConstructorParameters"].push(item.toJSON());
        }
        data["BinderModelName"] = this.binderModelName;
        data["BinderType"] = this.binderType ? this.binderType.toJSON() : <any>undefined;
        data["BindingSource"] = this.bindingSource ? this.bindingSource.toJSON() : <any>undefined;
        data["ConvertEmptyStringToNull"] = this.convertEmptyStringToNull;
        data["DataTypeName"] = this.dataTypeName;
        data["Description"] = this.description;
        data["DisplayFormatString"] = this.displayFormatString;
        data["DisplayName"] = this.displayName;
        data["EditFormatString"] = this.editFormatString;
        data["ElementMetadata"] = this.elementMetadata ? this.elementMetadata.toJSON() : <any>undefined;
        if (Array.isArray(this.enumGroupedDisplayNamesAndValues)) {
            data["EnumGroupedDisplayNamesAndValues"] = [];
            for (let item of this.enumGroupedDisplayNamesAndValues)
                data["EnumGroupedDisplayNamesAndValues"].push(item.toJSON());
        }
        if (this.enumNamesAndValues) {
            data["EnumNamesAndValues"] = {};
            for (let key in this.enumNamesAndValues) {
                if (this.enumNamesAndValues.hasOwnProperty(key))
                    (<any>data["EnumNamesAndValues"])[key] = this.enumNamesAndValues[key];
            }
        }
        data["HasNonDefaultEditFormat"] = this.hasNonDefaultEditFormat;
        data["HtmlEncode"] = this.htmlEncode;
        data["HideSurroundingHtml"] = this.hideSurroundingHtml;
        data["IsBindingAllowed"] = this.isBindingAllowed;
        data["IsBindingRequired"] = this.isBindingRequired;
        data["IsEnum"] = this.isEnum;
        data["IsFlagsEnum"] = this.isFlagsEnum;
        data["IsReadOnly"] = this.isReadOnly;
        data["IsRequired"] = this.isRequired;
        data["ModelBindingMessageProvider"] = this.modelBindingMessageProvider ? this.modelBindingMessageProvider.toJSON() : <any>undefined;
        data["Order"] = this.order;
        data["Placeholder"] = this.placeholder;
        data["NullDisplayText"] = this.nullDisplayText;
        data["PropertyFilterProvider"] = this.propertyFilterProvider ? this.propertyFilterProvider.toJSON() : <any>undefined;
        data["ShowForDisplay"] = this.showForDisplay;
        data["ShowForEdit"] = this.showForEdit;
        data["SimpleDisplayProperty"] = this.simpleDisplayProperty;
        data["TemplateHint"] = this.templateHint;
        data["PropertyValidationFilter"] = this.propertyValidationFilter ? this.propertyValidationFilter.toJSON() : <any>undefined;
        data["ValidateChildren"] = this.validateChildren;
        data["HasValidators"] = this.hasValidators;
        if (Array.isArray(this.validatorMetadata)) {
            data["ValidatorMetadata"] = [];
            for (let item of this.validatorMetadata)
                data["ValidatorMetadata"].push(item);
        }
        data["ElementType"] = this.elementType ? this.elementType.toJSON() : <any>undefined;
        data["IsComplexType"] = this.isComplexType;
        data["IsNullableValueType"] = this.isNullableValueType;
        data["IsCollectionType"] = this.isCollectionType;
        data["IsEnumerableType"] = this.isEnumerableType;
        data["IsReferenceOrNullableType"] = this.isReferenceOrNullableType;
        data["UnderlyingOrModelType"] = this.underlyingOrModelType ? this.underlyingOrModelType.toJSON() : <any>undefined;
        data["PropertyGetter"] = this.propertyGetter ? this.propertyGetter.toJSON() : <any>undefined;
        data["PropertySetter"] = this.propertySetter ? this.propertySetter.toJSON() : <any>undefined;
        data["BoundConstructorInvoker"] = this.boundConstructorInvoker ? this.boundConstructorInvoker.toJSON() : <any>undefined;
        return data;
    }
}

export interface IModelMetadata {
    containerType?: Type;
    containerMetadata?: ModelMetadata;
    metadataKind?: ModelMetadataKind;
    modelType?: Type;
    name?: string | undefined;
    parameterName?: string | undefined;
    propertyName?: string | undefined;
    additionalValues?: { [key: string]: any; } | undefined;
    properties?: ModelMetadata[] | undefined;
    boundConstructor?: ModelMetadata;
    boundConstructorParameters?: ModelMetadata[] | undefined;
    binderModelName?: string | undefined;
    binderType?: Type;
    bindingSource?: BindingSource;
    convertEmptyStringToNull?: boolean;
    dataTypeName?: string | undefined;
    description?: string | undefined;
    displayFormatString?: string | undefined;
    displayName?: string | undefined;
    editFormatString?: string | undefined;
    elementMetadata?: ModelMetadata;
    enumGroupedDisplayNamesAndValues?: EnumGroupAndNameStringKeyValuePair[] | undefined;
    enumNamesAndValues?: { [key: string]: string; } | undefined;
    hasNonDefaultEditFormat?: boolean;
    htmlEncode?: boolean;
    hideSurroundingHtml?: boolean;
    isBindingAllowed?: boolean;
    isBindingRequired?: boolean;
    isEnum?: boolean;
    isFlagsEnum?: boolean;
    isReadOnly?: boolean;
    isRequired?: boolean;
    modelBindingMessageProvider?: ModelBindingMessageProvider;
    order?: number;
    placeholder?: string | undefined;
    nullDisplayText?: string | undefined;
    propertyFilterProvider?: IPropertyFilterProvider;
    showForDisplay?: boolean;
    showForEdit?: boolean;
    simpleDisplayProperty?: string | undefined;
    templateHint?: string | undefined;
    propertyValidationFilter?: IPropertyValidationFilter;
    validateChildren?: boolean;
    hasValidators?: boolean | undefined;
    validatorMetadata?: any[] | undefined;
    elementType?: Type;
    isComplexType?: boolean;
    isNullableValueType?: boolean;
    isCollectionType?: boolean;
    isEnumerableType?: boolean;
    isReferenceOrNullableType?: boolean;
    underlyingOrModelType?: Type;
    propertyGetter?: ObjectObjectFunc;
    propertySetter?: ObjectObjectAction;
    boundConstructorInvoker?: ObjectArrayObjectFunc;
}

export class ModelMetadataBooleanFunc implements IModelMetadataBooleanFunc {
    readonly target?: any | undefined;
    method?: MethodInfo;

    constructor(data?: IModelMetadataBooleanFunc) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).target = _data["Target"];
            this.method = _data["Method"] ? MethodInfo.fromJS(_data["Method"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ModelMetadataBooleanFunc {
        data = typeof data === 'object' ? data : {};
        let result = new ModelMetadataBooleanFunc();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Target"] = this.target;
        data["Method"] = this.method ? this.method.toJSON() : <any>undefined;
        return data;
    }
}

export interface IModelMetadataBooleanFunc {
    target?: any | undefined;
    method?: MethodInfo;
}

export enum ModelMetadataKind {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class ModelStateEntry implements IModelStateEntry {
    rawValue?: any | undefined;
    attemptedValue?: string | undefined;
    readonly errors?: ModelError[] | undefined;
    validationState?: ModelValidationState;
    readonly isContainerNode?: boolean;
    readonly children?: ModelStateEntry[] | undefined;

    constructor(data?: IModelStateEntry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rawValue = _data["RawValue"];
            this.attemptedValue = _data["AttemptedValue"];
            if (Array.isArray(_data["Errors"])) {
                (<any>this).errors = [] as any;
                for (let item of _data["Errors"])
                    (<any>this).errors!.push(ModelError.fromJS(item));
            }
            this.validationState = _data["ValidationState"];
            (<any>this).isContainerNode = _data["IsContainerNode"];
            if (Array.isArray(_data["Children"])) {
                (<any>this).children = [] as any;
                for (let item of _data["Children"])
                    (<any>this).children!.push(ModelStateEntry.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ModelStateEntry {
        data = typeof data === 'object' ? data : {};
        let result = new ModelStateEntry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["RawValue"] = this.rawValue;
        data["AttemptedValue"] = this.attemptedValue;
        if (Array.isArray(this.errors)) {
            data["Errors"] = [];
            for (let item of this.errors)
                data["Errors"].push(item.toJSON());
        }
        data["ValidationState"] = this.validationState;
        data["IsContainerNode"] = this.isContainerNode;
        if (Array.isArray(this.children)) {
            data["Children"] = [];
            for (let item of this.children)
                data["Children"].push(item.toJSON());
        }
        return data;
    }
}

export interface IModelStateEntry {
    rawValue?: any | undefined;
    attemptedValue?: string | undefined;
    errors?: ModelError[] | undefined;
    validationState?: ModelValidationState;
    isContainerNode?: boolean;
    children?: ModelStateEntry[] | undefined;
}

export enum ModelValidationState {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class Module implements IModule {
    assembly?: Assembly;
    readonly fullyQualifiedName?: string | undefined;
    readonly name?: string | undefined;
    readonly mDStreamVersion?: number;
    readonly moduleVersionId?: string;
    readonly scopeName?: string | undefined;
    moduleHandle?: ModuleHandle;
    readonly customAttributes?: CustomAttributeData[] | undefined;
    readonly metadataToken?: number;

    constructor(data?: IModule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.assembly = _data["Assembly"] ? Assembly.fromJS(_data["Assembly"]) : <any>undefined;
            (<any>this).fullyQualifiedName = _data["FullyQualifiedName"];
            (<any>this).name = _data["Name"];
            (<any>this).mDStreamVersion = _data["MDStreamVersion"];
            (<any>this).moduleVersionId = _data["ModuleVersionId"];
            (<any>this).scopeName = _data["ScopeName"];
            this.moduleHandle = _data["ModuleHandle"] ? ModuleHandle.fromJS(_data["ModuleHandle"]) : <any>undefined;
            if (Array.isArray(_data["CustomAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["CustomAttributes"])
                    (<any>this).customAttributes!.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).metadataToken = _data["MetadataToken"];
        }
    }

    static fromJS(data: any): Module {
        data = typeof data === 'object' ? data : {};
        let result = new Module();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Assembly"] = this.assembly ? this.assembly.toJSON() : <any>undefined;
        data["FullyQualifiedName"] = this.fullyQualifiedName;
        data["Name"] = this.name;
        data["MDStreamVersion"] = this.mDStreamVersion;
        data["ModuleVersionId"] = this.moduleVersionId;
        data["ScopeName"] = this.scopeName;
        data["ModuleHandle"] = this.moduleHandle ? this.moduleHandle.toJSON() : <any>undefined;
        if (Array.isArray(this.customAttributes)) {
            data["CustomAttributes"] = [];
            for (let item of this.customAttributes)
                data["CustomAttributes"].push(item.toJSON());
        }
        data["MetadataToken"] = this.metadataToken;
        return data;
    }
}

export interface IModule {
    assembly?: Assembly;
    fullyQualifiedName?: string | undefined;
    name?: string | undefined;
    mDStreamVersion?: number;
    moduleVersionId?: string;
    scopeName?: string | undefined;
    moduleHandle?: ModuleHandle;
    customAttributes?: CustomAttributeData[] | undefined;
    metadataToken?: number;
}

export class ModuleHandle implements IModuleHandle {
    readonly mDStreamVersion?: number;

    constructor(data?: IModuleHandle) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).mDStreamVersion = _data["MDStreamVersion"];
        }
    }

    static fromJS(data: any): ModuleHandle {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleHandle();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["MDStreamVersion"] = this.mDStreamVersion;
        return data;
    }
}

export interface IModuleHandle {
    mDStreamVersion?: number;
}

export class Neighborhood implements INeighborhood {
    id?: number;
    districtId?: number;
    district?: District;
    name?: string | undefined;
    zipCode?: string | undefined;

    constructor(data?: INeighborhood) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.districtId = _data["DistrictId"];
            this.district = _data["District"] ? District.fromJS(_data["District"]) : <any>undefined;
            this.name = _data["Name"];
            this.zipCode = _data["ZipCode"];
        }
    }

    static fromJS(data: any): Neighborhood {
        data = typeof data === 'object' ? data : {};
        let result = new Neighborhood();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["DistrictId"] = this.districtId;
        data["District"] = this.district ? this.district.toJSON() : <any>undefined;
        data["Name"] = this.name;
        data["ZipCode"] = this.zipCode;
        return data;
    }
}

export interface INeighborhood {
    id?: number;
    districtId?: number;
    district?: District;
    name?: string | undefined;
    zipCode?: string | undefined;
}

export class Nok implements INok {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: INok) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): Nok {
        data = typeof data === 'object' ? data : {};
        let result = new Nok();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface INok {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class Notification implements INotification {
    readonly events?: { [key: string]: any; } | undefined;
    readonly id?: string | undefined;
    initializer?: IJavaScriptInitializer;
    readonly isInClientTemplate?: boolean;
    isSelfInitialized?: boolean;
    hasDeferredInitialization?: boolean;
    htmlAttributes?: { [key: string]: any; } | undefined;
    htmlHelper?: IHtmlHelper;
    modelMetadataProvider?: IModelMetadataProvider;
    name?: string | undefined;
    explorer?: ModelExplorer;
    readonly selector?: string | undefined;
    readonly idPrefix?: string | undefined;
    viewContext?: ViewContext;
    valueProvider?: IValueProvider;
    urlGenerator?: IUrlGenerator;
    htmlEncoder?: HtmlEncoder;
    readonly templates?: NotificationTemplateSettings[] | undefined;
    animation?: PopupAnimation;
    tag?: string | undefined;
    allowHideAfter?: number | undefined;
    appendTo?: string | undefined;
    autoHideAfter?: number | undefined;
    button?: boolean | undefined;
    height?: string | undefined;
    hideOnClick?: boolean | undefined;
    position?: NotificationPositionSettings;
    width?: string | undefined;
    stacking?: NotificationStackingSettings;

    constructor(data?: INotification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["Events"]) {
                (<any>this).events = {} as any;
                for (let key in _data["Events"]) {
                    if (_data["Events"].hasOwnProperty(key))
                        (<any>(<any>this).events)![key] = _data["Events"][key];
                }
            }
            (<any>this).id = _data["Id"];
            this.initializer = _data["Initializer"] ? IJavaScriptInitializer.fromJS(_data["Initializer"]) : <any>undefined;
            (<any>this).isInClientTemplate = _data["IsInClientTemplate"];
            this.isSelfInitialized = _data["IsSelfInitialized"];
            this.hasDeferredInitialization = _data["HasDeferredInitialization"];
            if (_data["HtmlAttributes"]) {
                this.htmlAttributes = {} as any;
                for (let key in _data["HtmlAttributes"]) {
                    if (_data["HtmlAttributes"].hasOwnProperty(key))
                        (<any>this.htmlAttributes)![key] = _data["HtmlAttributes"][key];
                }
            }
            this.htmlHelper = _data["HtmlHelper"] ? IHtmlHelper.fromJS(_data["HtmlHelper"]) : <any>undefined;
            this.modelMetadataProvider = _data["ModelMetadataProvider"] ? IModelMetadataProvider.fromJS(_data["ModelMetadataProvider"]) : <any>undefined;
            this.name = _data["Name"];
            this.explorer = _data["Explorer"] ? ModelExplorer.fromJS(_data["Explorer"]) : <any>undefined;
            (<any>this).selector = _data["Selector"];
            (<any>this).idPrefix = _data["IdPrefix"];
            this.viewContext = _data["ViewContext"] ? ViewContext.fromJS(_data["ViewContext"]) : <any>undefined;
            this.valueProvider = _data["ValueProvider"] ? IValueProvider.fromJS(_data["ValueProvider"]) : <any>undefined;
            this.urlGenerator = _data["UrlGenerator"] ? IUrlGenerator.fromJS(_data["UrlGenerator"]) : <any>undefined;
            this.htmlEncoder = _data["HtmlEncoder"] ? HtmlEncoder.fromJS(_data["HtmlEncoder"]) : <any>undefined;
            if (Array.isArray(_data["Templates"])) {
                (<any>this).templates = [] as any;
                for (let item of _data["Templates"])
                    (<any>this).templates!.push(NotificationTemplateSettings.fromJS(item));
            }
            this.animation = _data["Animation"] ? PopupAnimation.fromJS(_data["Animation"]) : <any>undefined;
            this.tag = _data["Tag"];
            this.allowHideAfter = _data["AllowHideAfter"];
            this.appendTo = _data["AppendTo"];
            this.autoHideAfter = _data["AutoHideAfter"];
            this.button = _data["Button"];
            this.height = _data["Height"];
            this.hideOnClick = _data["HideOnClick"];
            this.position = _data["Position"] ? NotificationPositionSettings.fromJS(_data["Position"]) : <any>undefined;
            this.width = _data["Width"];
            this.stacking = _data["Stacking"];
        }
    }

    static fromJS(data: any): Notification {
        data = typeof data === 'object' ? data : {};
        let result = new Notification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.events) {
            data["Events"] = {};
            for (let key in this.events) {
                if (this.events.hasOwnProperty(key))
                    (<any>data["Events"])[key] = this.events[key];
            }
        }
        data["Id"] = this.id;
        data["Initializer"] = this.initializer ? this.initializer.toJSON() : <any>undefined;
        data["IsInClientTemplate"] = this.isInClientTemplate;
        data["IsSelfInitialized"] = this.isSelfInitialized;
        data["HasDeferredInitialization"] = this.hasDeferredInitialization;
        if (this.htmlAttributes) {
            data["HtmlAttributes"] = {};
            for (let key in this.htmlAttributes) {
                if (this.htmlAttributes.hasOwnProperty(key))
                    (<any>data["HtmlAttributes"])[key] = this.htmlAttributes[key];
            }
        }
        data["HtmlHelper"] = this.htmlHelper ? this.htmlHelper.toJSON() : <any>undefined;
        data["ModelMetadataProvider"] = this.modelMetadataProvider ? this.modelMetadataProvider.toJSON() : <any>undefined;
        data["Name"] = this.name;
        data["Explorer"] = this.explorer ? this.explorer.toJSON() : <any>undefined;
        data["Selector"] = this.selector;
        data["IdPrefix"] = this.idPrefix;
        data["ViewContext"] = this.viewContext ? this.viewContext.toJSON() : <any>undefined;
        data["ValueProvider"] = this.valueProvider ? this.valueProvider.toJSON() : <any>undefined;
        data["UrlGenerator"] = this.urlGenerator ? this.urlGenerator.toJSON() : <any>undefined;
        data["HtmlEncoder"] = this.htmlEncoder ? this.htmlEncoder.toJSON() : <any>undefined;
        if (Array.isArray(this.templates)) {
            data["Templates"] = [];
            for (let item of this.templates)
                data["Templates"].push(item.toJSON());
        }
        data["Animation"] = this.animation ? this.animation.toJSON() : <any>undefined;
        data["Tag"] = this.tag;
        data["AllowHideAfter"] = this.allowHideAfter;
        data["AppendTo"] = this.appendTo;
        data["AutoHideAfter"] = this.autoHideAfter;
        data["Button"] = this.button;
        data["Height"] = this.height;
        data["HideOnClick"] = this.hideOnClick;
        data["Position"] = this.position ? this.position.toJSON() : <any>undefined;
        data["Width"] = this.width;
        data["Stacking"] = this.stacking;
        return data;
    }
}

export interface INotification {
    events?: { [key: string]: any; } | undefined;
    id?: string | undefined;
    initializer?: IJavaScriptInitializer;
    isInClientTemplate?: boolean;
    isSelfInitialized?: boolean;
    hasDeferredInitialization?: boolean;
    htmlAttributes?: { [key: string]: any; } | undefined;
    htmlHelper?: IHtmlHelper;
    modelMetadataProvider?: IModelMetadataProvider;
    name?: string | undefined;
    explorer?: ModelExplorer;
    selector?: string | undefined;
    idPrefix?: string | undefined;
    viewContext?: ViewContext;
    valueProvider?: IValueProvider;
    urlGenerator?: IUrlGenerator;
    htmlEncoder?: HtmlEncoder;
    templates?: NotificationTemplateSettings[] | undefined;
    animation?: PopupAnimation;
    tag?: string | undefined;
    allowHideAfter?: number | undefined;
    appendTo?: string | undefined;
    autoHideAfter?: number | undefined;
    button?: boolean | undefined;
    height?: string | undefined;
    hideOnClick?: boolean | undefined;
    position?: NotificationPositionSettings;
    width?: string | undefined;
    stacking?: NotificationStackingSettings;
}

export class NotificationPositionSettings implements INotificationPositionSettings {
    bottom?: number | undefined;
    left?: number | undefined;
    pinned?: boolean | undefined;
    right?: number | undefined;
    top?: number | undefined;
    notification?: Notification;

    constructor(data?: INotificationPositionSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.bottom = _data["Bottom"];
            this.left = _data["Left"];
            this.pinned = _data["Pinned"];
            this.right = _data["Right"];
            this.top = _data["Top"];
            this.notification = _data["Notification"] ? Notification.fromJS(_data["Notification"]) : <any>undefined;
        }
    }

    static fromJS(data: any): NotificationPositionSettings {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationPositionSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Bottom"] = this.bottom;
        data["Left"] = this.left;
        data["Pinned"] = this.pinned;
        data["Right"] = this.right;
        data["Top"] = this.top;
        data["Notification"] = this.notification ? this.notification.toJSON() : <any>undefined;
        return data;
    }
}

export interface INotificationPositionSettings {
    bottom?: number | undefined;
    left?: number | undefined;
    pinned?: boolean | undefined;
    right?: number | undefined;
    top?: number | undefined;
    notification?: Notification;
}

export enum NotificationStackingSettings {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

export class NotificationTemplateSettings implements INotificationTemplateSettings {
    type?: string | undefined;
    clientTemplateID?: string | undefined;
    clientTemplate?: string | undefined;

    constructor(data?: INotificationTemplateSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["Type"];
            this.clientTemplateID = _data["ClientTemplateID"];
            this.clientTemplate = _data["ClientTemplate"];
        }
    }

    static fromJS(data: any): NotificationTemplateSettings {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationTemplateSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Type"] = this.type;
        data["ClientTemplateID"] = this.clientTemplateID;
        data["ClientTemplate"] = this.clientTemplate;
        return data;
    }
}

export interface INotificationTemplateSettings {
    type?: string | undefined;
    clientTemplateID?: string | undefined;
    clientTemplate?: string | undefined;
}

export class NotificationType implements INotificationType {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;

    constructor(data?: INotificationType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.createdOn = _data["CreatedOn"] ? moment(_data["CreatedOn"].toString()) : <any>undefined;
            this.createdById = _data["CreatedById"];
            this.createdBy = _data["CreatedBy"] ? User.fromJS(_data["CreatedBy"]) : <any>undefined;
            this.updatedOn = _data["UpdatedOn"] ? moment(_data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedById = _data["UpdatedById"];
            this.updatedBy = _data["UpdatedBy"] ? User.fromJS(_data["UpdatedBy"]) : <any>undefined;
            this.deletedOn = _data["DeletedOn"] ? moment(_data["DeletedOn"].toString()) : <any>undefined;
            this.deletedById = _data["DeletedById"];
            this.deletedBy = _data["DeletedBy"] ? User.fromJS(_data["DeletedBy"]) : <any>undefined;
            this.isDeleted = _data["IsDeleted"];
            this.code = _data["Code"];
            this.description = _data["Description"];
            this.displayOrder = _data["DisplayOrder"];
            this.isActive = _data["IsActive"];
        }
    }

    static fromJS(data: any): NotificationType {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedById"] = this.createdById;
        data["CreatedBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["DeletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        data["DeletedById"] = this.deletedById;
        data["DeletedBy"] = this.deletedBy ? this.deletedBy.toJSON() : <any>undefined;
        data["IsDeleted"] = this.isDeleted;
        data["Code"] = this.code;
        data["Description"] = this.description;
        data["DisplayOrder"] = this.displayOrder;
        data["IsActive"] = this.isActive;
        return data;
    }
}

export interface INotificationType {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;
}

export class ObjectArrayObjectFunc implements IObjectArrayObjectFunc {
    readonly target?: any | undefined;
    method?: MethodInfo;

    constructor(data?: IObjectArrayObjectFunc) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).target = _data["Target"];
            this.method = _data["Method"] ? MethodInfo.fromJS(_data["Method"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ObjectArrayObjectFunc {
        data = typeof data === 'object' ? data : {};
        let result = new ObjectArrayObjectFunc();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Target"] = this.target;
        data["Method"] = this.method ? this.method.toJSON() : <any>undefined;
        return data;
    }
}

export interface IObjectArrayObjectFunc {
    target?: any | undefined;
    method?: MethodInfo;
}

export class ObjectObjectAction implements IObjectObjectAction {
    readonly target?: any | undefined;
    method?: MethodInfo;

    constructor(data?: IObjectObjectAction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).target = _data["Target"];
            this.method = _data["Method"] ? MethodInfo.fromJS(_data["Method"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ObjectObjectAction {
        data = typeof data === 'object' ? data : {};
        let result = new ObjectObjectAction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Target"] = this.target;
        data["Method"] = this.method ? this.method.toJSON() : <any>undefined;
        return data;
    }
}

export interface IObjectObjectAction {
    target?: any | undefined;
    method?: MethodInfo;
}

export class ObjectObjectFunc implements IObjectObjectFunc {
    readonly target?: any | undefined;
    method?: MethodInfo;

    constructor(data?: IObjectObjectFunc) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).target = _data["Target"];
            this.method = _data["Method"] ? MethodInfo.fromJS(_data["Method"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ObjectObjectFunc {
        data = typeof data === 'object' ? data : {};
        let result = new ObjectObjectFunc();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Target"] = this.target;
        data["Method"] = this.method ? this.method.toJSON() : <any>undefined;
        return data;
    }
}

export interface IObjectObjectFunc {
    target?: any | undefined;
    method?: MethodInfo;
}

export class Oid implements IOid {
    value?: string | undefined;
    friendlyName?: string | undefined;

    constructor(data?: IOid) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["Value"];
            this.friendlyName = _data["FriendlyName"];
        }
    }

    static fromJS(data: any): Oid {
        data = typeof data === 'object' ? data : {};
        let result = new Oid();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Value"] = this.value;
        data["FriendlyName"] = this.friendlyName;
        return data;
    }
}

export interface IOid {
    value?: string | undefined;
    friendlyName?: string | undefined;
}

export class Ons implements IOns {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IOns) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): Ons {
        data = typeof data === 'object' ? data : {};
        let result = new Ons();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IOns {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class Order implements IOrder {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    customerId?: number;
    customer?: Customer;
    deliveryTime?: TimeSpan;
    subTotal?: number;
    total?: number;
    shippingAddressId?: number | undefined;
    shippingAddress?: OrderAddress;
    billingAddressId?: number | undefined;
    billingAddress?: OrderAddress;
    orderStatusId?: number;
    orderStatus?: OrderStatus;
    transactionId?: number;
    transaction?: Transaction;
    assetId?: number;
    asset?: Asset;
    note?: string | undefined;
    isTest?: boolean;
    readonly orderItems?: OrderItem[] | undefined;

    constructor(data?: IOrder) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.createdOn = _data["CreatedOn"] ? moment(_data["CreatedOn"].toString()) : <any>undefined;
            this.createdById = _data["CreatedById"];
            this.createdBy = _data["CreatedBy"] ? User.fromJS(_data["CreatedBy"]) : <any>undefined;
            this.updatedOn = _data["UpdatedOn"] ? moment(_data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedById = _data["UpdatedById"];
            this.updatedBy = _data["UpdatedBy"] ? User.fromJS(_data["UpdatedBy"]) : <any>undefined;
            this.deletedOn = _data["DeletedOn"] ? moment(_data["DeletedOn"].toString()) : <any>undefined;
            this.deletedById = _data["DeletedById"];
            this.deletedBy = _data["DeletedBy"] ? User.fromJS(_data["DeletedBy"]) : <any>undefined;
            this.isDeleted = _data["IsDeleted"];
            this.customerId = _data["CustomerId"];
            this.customer = _data["Customer"] ? Customer.fromJS(_data["Customer"]) : <any>undefined;
            this.deliveryTime = _data["DeliveryTime"] ? TimeSpan.fromJS(_data["DeliveryTime"]) : <any>undefined;
            this.subTotal = _data["SubTotal"];
            this.total = _data["Total"];
            this.shippingAddressId = _data["ShippingAddressId"];
            this.shippingAddress = _data["ShippingAddress"] ? OrderAddress.fromJS(_data["ShippingAddress"]) : <any>undefined;
            this.billingAddressId = _data["BillingAddressId"];
            this.billingAddress = _data["BillingAddress"] ? OrderAddress.fromJS(_data["BillingAddress"]) : <any>undefined;
            this.orderStatusId = _data["OrderStatusId"];
            this.orderStatus = _data["OrderStatus"] ? OrderStatus.fromJS(_data["OrderStatus"]) : <any>undefined;
            this.transactionId = _data["TransactionId"];
            this.transaction = _data["Transaction"] ? Transaction.fromJS(_data["Transaction"]) : <any>undefined;
            this.assetId = _data["AssetId"];
            this.asset = _data["Asset"] ? Asset.fromJS(_data["Asset"]) : <any>undefined;
            this.note = _data["Note"];
            this.isTest = _data["IsTest"];
            if (Array.isArray(_data["OrderItems"])) {
                (<any>this).orderItems = [] as any;
                for (let item of _data["OrderItems"])
                    (<any>this).orderItems!.push(OrderItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Order {
        data = typeof data === 'object' ? data : {};
        let result = new Order();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedById"] = this.createdById;
        data["CreatedBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["DeletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        data["DeletedById"] = this.deletedById;
        data["DeletedBy"] = this.deletedBy ? this.deletedBy.toJSON() : <any>undefined;
        data["IsDeleted"] = this.isDeleted;
        data["CustomerId"] = this.customerId;
        data["Customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        data["DeliveryTime"] = this.deliveryTime ? this.deliveryTime.toJSON() : <any>undefined;
        data["SubTotal"] = this.subTotal;
        data["Total"] = this.total;
        data["ShippingAddressId"] = this.shippingAddressId;
        data["ShippingAddress"] = this.shippingAddress ? this.shippingAddress.toJSON() : <any>undefined;
        data["BillingAddressId"] = this.billingAddressId;
        data["BillingAddress"] = this.billingAddress ? this.billingAddress.toJSON() : <any>undefined;
        data["OrderStatusId"] = this.orderStatusId;
        data["OrderStatus"] = this.orderStatus ? this.orderStatus.toJSON() : <any>undefined;
        data["TransactionId"] = this.transactionId;
        data["Transaction"] = this.transaction ? this.transaction.toJSON() : <any>undefined;
        data["AssetId"] = this.assetId;
        data["Asset"] = this.asset ? this.asset.toJSON() : <any>undefined;
        data["Note"] = this.note;
        data["IsTest"] = this.isTest;
        if (Array.isArray(this.orderItems)) {
            data["OrderItems"] = [];
            for (let item of this.orderItems)
                data["OrderItems"].push(item.toJSON());
        }
        return data;
    }
}

export interface IOrder {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    customerId?: number;
    customer?: Customer;
    deliveryTime?: TimeSpan;
    subTotal?: number;
    total?: number;
    shippingAddressId?: number | undefined;
    shippingAddress?: OrderAddress;
    billingAddressId?: number | undefined;
    billingAddress?: OrderAddress;
    orderStatusId?: number;
    orderStatus?: OrderStatus;
    transactionId?: number;
    transaction?: Transaction;
    assetId?: number;
    asset?: Asset;
    note?: string | undefined;
    isTest?: boolean;
    orderItems?: OrderItem[] | undefined;
}

export class OrderAddress implements IOrderAddress {
    id?: number;
    name?: string | undefined;
    contactName?: string | undefined;
    phone?: string | undefined;
    addressLine?: string | undefined;
    directions?: string | undefined;
    neighborhoodId?: number | undefined;
    neighborhood?: Neighborhood;
    districtId?: number;
    district?: District;
    provinceId?: number;
    province?: Province;
    countryId?: string | undefined;
    country?: Country;

    constructor(data?: IOrderAddress) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.name = _data["Name"];
            this.contactName = _data["ContactName"];
            this.phone = _data["Phone"];
            this.addressLine = _data["AddressLine"];
            this.directions = _data["Directions"];
            this.neighborhoodId = _data["NeighborhoodId"];
            this.neighborhood = _data["Neighborhood"] ? Neighborhood.fromJS(_data["Neighborhood"]) : <any>undefined;
            this.districtId = _data["DistrictId"];
            this.district = _data["District"] ? District.fromJS(_data["District"]) : <any>undefined;
            this.provinceId = _data["ProvinceId"];
            this.province = _data["Province"] ? Province.fromJS(_data["Province"]) : <any>undefined;
            this.countryId = _data["CountryId"];
            this.country = _data["Country"] ? Country.fromJS(_data["Country"]) : <any>undefined;
        }
    }

    static fromJS(data: any): OrderAddress {
        data = typeof data === 'object' ? data : {};
        let result = new OrderAddress();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Name"] = this.name;
        data["ContactName"] = this.contactName;
        data["Phone"] = this.phone;
        data["AddressLine"] = this.addressLine;
        data["Directions"] = this.directions;
        data["NeighborhoodId"] = this.neighborhoodId;
        data["Neighborhood"] = this.neighborhood ? this.neighborhood.toJSON() : <any>undefined;
        data["DistrictId"] = this.districtId;
        data["District"] = this.district ? this.district.toJSON() : <any>undefined;
        data["ProvinceId"] = this.provinceId;
        data["Province"] = this.province ? this.province.toJSON() : <any>undefined;
        data["CountryId"] = this.countryId;
        data["Country"] = this.country ? this.country.toJSON() : <any>undefined;
        return data;
    }
}

export interface IOrderAddress {
    id?: number;
    name?: string | undefined;
    contactName?: string | undefined;
    phone?: string | undefined;
    addressLine?: string | undefined;
    directions?: string | undefined;
    neighborhoodId?: number | undefined;
    neighborhood?: Neighborhood;
    districtId?: number;
    district?: District;
    provinceId?: number;
    province?: Province;
    countryId?: string | undefined;
    country?: Country;
}

export class OrderItem implements IOrderItem {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    orderId?: number;
    order?: Order;
    productId?: number;
    product?: Product;
    quantity?: number;
    productPrice?: number;
    amount?: number;

    constructor(data?: IOrderItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.createdOn = _data["CreatedOn"] ? moment(_data["CreatedOn"].toString()) : <any>undefined;
            this.createdById = _data["CreatedById"];
            this.createdBy = _data["CreatedBy"] ? User.fromJS(_data["CreatedBy"]) : <any>undefined;
            this.updatedOn = _data["UpdatedOn"] ? moment(_data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedById = _data["UpdatedById"];
            this.updatedBy = _data["UpdatedBy"] ? User.fromJS(_data["UpdatedBy"]) : <any>undefined;
            this.deletedOn = _data["DeletedOn"] ? moment(_data["DeletedOn"].toString()) : <any>undefined;
            this.deletedById = _data["DeletedById"];
            this.deletedBy = _data["DeletedBy"] ? User.fromJS(_data["DeletedBy"]) : <any>undefined;
            this.isDeleted = _data["IsDeleted"];
            this.orderId = _data["OrderId"];
            this.order = _data["Order"] ? Order.fromJS(_data["Order"]) : <any>undefined;
            this.productId = _data["ProductId"];
            this.product = _data["Product"] ? Product.fromJS(_data["Product"]) : <any>undefined;
            this.quantity = _data["Quantity"];
            this.productPrice = _data["ProductPrice"];
            this.amount = _data["Amount"];
        }
    }

    static fromJS(data: any): OrderItem {
        data = typeof data === 'object' ? data : {};
        let result = new OrderItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedById"] = this.createdById;
        data["CreatedBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["DeletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        data["DeletedById"] = this.deletedById;
        data["DeletedBy"] = this.deletedBy ? this.deletedBy.toJSON() : <any>undefined;
        data["IsDeleted"] = this.isDeleted;
        data["OrderId"] = this.orderId;
        data["Order"] = this.order ? this.order.toJSON() : <any>undefined;
        data["ProductId"] = this.productId;
        data["Product"] = this.product ? this.product.toJSON() : <any>undefined;
        data["Quantity"] = this.quantity;
        data["ProductPrice"] = this.productPrice;
        data["Amount"] = this.amount;
        return data;
    }
}

export interface IOrderItem {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    orderId?: number;
    order?: Order;
    productId?: number;
    product?: Product;
    quantity?: number;
    productPrice?: number;
    amount?: number;
}

export class OrderStatus implements IOrderStatus {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;

    constructor(data?: IOrderStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.createdOn = _data["CreatedOn"] ? moment(_data["CreatedOn"].toString()) : <any>undefined;
            this.createdById = _data["CreatedById"];
            this.createdBy = _data["CreatedBy"] ? User.fromJS(_data["CreatedBy"]) : <any>undefined;
            this.updatedOn = _data["UpdatedOn"] ? moment(_data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedById = _data["UpdatedById"];
            this.updatedBy = _data["UpdatedBy"] ? User.fromJS(_data["UpdatedBy"]) : <any>undefined;
            this.deletedOn = _data["DeletedOn"] ? moment(_data["DeletedOn"].toString()) : <any>undefined;
            this.deletedById = _data["DeletedById"];
            this.deletedBy = _data["DeletedBy"] ? User.fromJS(_data["DeletedBy"]) : <any>undefined;
            this.isDeleted = _data["IsDeleted"];
            this.code = _data["Code"];
            this.description = _data["Description"];
            this.displayOrder = _data["DisplayOrder"];
            this.isActive = _data["IsActive"];
        }
    }

    static fromJS(data: any): OrderStatus {
        data = typeof data === 'object' ? data : {};
        let result = new OrderStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedById"] = this.createdById;
        data["CreatedBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["DeletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        data["DeletedById"] = this.deletedById;
        data["DeletedBy"] = this.deletedBy ? this.deletedBy.toJSON() : <any>undefined;
        data["IsDeleted"] = this.isDeleted;
        data["Code"] = this.code;
        data["Description"] = this.description;
        data["DisplayOrder"] = this.displayOrder;
        data["IsActive"] = this.isActive;
        return data;
    }
}

export interface IOrderStatus {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;
}

export class Paladyum implements IPaladyum {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IPaladyum) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): Paladyum {
        data = typeof data === 'object' ? data : {};
        let result = new Paladyum();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IPaladyum {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class PaladyumfixAm implements IPaladyumfixAm {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IPaladyumfixAm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): PaladyumfixAm {
        data = typeof data === 'object' ? data : {};
        let result = new PaladyumfixAm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IPaladyumfixAm {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class PaladyumfixPm implements IPaladyumfixPm {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IPaladyumfixPm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): PaladyumfixPm {
        data = typeof data === 'object' ? data : {};
        let result = new PaladyumfixPm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IPaladyumfixPm {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export enum ParameterAttributes {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _4 = 4,
    _8 = 8,
    _16 = 16,
    _4096 = 4096,
    _8192 = 8192,
    _16384 = 16384,
    _32768 = 32768,
    _61440 = 61440,
}

export class ParameterDescriptor implements IParameterDescriptor {
    name?: string | undefined;
    parameterType?: Type;
    bindingInfo?: BindingInfo;

    constructor(data?: IParameterDescriptor) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["Name"];
            this.parameterType = _data["ParameterType"] ? Type.fromJS(_data["ParameterType"]) : <any>undefined;
            this.bindingInfo = _data["BindingInfo"] ? BindingInfo.fromJS(_data["BindingInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ParameterDescriptor {
        data = typeof data === 'object' ? data : {};
        let result = new ParameterDescriptor();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Name"] = this.name;
        data["ParameterType"] = this.parameterType ? this.parameterType.toJSON() : <any>undefined;
        data["BindingInfo"] = this.bindingInfo ? this.bindingInfo.toJSON() : <any>undefined;
        return data;
    }
}

export interface IParameterDescriptor {
    name?: string | undefined;
    parameterType?: Type;
    bindingInfo?: BindingInfo;
}

export class ParameterInfo implements IParameterInfo {
    attributes?: ParameterAttributes;
    member?: MemberInfo;
    readonly name?: string | undefined;
    parameterType?: Type;
    readonly position?: number;
    readonly isIn?: boolean;
    readonly isLcid?: boolean;
    readonly isOptional?: boolean;
    readonly isOut?: boolean;
    readonly isRetval?: boolean;
    readonly defaultValue?: any | undefined;
    readonly rawDefaultValue?: any | undefined;
    readonly hasDefaultValue?: boolean;
    readonly customAttributes?: CustomAttributeData[] | undefined;
    readonly metadataToken?: number;

    constructor(data?: IParameterInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.attributes = _data["Attributes"];
            this.member = _data["Member"] ? MemberInfo.fromJS(_data["Member"]) : <any>undefined;
            (<any>this).name = _data["Name"];
            this.parameterType = _data["ParameterType"] ? Type.fromJS(_data["ParameterType"]) : <any>undefined;
            (<any>this).position = _data["Position"];
            (<any>this).isIn = _data["IsIn"];
            (<any>this).isLcid = _data["IsLcid"];
            (<any>this).isOptional = _data["IsOptional"];
            (<any>this).isOut = _data["IsOut"];
            (<any>this).isRetval = _data["IsRetval"];
            (<any>this).defaultValue = _data["DefaultValue"];
            (<any>this).rawDefaultValue = _data["RawDefaultValue"];
            (<any>this).hasDefaultValue = _data["HasDefaultValue"];
            if (Array.isArray(_data["CustomAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["CustomAttributes"])
                    (<any>this).customAttributes!.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).metadataToken = _data["MetadataToken"];
        }
    }

    static fromJS(data: any): ParameterInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ParameterInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Attributes"] = this.attributes;
        data["Member"] = this.member ? this.member.toJSON() : <any>undefined;
        data["Name"] = this.name;
        data["ParameterType"] = this.parameterType ? this.parameterType.toJSON() : <any>undefined;
        data["Position"] = this.position;
        data["IsIn"] = this.isIn;
        data["IsLcid"] = this.isLcid;
        data["IsOptional"] = this.isOptional;
        data["IsOut"] = this.isOut;
        data["IsRetval"] = this.isRetval;
        data["DefaultValue"] = this.defaultValue;
        data["RawDefaultValue"] = this.rawDefaultValue;
        data["HasDefaultValue"] = this.hasDefaultValue;
        if (Array.isArray(this.customAttributes)) {
            data["CustomAttributes"] = [];
            for (let item of this.customAttributes)
                data["CustomAttributes"].push(item.toJSON());
        }
        data["MetadataToken"] = this.metadataToken;
        return data;
    }
}

export interface IParameterInfo {
    attributes?: ParameterAttributes;
    member?: MemberInfo;
    name?: string | undefined;
    parameterType?: Type;
    position?: number;
    isIn?: boolean;
    isLcid?: boolean;
    isOptional?: boolean;
    isOut?: boolean;
    isRetval?: boolean;
    defaultValue?: any | undefined;
    rawDefaultValue?: any | undefined;
    hasDefaultValue?: boolean;
    customAttributes?: CustomAttributeData[] | undefined;
    metadataToken?: number;
}

export class PathString implements IPathString {
    readonly value?: string | undefined;
    readonly hasValue?: boolean;

    constructor(data?: IPathString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).value = _data["Value"];
            (<any>this).hasValue = _data["HasValue"];
        }
    }

    static fromJS(data: any): PathString {
        data = typeof data === 'object' ? data : {};
        let result = new PathString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Value"] = this.value;
        data["HasValue"] = this.hasValue;
        return data;
    }
}

export interface IPathString {
    value?: string | undefined;
    hasValue?: boolean;
}

export class PaymentType implements IPaymentType {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;

    constructor(data?: IPaymentType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.createdOn = _data["CreatedOn"] ? moment(_data["CreatedOn"].toString()) : <any>undefined;
            this.createdById = _data["CreatedById"];
            this.createdBy = _data["CreatedBy"] ? User.fromJS(_data["CreatedBy"]) : <any>undefined;
            this.updatedOn = _data["UpdatedOn"] ? moment(_data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedById = _data["UpdatedById"];
            this.updatedBy = _data["UpdatedBy"] ? User.fromJS(_data["UpdatedBy"]) : <any>undefined;
            this.deletedOn = _data["DeletedOn"] ? moment(_data["DeletedOn"].toString()) : <any>undefined;
            this.deletedById = _data["DeletedById"];
            this.deletedBy = _data["DeletedBy"] ? User.fromJS(_data["DeletedBy"]) : <any>undefined;
            this.isDeleted = _data["IsDeleted"];
            this.code = _data["Code"];
            this.description = _data["Description"];
            this.displayOrder = _data["DisplayOrder"];
            this.isActive = _data["IsActive"];
        }
    }

    static fromJS(data: any): PaymentType {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedById"] = this.createdById;
        data["CreatedBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["DeletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        data["DeletedById"] = this.deletedById;
        data["DeletedBy"] = this.deletedBy ? this.deletedBy.toJSON() : <any>undefined;
        data["IsDeleted"] = this.isDeleted;
        data["Code"] = this.code;
        data["Description"] = this.description;
        data["DisplayOrder"] = this.displayOrder;
        data["IsActive"] = this.isActive;
        return data;
    }
}

export interface IPaymentType {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;
}

export class PipeReader implements IPipeReader {

    constructor(data?: IPipeReader) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): PipeReader {
        data = typeof data === 'object' ? data : {};
        let result = new PipeReader();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IPipeReader {
}

export class PipeWriter implements IPipeWriter {

    constructor(data?: IPipeWriter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): PipeWriter {
        data = typeof data === 'object' ? data : {};
        let result = new PipeWriter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IPipeWriter {
}

export class Platin implements IPlatin {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IPlatin) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): Platin {
        data = typeof data === 'object' ? data : {};
        let result = new Platin();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IPlatin {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class PlatinfixAm implements IPlatinfixAm {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IPlatinfixAm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): PlatinfixAm {
        data = typeof data === 'object' ? data : {};
        let result = new PlatinfixAm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IPlatinfixAm {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class PlatinfixPm implements IPlatinfixPm {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IPlatinfixPm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): PlatinfixPm {
        data = typeof data === 'object' ? data : {};
        let result = new PlatinfixPm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IPlatinfixPm {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class PopupAnimation implements IPopupAnimation {
    enabled?: boolean;
    open?: Effects;
    close?: Effects;

    constructor(data?: IPopupAnimation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.enabled = _data["Enabled"];
            this.open = _data["Open"] ? Effects.fromJS(_data["Open"]) : <any>undefined;
            this.close = _data["Close"] ? Effects.fromJS(_data["Close"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PopupAnimation {
        data = typeof data === 'object' ? data : {};
        let result = new PopupAnimation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Enabled"] = this.enabled;
        data["Open"] = this.open ? this.open.toJSON() : <any>undefined;
        data["Close"] = this.close ? this.close.toJSON() : <any>undefined;
        return data;
    }
}

export interface IPopupAnimation {
    enabled?: boolean;
    open?: Effects;
    close?: Effects;
}

export class Post implements IPost {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    title!: string;
    subTitle?: string | undefined;
    slug?: string | undefined;
    metaKeywords?: string | undefined;
    metaDescription?: string | undefined;
    body?: string | undefined;
    mediaId?: number | undefined;
    media?: Media;
    isPublished?: boolean;
    publishedOn?: moment.Moment | undefined;
    publishedTill?: moment.Moment | undefined;
    categoryId?: number | undefined;
    category?: PostCategory;

    constructor(data?: IPost) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.createdOn = _data["CreatedOn"] ? moment(_data["CreatedOn"].toString()) : <any>undefined;
            this.createdById = _data["CreatedById"];
            this.createdBy = _data["CreatedBy"] ? User.fromJS(_data["CreatedBy"]) : <any>undefined;
            this.updatedOn = _data["UpdatedOn"] ? moment(_data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedById = _data["UpdatedById"];
            this.updatedBy = _data["UpdatedBy"] ? User.fromJS(_data["UpdatedBy"]) : <any>undefined;
            this.deletedOn = _data["DeletedOn"] ? moment(_data["DeletedOn"].toString()) : <any>undefined;
            this.deletedById = _data["DeletedById"];
            this.deletedBy = _data["DeletedBy"] ? User.fromJS(_data["DeletedBy"]) : <any>undefined;
            this.isDeleted = _data["IsDeleted"];
            this.title = _data["Title"];
            this.subTitle = _data["SubTitle"];
            this.slug = _data["Slug"];
            this.metaKeywords = _data["MetaKeywords"];
            this.metaDescription = _data["MetaDescription"];
            this.body = _data["Body"];
            this.mediaId = _data["MediaId"];
            this.media = _data["Media"] ? Media.fromJS(_data["Media"]) : <any>undefined;
            this.isPublished = _data["IsPublished"];
            this.publishedOn = _data["PublishedOn"] ? moment(_data["PublishedOn"].toString()) : <any>undefined;
            this.publishedTill = _data["PublishedTill"] ? moment(_data["PublishedTill"].toString()) : <any>undefined;
            this.categoryId = _data["CategoryId"];
            this.category = _data["Category"] ? PostCategory.fromJS(_data["Category"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Post {
        data = typeof data === 'object' ? data : {};
        let result = new Post();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedById"] = this.createdById;
        data["CreatedBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["DeletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        data["DeletedById"] = this.deletedById;
        data["DeletedBy"] = this.deletedBy ? this.deletedBy.toJSON() : <any>undefined;
        data["IsDeleted"] = this.isDeleted;
        data["Title"] = this.title;
        data["SubTitle"] = this.subTitle;
        data["Slug"] = this.slug;
        data["MetaKeywords"] = this.metaKeywords;
        data["MetaDescription"] = this.metaDescription;
        data["Body"] = this.body;
        data["MediaId"] = this.mediaId;
        data["Media"] = this.media ? this.media.toJSON() : <any>undefined;
        data["IsPublished"] = this.isPublished;
        data["PublishedOn"] = this.publishedOn ? this.publishedOn.toISOString() : <any>undefined;
        data["PublishedTill"] = this.publishedTill ? this.publishedTill.toISOString() : <any>undefined;
        data["CategoryId"] = this.categoryId;
        data["Category"] = this.category ? this.category.toJSON() : <any>undefined;
        return data;
    }
}

export interface IPost {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    title: string;
    subTitle?: string | undefined;
    slug?: string | undefined;
    metaKeywords?: string | undefined;
    metaDescription?: string | undefined;
    body?: string | undefined;
    mediaId?: number | undefined;
    media?: Media;
    isPublished?: boolean;
    publishedOn?: moment.Moment | undefined;
    publishedTill?: moment.Moment | undefined;
    categoryId?: number | undefined;
    category?: PostCategory;
}

export class PostCategory implements IPostCategory {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    name?: string | undefined;
    mediaId?: number | undefined;
    media?: Media;

    constructor(data?: IPostCategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.createdOn = _data["CreatedOn"] ? moment(_data["CreatedOn"].toString()) : <any>undefined;
            this.createdById = _data["CreatedById"];
            this.createdBy = _data["CreatedBy"] ? User.fromJS(_data["CreatedBy"]) : <any>undefined;
            this.updatedOn = _data["UpdatedOn"] ? moment(_data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedById = _data["UpdatedById"];
            this.updatedBy = _data["UpdatedBy"] ? User.fromJS(_data["UpdatedBy"]) : <any>undefined;
            this.deletedOn = _data["DeletedOn"] ? moment(_data["DeletedOn"].toString()) : <any>undefined;
            this.deletedById = _data["DeletedById"];
            this.deletedBy = _data["DeletedBy"] ? User.fromJS(_data["DeletedBy"]) : <any>undefined;
            this.isDeleted = _data["IsDeleted"];
            this.name = _data["Name"];
            this.mediaId = _data["MediaId"];
            this.media = _data["Media"] ? Media.fromJS(_data["Media"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PostCategory {
        data = typeof data === 'object' ? data : {};
        let result = new PostCategory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedById"] = this.createdById;
        data["CreatedBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["DeletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        data["DeletedById"] = this.deletedById;
        data["DeletedBy"] = this.deletedBy ? this.deletedBy.toJSON() : <any>undefined;
        data["IsDeleted"] = this.isDeleted;
        data["Name"] = this.name;
        data["MediaId"] = this.mediaId;
        data["Media"] = this.media ? this.media.toJSON() : <any>undefined;
        return data;
    }
}

export interface IPostCategory {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    name?: string | undefined;
    mediaId?: number | undefined;
    media?: Media;
}

export class Product implements IProduct {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    code?: string | undefined;
    barcode?: string | undefined;
    name?: string | undefined;
    normalizedName?: string | undefined;
    description?: string | undefined;
    specification?: string | undefined;
    brand?: string | undefined;
    price?: number;
    oldPrice?: number | undefined;
    specialPrice?: number | undefined;
    specialPriceStart?: moment.Moment | undefined;
    specialPriceEnd?: moment.Moment | undefined;
    stockQuantity?: number;
    displayOrder?: number;
    isFeatured?: boolean;
    isPublished?: boolean;
    unitId?: number;
    unit?: ProductUnit;
    productTypeId?: number;
    productType?: ProductType;
    mediaId?: number | undefined;
    media?: Media;
    yatirimimId?: number | undefined;
    readonly categories?: ProductCategory[] | undefined;

    constructor(data?: IProduct) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.createdOn = _data["CreatedOn"] ? moment(_data["CreatedOn"].toString()) : <any>undefined;
            this.createdById = _data["CreatedById"];
            this.createdBy = _data["CreatedBy"] ? User.fromJS(_data["CreatedBy"]) : <any>undefined;
            this.updatedOn = _data["UpdatedOn"] ? moment(_data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedById = _data["UpdatedById"];
            this.updatedBy = _data["UpdatedBy"] ? User.fromJS(_data["UpdatedBy"]) : <any>undefined;
            this.deletedOn = _data["DeletedOn"] ? moment(_data["DeletedOn"].toString()) : <any>undefined;
            this.deletedById = _data["DeletedById"];
            this.deletedBy = _data["DeletedBy"] ? User.fromJS(_data["DeletedBy"]) : <any>undefined;
            this.isDeleted = _data["IsDeleted"];
            this.code = _data["Code"];
            this.barcode = _data["Barcode"];
            this.name = _data["Name"];
            this.normalizedName = _data["NormalizedName"];
            this.description = _data["Description"];
            this.specification = _data["Specification"];
            this.brand = _data["Brand"];
            this.price = _data["Price"];
            this.oldPrice = _data["OldPrice"];
            this.specialPrice = _data["SpecialPrice"];
            this.specialPriceStart = _data["SpecialPriceStart"] ? moment(_data["SpecialPriceStart"].toString()) : <any>undefined;
            this.specialPriceEnd = _data["SpecialPriceEnd"] ? moment(_data["SpecialPriceEnd"].toString()) : <any>undefined;
            this.stockQuantity = _data["StockQuantity"];
            this.displayOrder = _data["DisplayOrder"];
            this.isFeatured = _data["IsFeatured"];
            this.isPublished = _data["IsPublished"];
            this.unitId = _data["UnitId"];
            this.unit = _data["Unit"] ? ProductUnit.fromJS(_data["Unit"]) : <any>undefined;
            this.productTypeId = _data["ProductTypeId"];
            this.productType = _data["ProductType"] ? ProductType.fromJS(_data["ProductType"]) : <any>undefined;
            this.mediaId = _data["MediaId"];
            this.media = _data["Media"] ? Media.fromJS(_data["Media"]) : <any>undefined;
            this.yatirimimId = _data["YatirimimId"];
            if (Array.isArray(_data["Categories"])) {
                (<any>this).categories = [] as any;
                for (let item of _data["Categories"])
                    (<any>this).categories!.push(ProductCategory.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Product {
        data = typeof data === 'object' ? data : {};
        let result = new Product();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedById"] = this.createdById;
        data["CreatedBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["DeletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        data["DeletedById"] = this.deletedById;
        data["DeletedBy"] = this.deletedBy ? this.deletedBy.toJSON() : <any>undefined;
        data["IsDeleted"] = this.isDeleted;
        data["Code"] = this.code;
        data["Barcode"] = this.barcode;
        data["Name"] = this.name;
        data["NormalizedName"] = this.normalizedName;
        data["Description"] = this.description;
        data["Specification"] = this.specification;
        data["Brand"] = this.brand;
        data["Price"] = this.price;
        data["OldPrice"] = this.oldPrice;
        data["SpecialPrice"] = this.specialPrice;
        data["SpecialPriceStart"] = this.specialPriceStart ? this.specialPriceStart.toISOString() : <any>undefined;
        data["SpecialPriceEnd"] = this.specialPriceEnd ? this.specialPriceEnd.toISOString() : <any>undefined;
        data["StockQuantity"] = this.stockQuantity;
        data["DisplayOrder"] = this.displayOrder;
        data["IsFeatured"] = this.isFeatured;
        data["IsPublished"] = this.isPublished;
        data["UnitId"] = this.unitId;
        data["Unit"] = this.unit ? this.unit.toJSON() : <any>undefined;
        data["ProductTypeId"] = this.productTypeId;
        data["ProductType"] = this.productType ? this.productType.toJSON() : <any>undefined;
        data["MediaId"] = this.mediaId;
        data["Media"] = this.media ? this.media.toJSON() : <any>undefined;
        data["YatirimimId"] = this.yatirimimId;
        if (Array.isArray(this.categories)) {
            data["Categories"] = [];
            for (let item of this.categories)
                data["Categories"].push(item.toJSON());
        }
        return data;
    }
}

export interface IProduct {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    code?: string | undefined;
    barcode?: string | undefined;
    name?: string | undefined;
    normalizedName?: string | undefined;
    description?: string | undefined;
    specification?: string | undefined;
    brand?: string | undefined;
    price?: number;
    oldPrice?: number | undefined;
    specialPrice?: number | undefined;
    specialPriceStart?: moment.Moment | undefined;
    specialPriceEnd?: moment.Moment | undefined;
    stockQuantity?: number;
    displayOrder?: number;
    isFeatured?: boolean;
    isPublished?: boolean;
    unitId?: number;
    unit?: ProductUnit;
    productTypeId?: number;
    productType?: ProductType;
    mediaId?: number | undefined;
    media?: Media;
    yatirimimId?: number | undefined;
    categories?: ProductCategory[] | undefined;
}

export class ProductCategory implements IProductCategory {
    id?: number;
    productId?: number;
    product?: Product;
    categoryId?: number;
    category?: Category;

    constructor(data?: IProductCategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.productId = _data["ProductId"];
            this.product = _data["Product"] ? Product.fromJS(_data["Product"]) : <any>undefined;
            this.categoryId = _data["CategoryId"];
            this.category = _data["Category"] ? Category.fromJS(_data["Category"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ProductCategory {
        data = typeof data === 'object' ? data : {};
        let result = new ProductCategory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["ProductId"] = this.productId;
        data["Product"] = this.product ? this.product.toJSON() : <any>undefined;
        data["CategoryId"] = this.categoryId;
        data["Category"] = this.category ? this.category.toJSON() : <any>undefined;
        return data;
    }
}

export interface IProductCategory {
    id?: number;
    productId?: number;
    product?: Product;
    categoryId?: number;
    category?: Category;
}

export class ProductType implements IProductType {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;

    constructor(data?: IProductType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.createdOn = _data["CreatedOn"] ? moment(_data["CreatedOn"].toString()) : <any>undefined;
            this.createdById = _data["CreatedById"];
            this.createdBy = _data["CreatedBy"] ? User.fromJS(_data["CreatedBy"]) : <any>undefined;
            this.updatedOn = _data["UpdatedOn"] ? moment(_data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedById = _data["UpdatedById"];
            this.updatedBy = _data["UpdatedBy"] ? User.fromJS(_data["UpdatedBy"]) : <any>undefined;
            this.deletedOn = _data["DeletedOn"] ? moment(_data["DeletedOn"].toString()) : <any>undefined;
            this.deletedById = _data["DeletedById"];
            this.deletedBy = _data["DeletedBy"] ? User.fromJS(_data["DeletedBy"]) : <any>undefined;
            this.isDeleted = _data["IsDeleted"];
            this.code = _data["Code"];
            this.description = _data["Description"];
            this.displayOrder = _data["DisplayOrder"];
            this.isActive = _data["IsActive"];
        }
    }

    static fromJS(data: any): ProductType {
        data = typeof data === 'object' ? data : {};
        let result = new ProductType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedById"] = this.createdById;
        data["CreatedBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["DeletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        data["DeletedById"] = this.deletedById;
        data["DeletedBy"] = this.deletedBy ? this.deletedBy.toJSON() : <any>undefined;
        data["IsDeleted"] = this.isDeleted;
        data["Code"] = this.code;
        data["Description"] = this.description;
        data["DisplayOrder"] = this.displayOrder;
        data["IsActive"] = this.isActive;
        return data;
    }
}

export interface IProductType {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;
}

export class ProductUnit implements IProductUnit {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    code?: string | undefined;
    short?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;

    constructor(data?: IProductUnit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.createdOn = _data["CreatedOn"] ? moment(_data["CreatedOn"].toString()) : <any>undefined;
            this.createdById = _data["CreatedById"];
            this.createdBy = _data["CreatedBy"] ? User.fromJS(_data["CreatedBy"]) : <any>undefined;
            this.updatedOn = _data["UpdatedOn"] ? moment(_data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedById = _data["UpdatedById"];
            this.updatedBy = _data["UpdatedBy"] ? User.fromJS(_data["UpdatedBy"]) : <any>undefined;
            this.deletedOn = _data["DeletedOn"] ? moment(_data["DeletedOn"].toString()) : <any>undefined;
            this.deletedById = _data["DeletedById"];
            this.deletedBy = _data["DeletedBy"] ? User.fromJS(_data["DeletedBy"]) : <any>undefined;
            this.isDeleted = _data["IsDeleted"];
            this.code = _data["Code"];
            this.short = _data["Short"];
            this.description = _data["Description"];
            this.displayOrder = _data["DisplayOrder"];
            this.isActive = _data["IsActive"];
        }
    }

    static fromJS(data: any): ProductUnit {
        data = typeof data === 'object' ? data : {};
        let result = new ProductUnit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedById"] = this.createdById;
        data["CreatedBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["DeletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        data["DeletedById"] = this.deletedById;
        data["DeletedBy"] = this.deletedBy ? this.deletedBy.toJSON() : <any>undefined;
        data["IsDeleted"] = this.isDeleted;
        data["Code"] = this.code;
        data["Short"] = this.short;
        data["Description"] = this.description;
        data["DisplayOrder"] = this.displayOrder;
        data["IsActive"] = this.isActive;
        return data;
    }
}

export interface IProductUnit {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    code?: string | undefined;
    short?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;
}

export enum PropertyAttributes {
    _0 = 0,
    _512 = 512,
    _1024 = 1024,
    _4096 = 4096,
    _8192 = 8192,
    _16384 = 16384,
    _32768 = 32768,
    _62464 = 62464,
}

export class PropertyInfo implements IPropertyInfo {
    readonly name?: string | undefined;
    declaringType?: Type;
    reflectedType?: Type;
    module?: Module;
    readonly customAttributes?: CustomAttributeData[] | undefined;
    readonly isCollectible?: boolean;
    readonly metadataToken?: number;
    memberType?: MemberTypes;
    propertyType?: Type;
    attributes?: PropertyAttributes;
    readonly isSpecialName?: boolean;
    readonly canRead?: boolean;
    readonly canWrite?: boolean;
    getMethod?: MethodInfo;
    setMethod?: MethodInfo;

    constructor(data?: IPropertyInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).name = _data["Name"];
            this.declaringType = _data["DeclaringType"] ? Type.fromJS(_data["DeclaringType"]) : <any>undefined;
            this.reflectedType = _data["ReflectedType"] ? Type.fromJS(_data["ReflectedType"]) : <any>undefined;
            this.module = _data["Module"] ? Module.fromJS(_data["Module"]) : <any>undefined;
            if (Array.isArray(_data["CustomAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["CustomAttributes"])
                    (<any>this).customAttributes!.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).isCollectible = _data["IsCollectible"];
            (<any>this).metadataToken = _data["MetadataToken"];
            this.memberType = _data["MemberType"];
            this.propertyType = _data["PropertyType"] ? Type.fromJS(_data["PropertyType"]) : <any>undefined;
            this.attributes = _data["Attributes"];
            (<any>this).isSpecialName = _data["IsSpecialName"];
            (<any>this).canRead = _data["CanRead"];
            (<any>this).canWrite = _data["CanWrite"];
            this.getMethod = _data["GetMethod"] ? MethodInfo.fromJS(_data["GetMethod"]) : <any>undefined;
            this.setMethod = _data["SetMethod"] ? MethodInfo.fromJS(_data["SetMethod"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PropertyInfo {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Name"] = this.name;
        data["DeclaringType"] = this.declaringType ? this.declaringType.toJSON() : <any>undefined;
        data["ReflectedType"] = this.reflectedType ? this.reflectedType.toJSON() : <any>undefined;
        data["Module"] = this.module ? this.module.toJSON() : <any>undefined;
        if (Array.isArray(this.customAttributes)) {
            data["CustomAttributes"] = [];
            for (let item of this.customAttributes)
                data["CustomAttributes"].push(item.toJSON());
        }
        data["IsCollectible"] = this.isCollectible;
        data["MetadataToken"] = this.metadataToken;
        data["MemberType"] = this.memberType;
        data["PropertyType"] = this.propertyType ? this.propertyType.toJSON() : <any>undefined;
        data["Attributes"] = this.attributes;
        data["IsSpecialName"] = this.isSpecialName;
        data["CanRead"] = this.canRead;
        data["CanWrite"] = this.canWrite;
        data["GetMethod"] = this.getMethod ? this.getMethod.toJSON() : <any>undefined;
        data["SetMethod"] = this.setMethod ? this.setMethod.toJSON() : <any>undefined;
        return data;
    }
}

export interface IPropertyInfo {
    name?: string | undefined;
    declaringType?: Type;
    reflectedType?: Type;
    module?: Module;
    customAttributes?: CustomAttributeData[] | undefined;
    isCollectible?: boolean;
    metadataToken?: number;
    memberType?: MemberTypes;
    propertyType?: Type;
    attributes?: PropertyAttributes;
    isSpecialName?: boolean;
    canRead?: boolean;
    canWrite?: boolean;
    getMethod?: MethodInfo;
    setMethod?: MethodInfo;
}

export class Province implements IProvince {
    id?: number;
    countryId!: string;
    country?: Country;
    name!: string;
    type?: string | undefined;

    constructor(data?: IProvince) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.countryId = _data["CountryId"];
            this.country = _data["Country"] ? Country.fromJS(_data["Country"]) : <any>undefined;
            this.name = _data["Name"];
            this.type = _data["Type"];
        }
    }

    static fromJS(data: any): Province {
        data = typeof data === 'object' ? data : {};
        let result = new Province();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CountryId"] = this.countryId;
        data["Country"] = this.country ? this.country.toJSON() : <any>undefined;
        data["Name"] = this.name;
        data["Type"] = this.type;
        return data;
    }
}

export interface IProvince {
    id?: number;
    countryId: string;
    country?: Country;
    name: string;
    type?: string | undefined;
}

export class PublicKey implements IPublicKey {
    encodedKeyValue?: AsnEncodedData;
    encodedParameters?: AsnEncodedData;
    key?: AsymmetricAlgorithm;
    oid?: Oid;

    constructor(data?: IPublicKey) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.encodedKeyValue = _data["EncodedKeyValue"] ? AsnEncodedData.fromJS(_data["EncodedKeyValue"]) : <any>undefined;
            this.encodedParameters = _data["EncodedParameters"] ? AsnEncodedData.fromJS(_data["EncodedParameters"]) : <any>undefined;
            this.key = _data["Key"] ? AsymmetricAlgorithm.fromJS(_data["Key"]) : <any>undefined;
            this.oid = _data["Oid"] ? Oid.fromJS(_data["Oid"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PublicKey {
        data = typeof data === 'object' ? data : {};
        let result = new PublicKey();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["EncodedKeyValue"] = this.encodedKeyValue ? this.encodedKeyValue.toJSON() : <any>undefined;
        data["EncodedParameters"] = this.encodedParameters ? this.encodedParameters.toJSON() : <any>undefined;
        data["Key"] = this.key ? this.key.toJSON() : <any>undefined;
        data["Oid"] = this.oid ? this.oid.toJSON() : <any>undefined;
        return data;
    }
}

export interface IPublicKey {
    encodedKeyValue?: AsnEncodedData;
    encodedParameters?: AsnEncodedData;
    key?: AsymmetricAlgorithm;
    oid?: Oid;
}

export class QueryString implements IQueryString {
    readonly value?: string | undefined;
    readonly hasValue?: boolean;

    constructor(data?: IQueryString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).value = _data["Value"];
            (<any>this).hasValue = _data["HasValue"];
        }
    }

    static fromJS(data: any): QueryString {
        data = typeof data === 'object' ? data : {};
        let result = new QueryString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Value"] = this.value;
        data["HasValue"] = this.hasValue;
        return data;
    }
}

export interface IQueryString {
    value?: string | undefined;
    hasValue?: boolean;
}

export class Request implements IRequest {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    customerId?: number;
    customer?: Customer;
    customerBankAccountId?: number | undefined;
    customerBankAccount?: CustomerBankAccount;
    requestTypeId?: number;
    requestType?: RequestType;
    demandTypeId?: number;
    demandType?: DemandType;
    requestStatusId?: number;
    requestStatus?: RequestStatus;
    comment?: string | undefined;
    quantity?: number;
    symbolId?: number;
    symbol?: Symbol;
    price?: number;

    constructor(data?: IRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.createdOn = _data["CreatedOn"] ? moment(_data["CreatedOn"].toString()) : <any>undefined;
            this.createdById = _data["CreatedById"];
            this.createdBy = _data["CreatedBy"] ? User.fromJS(_data["CreatedBy"]) : <any>undefined;
            this.updatedOn = _data["UpdatedOn"] ? moment(_data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedById = _data["UpdatedById"];
            this.updatedBy = _data["UpdatedBy"] ? User.fromJS(_data["UpdatedBy"]) : <any>undefined;
            this.deletedOn = _data["DeletedOn"] ? moment(_data["DeletedOn"].toString()) : <any>undefined;
            this.deletedById = _data["DeletedById"];
            this.deletedBy = _data["DeletedBy"] ? User.fromJS(_data["DeletedBy"]) : <any>undefined;
            this.isDeleted = _data["IsDeleted"];
            this.customerId = _data["CustomerId"];
            this.customer = _data["Customer"] ? Customer.fromJS(_data["Customer"]) : <any>undefined;
            this.customerBankAccountId = _data["CustomerBankAccountId"];
            this.customerBankAccount = _data["CustomerBankAccount"] ? CustomerBankAccount.fromJS(_data["CustomerBankAccount"]) : <any>undefined;
            this.requestTypeId = _data["RequestTypeId"];
            this.requestType = _data["RequestType"] ? RequestType.fromJS(_data["RequestType"]) : <any>undefined;
            this.demandTypeId = _data["DemandTypeId"];
            this.demandType = _data["DemandType"] ? DemandType.fromJS(_data["DemandType"]) : <any>undefined;
            this.requestStatusId = _data["RequestStatusId"];
            this.requestStatus = _data["RequestStatus"] ? RequestStatus.fromJS(_data["RequestStatus"]) : <any>undefined;
            this.comment = _data["Comment"];
            this.quantity = _data["Quantity"];
            this.symbolId = _data["SymbolId"];
            this.symbol = _data["Symbol"] ? Symbol.fromJS(_data["Symbol"]) : <any>undefined;
            this.price = _data["Price"];
        }
    }

    static fromJS(data: any): Request {
        data = typeof data === 'object' ? data : {};
        let result = new Request();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedById"] = this.createdById;
        data["CreatedBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["DeletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        data["DeletedById"] = this.deletedById;
        data["DeletedBy"] = this.deletedBy ? this.deletedBy.toJSON() : <any>undefined;
        data["IsDeleted"] = this.isDeleted;
        data["CustomerId"] = this.customerId;
        data["Customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        data["CustomerBankAccountId"] = this.customerBankAccountId;
        data["CustomerBankAccount"] = this.customerBankAccount ? this.customerBankAccount.toJSON() : <any>undefined;
        data["RequestTypeId"] = this.requestTypeId;
        data["RequestType"] = this.requestType ? this.requestType.toJSON() : <any>undefined;
        data["DemandTypeId"] = this.demandTypeId;
        data["DemandType"] = this.demandType ? this.demandType.toJSON() : <any>undefined;
        data["RequestStatusId"] = this.requestStatusId;
        data["RequestStatus"] = this.requestStatus ? this.requestStatus.toJSON() : <any>undefined;
        data["Comment"] = this.comment;
        data["Quantity"] = this.quantity;
        data["SymbolId"] = this.symbolId;
        data["Symbol"] = this.symbol ? this.symbol.toJSON() : <any>undefined;
        data["Price"] = this.price;
        return data;
    }
}

export interface IRequest {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    customerId?: number;
    customer?: Customer;
    customerBankAccountId?: number | undefined;
    customerBankAccount?: CustomerBankAccount;
    requestTypeId?: number;
    requestType?: RequestType;
    demandTypeId?: number;
    demandType?: DemandType;
    requestStatusId?: number;
    requestStatus?: RequestStatus;
    comment?: string | undefined;
    quantity?: number;
    symbolId?: number;
    symbol?: Symbol;
    price?: number;
}

export class RequestStatus implements IRequestStatus {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;

    constructor(data?: IRequestStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.createdOn = _data["CreatedOn"] ? moment(_data["CreatedOn"].toString()) : <any>undefined;
            this.createdById = _data["CreatedById"];
            this.createdBy = _data["CreatedBy"] ? User.fromJS(_data["CreatedBy"]) : <any>undefined;
            this.updatedOn = _data["UpdatedOn"] ? moment(_data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedById = _data["UpdatedById"];
            this.updatedBy = _data["UpdatedBy"] ? User.fromJS(_data["UpdatedBy"]) : <any>undefined;
            this.deletedOn = _data["DeletedOn"] ? moment(_data["DeletedOn"].toString()) : <any>undefined;
            this.deletedById = _data["DeletedById"];
            this.deletedBy = _data["DeletedBy"] ? User.fromJS(_data["DeletedBy"]) : <any>undefined;
            this.isDeleted = _data["IsDeleted"];
            this.code = _data["Code"];
            this.description = _data["Description"];
            this.displayOrder = _data["DisplayOrder"];
            this.isActive = _data["IsActive"];
        }
    }

    static fromJS(data: any): RequestStatus {
        data = typeof data === 'object' ? data : {};
        let result = new RequestStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedById"] = this.createdById;
        data["CreatedBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["DeletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        data["DeletedById"] = this.deletedById;
        data["DeletedBy"] = this.deletedBy ? this.deletedBy.toJSON() : <any>undefined;
        data["IsDeleted"] = this.isDeleted;
        data["Code"] = this.code;
        data["Description"] = this.description;
        data["DisplayOrder"] = this.displayOrder;
        data["IsActive"] = this.isActive;
        return data;
    }
}

export interface IRequestStatus {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;
}

export class RequestType implements IRequestType {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;

    constructor(data?: IRequestType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.createdOn = _data["CreatedOn"] ? moment(_data["CreatedOn"].toString()) : <any>undefined;
            this.createdById = _data["CreatedById"];
            this.createdBy = _data["CreatedBy"] ? User.fromJS(_data["CreatedBy"]) : <any>undefined;
            this.updatedOn = _data["UpdatedOn"] ? moment(_data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedById = _data["UpdatedById"];
            this.updatedBy = _data["UpdatedBy"] ? User.fromJS(_data["UpdatedBy"]) : <any>undefined;
            this.deletedOn = _data["DeletedOn"] ? moment(_data["DeletedOn"].toString()) : <any>undefined;
            this.deletedById = _data["DeletedById"];
            this.deletedBy = _data["DeletedBy"] ? User.fromJS(_data["DeletedBy"]) : <any>undefined;
            this.isDeleted = _data["IsDeleted"];
            this.code = _data["Code"];
            this.description = _data["Description"];
            this.displayOrder = _data["DisplayOrder"];
            this.isActive = _data["IsActive"];
        }
    }

    static fromJS(data: any): RequestType {
        data = typeof data === 'object' ? data : {};
        let result = new RequestType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedById"] = this.createdById;
        data["CreatedBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["DeletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        data["DeletedById"] = this.deletedById;
        data["DeletedBy"] = this.deletedBy ? this.deletedBy.toJSON() : <any>undefined;
        data["IsDeleted"] = this.isDeleted;
        data["Code"] = this.code;
        data["Description"] = this.description;
        data["DisplayOrder"] = this.displayOrder;
        data["IsActive"] = this.isActive;
        return data;
    }
}

export interface IRequestType {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;
}

export class Retail implements IRetail {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    nationalityId?: string | undefined;
    nationality?: Country;
    customer?: Customer;
    identityNo?: string | undefined;
    passportNo?: string | undefined;
    otpSentOn?: moment.Moment | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    normalizedFirstName?: string | undefined;
    normalizedLastName?: string | undefined;
    fatherFirstName?: string | undefined;
    fatherLastName?: string | undefined;
    motherFirstName?: string | undefined;
    motherLastName?: string | undefined;
    genderId?: number | undefined;
    gender?: Gender;
    bloodTypeId?: number | undefined;
    bloodType?: BloodType;
    birthDate?: moment.Moment | undefined;
    birthInCountry?: boolean;
    birthPlaceCountry?: string | undefined;
    birthPlaceProvince?: string | undefined;
    birthPlaceNeighborhood?: string | undefined;
    birthRegisterNumber?: string | undefined;
    livingState?: string | undefined;
    maritalStatus?: string | undefined;
    religion?: string | undefined;
    isCitizen?: boolean;
    sSN?: string | undefined;
    sectorId?: number | undefined;
    sector?: CorporateCategory;
    job?: string | undefined;
    notes?: string | undefined;
    isActive?: boolean;
    isVerifiedCitizen?: boolean;
    isVerifiedForeign?: boolean;

    constructor(data?: IRetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.isActive = true;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.createdOn = _data["CreatedOn"] ? moment(_data["CreatedOn"].toString()) : <any>undefined;
            this.createdById = _data["CreatedById"];
            this.createdBy = _data["CreatedBy"] ? User.fromJS(_data["CreatedBy"]) : <any>undefined;
            this.updatedOn = _data["UpdatedOn"] ? moment(_data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedById = _data["UpdatedById"];
            this.updatedBy = _data["UpdatedBy"] ? User.fromJS(_data["UpdatedBy"]) : <any>undefined;
            this.deletedOn = _data["DeletedOn"] ? moment(_data["DeletedOn"].toString()) : <any>undefined;
            this.deletedById = _data["DeletedById"];
            this.deletedBy = _data["DeletedBy"] ? User.fromJS(_data["DeletedBy"]) : <any>undefined;
            this.isDeleted = _data["IsDeleted"];
            this.nationalityId = _data["NationalityId"];
            this.nationality = _data["Nationality"] ? Country.fromJS(_data["Nationality"]) : <any>undefined;
            this.customer = _data["Customer"] ? Customer.fromJS(_data["Customer"]) : <any>undefined;
            this.identityNo = _data["IdentityNo"];
            this.passportNo = _data["PassportNo"];
            this.otpSentOn = _data["OtpSentOn"] ? moment(_data["OtpSentOn"].toString()) : <any>undefined;
            this.firstName = _data["FirstName"];
            this.lastName = _data["LastName"];
            this.normalizedFirstName = _data["NormalizedFirstName"];
            this.normalizedLastName = _data["NormalizedLastName"];
            this.fatherFirstName = _data["FatherFirstName"];
            this.fatherLastName = _data["FatherLastName"];
            this.motherFirstName = _data["MotherFirstName"];
            this.motherLastName = _data["MotherLastName"];
            this.genderId = _data["GenderId"];
            this.gender = _data["Gender"] ? Gender.fromJS(_data["Gender"]) : <any>undefined;
            this.bloodTypeId = _data["BloodTypeId"];
            this.bloodType = _data["BloodType"] ? BloodType.fromJS(_data["BloodType"]) : <any>undefined;
            this.birthDate = _data["BirthDate"] ? moment(_data["BirthDate"].toString()) : <any>undefined;
            this.birthInCountry = _data["BirthInCountry"];
            this.birthPlaceCountry = _data["BirthPlaceCountry"];
            this.birthPlaceProvince = _data["BirthPlaceProvince"];
            this.birthPlaceNeighborhood = _data["BirthPlaceNeighborhood"];
            this.birthRegisterNumber = _data["BirthRegisterNumber"];
            this.livingState = _data["LivingState"];
            this.maritalStatus = _data["MaritalStatus"];
            this.religion = _data["Religion"];
            this.isCitizen = _data["IsCitizen"];
            this.sSN = _data["SSN"];
            this.sectorId = _data["SectorId"];
            this.sector = _data["Sector"] ? CorporateCategory.fromJS(_data["Sector"]) : <any>undefined;
            this.job = _data["Job"];
            this.notes = _data["Notes"];
            this.isActive = _data["IsActive"] !== undefined ? _data["IsActive"] : true;
            this.isVerifiedCitizen = _data["IsVerifiedCitizen"];
            this.isVerifiedForeign = _data["IsVerifiedForeign"];
        }
    }

    static fromJS(data: any): Retail {
        data = typeof data === 'object' ? data : {};
        let result = new Retail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedById"] = this.createdById;
        data["CreatedBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["DeletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        data["DeletedById"] = this.deletedById;
        data["DeletedBy"] = this.deletedBy ? this.deletedBy.toJSON() : <any>undefined;
        data["IsDeleted"] = this.isDeleted;
        data["NationalityId"] = this.nationalityId;
        data["Nationality"] = this.nationality ? this.nationality.toJSON() : <any>undefined;
        data["Customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        data["IdentityNo"] = this.identityNo;
        data["PassportNo"] = this.passportNo;
        data["OtpSentOn"] = this.otpSentOn ? this.otpSentOn.toISOString() : <any>undefined;
        data["FirstName"] = this.firstName;
        data["LastName"] = this.lastName;
        data["NormalizedFirstName"] = this.normalizedFirstName;
        data["NormalizedLastName"] = this.normalizedLastName;
        data["FatherFirstName"] = this.fatherFirstName;
        data["FatherLastName"] = this.fatherLastName;
        data["MotherFirstName"] = this.motherFirstName;
        data["MotherLastName"] = this.motherLastName;
        data["GenderId"] = this.genderId;
        data["Gender"] = this.gender ? this.gender.toJSON() : <any>undefined;
        data["BloodTypeId"] = this.bloodTypeId;
        data["BloodType"] = this.bloodType ? this.bloodType.toJSON() : <any>undefined;
        data["BirthDate"] = this.birthDate ? this.birthDate.toISOString() : <any>undefined;
        data["BirthInCountry"] = this.birthInCountry;
        data["BirthPlaceCountry"] = this.birthPlaceCountry;
        data["BirthPlaceProvince"] = this.birthPlaceProvince;
        data["BirthPlaceNeighborhood"] = this.birthPlaceNeighborhood;
        data["BirthRegisterNumber"] = this.birthRegisterNumber;
        data["LivingState"] = this.livingState;
        data["MaritalStatus"] = this.maritalStatus;
        data["Religion"] = this.religion;
        data["IsCitizen"] = this.isCitizen;
        data["SSN"] = this.sSN;
        data["SectorId"] = this.sectorId;
        data["Sector"] = this.sector ? this.sector.toJSON() : <any>undefined;
        data["Job"] = this.job;
        data["Notes"] = this.notes;
        data["IsActive"] = this.isActive;
        data["IsVerifiedCitizen"] = this.isVerifiedCitizen;
        data["IsVerifiedForeign"] = this.isVerifiedForeign;
        return data;
    }
}

export interface IRetail {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    nationalityId?: string | undefined;
    nationality?: Country;
    customer?: Customer;
    identityNo?: string | undefined;
    passportNo?: string | undefined;
    otpSentOn?: moment.Moment | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    normalizedFirstName?: string | undefined;
    normalizedLastName?: string | undefined;
    fatherFirstName?: string | undefined;
    fatherLastName?: string | undefined;
    motherFirstName?: string | undefined;
    motherLastName?: string | undefined;
    genderId?: number | undefined;
    gender?: Gender;
    bloodTypeId?: number | undefined;
    bloodType?: BloodType;
    birthDate?: moment.Moment | undefined;
    birthInCountry?: boolean;
    birthPlaceCountry?: string | undefined;
    birthPlaceProvince?: string | undefined;
    birthPlaceNeighborhood?: string | undefined;
    birthRegisterNumber?: string | undefined;
    livingState?: string | undefined;
    maritalStatus?: string | undefined;
    religion?: string | undefined;
    isCitizen?: boolean;
    sSN?: string | undefined;
    sectorId?: number | undefined;
    sector?: CorporateCategory;
    job?: string | undefined;
    notes?: string | undefined;
    isActive?: boolean;
    isVerifiedCitizen?: boolean;
    isVerifiedForeign?: boolean;
}

export class RetailModel implements IRetailModel {
    id?: number;
    nationalityId?: string | undefined;
    nationality?: CountryModel;
    customer?: CustomerModel;
    identityNo?: string | undefined;
    passportNo?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    genderId?: number | undefined;
    gender?: GenderModel;

    constructor(data?: IRetailModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.nationalityId = _data["NationalityId"];
            this.nationality = _data["Nationality"] ? CountryModel.fromJS(_data["Nationality"]) : <any>undefined;
            this.customer = _data["Customer"] ? CustomerModel.fromJS(_data["Customer"]) : <any>undefined;
            this.identityNo = _data["IdentityNo"];
            this.passportNo = _data["PassportNo"];
            this.firstName = _data["FirstName"];
            this.lastName = _data["LastName"];
            this.genderId = _data["GenderId"];
            this.gender = _data["Gender"] ? GenderModel.fromJS(_data["Gender"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RetailModel {
        data = typeof data === 'object' ? data : {};
        let result = new RetailModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["NationalityId"] = this.nationalityId;
        data["Nationality"] = this.nationality ? this.nationality.toJSON() : <any>undefined;
        data["Customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        data["IdentityNo"] = this.identityNo;
        data["PassportNo"] = this.passportNo;
        data["FirstName"] = this.firstName;
        data["LastName"] = this.lastName;
        data["GenderId"] = this.genderId;
        data["Gender"] = this.gender ? this.gender.toJSON() : <any>undefined;
        return data;
    }
}

export interface IRetailModel {
    id?: number;
    nationalityId?: string | undefined;
    nationality?: CountryModel;
    customer?: CustomerModel;
    identityNo?: string | undefined;
    passportNo?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    genderId?: number | undefined;
    gender?: GenderModel;
}

export class Rodyumfix implements IRodyumfix {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IRodyumfix) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): Rodyumfix {
        data = typeof data === 'object' ? data : {};
        let result = new Rodyumfix();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IRodyumfix {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class Role implements IRole {
    id?: number;
    name?: string | undefined;
    normalizedName?: string | undefined;
    concurrencyStamp?: string | undefined;
    description?: string | undefined;
    userRoles?: UserRole[] | undefined;
    isDeleted?: boolean;

    constructor(data?: IRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.name = _data["Name"];
            this.normalizedName = _data["NormalizedName"];
            this.concurrencyStamp = _data["ConcurrencyStamp"];
            this.description = _data["Description"];
            if (Array.isArray(_data["UserRoles"])) {
                this.userRoles = [] as any;
                for (let item of _data["UserRoles"])
                    this.userRoles!.push(UserRole.fromJS(item));
            }
            this.isDeleted = _data["IsDeleted"];
        }
    }

    static fromJS(data: any): Role {
        data = typeof data === 'object' ? data : {};
        let result = new Role();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Name"] = this.name;
        data["NormalizedName"] = this.normalizedName;
        data["ConcurrencyStamp"] = this.concurrencyStamp;
        data["Description"] = this.description;
        if (Array.isArray(this.userRoles)) {
            data["UserRoles"] = [];
            for (let item of this.userRoles)
                data["UserRoles"].push(item.toJSON());
        }
        data["IsDeleted"] = this.isDeleted;
        return data;
    }
}

export interface IRole {
    id?: number;
    name?: string | undefined;
    normalizedName?: string | undefined;
    concurrencyStamp?: string | undefined;
    description?: string | undefined;
    userRoles?: UserRole[] | undefined;
    isDeleted?: boolean;
}

export class RouteData implements IRouteData {
    readonly dataTokens?: { [key: string]: any; } | undefined;
    readonly routers?: IRouter[] | undefined;
    readonly values?: { [key: string]: any; } | undefined;

    constructor(data?: IRouteData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["DataTokens"]) {
                (<any>this).dataTokens = {} as any;
                for (let key in _data["DataTokens"]) {
                    if (_data["DataTokens"].hasOwnProperty(key))
                        (<any>(<any>this).dataTokens)![key] = _data["DataTokens"][key];
                }
            }
            if (Array.isArray(_data["Routers"])) {
                (<any>this).routers = [] as any;
                for (let item of _data["Routers"])
                    (<any>this).routers!.push(IRouter.fromJS(item));
            }
            if (_data["Values"]) {
                (<any>this).values = {} as any;
                for (let key in _data["Values"]) {
                    if (_data["Values"].hasOwnProperty(key))
                        (<any>(<any>this).values)![key] = _data["Values"][key];
                }
            }
        }
    }

    static fromJS(data: any): RouteData {
        data = typeof data === 'object' ? data : {};
        let result = new RouteData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.dataTokens) {
            data["DataTokens"] = {};
            for (let key in this.dataTokens) {
                if (this.dataTokens.hasOwnProperty(key))
                    (<any>data["DataTokens"])[key] = this.dataTokens[key];
            }
        }
        if (Array.isArray(this.routers)) {
            data["Routers"] = [];
            for (let item of this.routers)
                data["Routers"].push(item.toJSON());
        }
        if (this.values) {
            data["Values"] = {};
            for (let key in this.values) {
                if (this.values.hasOwnProperty(key))
                    (<any>data["Values"])[key] = this.values[key];
            }
        }
        return data;
    }
}

export interface IRouteData {
    dataTokens?: { [key: string]: any; } | undefined;
    routers?: IRouter[] | undefined;
    values?: { [key: string]: any; } | undefined;
}

export class RssFeed implements IRssFeed {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    title!: string;
    subTitle?: string | undefined;
    link!: string;

    constructor(data?: IRssFeed) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.createdOn = _data["CreatedOn"] ? moment(_data["CreatedOn"].toString()) : <any>undefined;
            this.createdById = _data["CreatedById"];
            this.createdBy = _data["CreatedBy"] ? User.fromJS(_data["CreatedBy"]) : <any>undefined;
            this.updatedOn = _data["UpdatedOn"] ? moment(_data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedById = _data["UpdatedById"];
            this.updatedBy = _data["UpdatedBy"] ? User.fromJS(_data["UpdatedBy"]) : <any>undefined;
            this.deletedOn = _data["DeletedOn"] ? moment(_data["DeletedOn"].toString()) : <any>undefined;
            this.deletedById = _data["DeletedById"];
            this.deletedBy = _data["DeletedBy"] ? User.fromJS(_data["DeletedBy"]) : <any>undefined;
            this.isDeleted = _data["IsDeleted"];
            this.title = _data["Title"];
            this.subTitle = _data["SubTitle"];
            this.link = _data["Link"];
        }
    }

    static fromJS(data: any): RssFeed {
        data = typeof data === 'object' ? data : {};
        let result = new RssFeed();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedById"] = this.createdById;
        data["CreatedBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["DeletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        data["DeletedById"] = this.deletedById;
        data["DeletedBy"] = this.deletedBy ? this.deletedBy.toJSON() : <any>undefined;
        data["IsDeleted"] = this.isDeleted;
        data["Title"] = this.title;
        data["SubTitle"] = this.subTitle;
        data["Link"] = this.link;
        return data;
    }
}

export interface IRssFeed {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    title: string;
    subTitle?: string | undefined;
    link: string;
}

export class RuntimeFieldHandle implements IRuntimeFieldHandle {
    value?: IntPtr;

    constructor(data?: IRuntimeFieldHandle) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["Value"] ? IntPtr.fromJS(_data["Value"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RuntimeFieldHandle {
        data = typeof data === 'object' ? data : {};
        let result = new RuntimeFieldHandle();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Value"] = this.value ? this.value.toJSON() : <any>undefined;
        return data;
    }
}

export interface IRuntimeFieldHandle {
    value?: IntPtr;
}

export class RuntimeMethodHandle implements IRuntimeMethodHandle {
    value?: IntPtr;

    constructor(data?: IRuntimeMethodHandle) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["Value"] ? IntPtr.fromJS(_data["Value"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RuntimeMethodHandle {
        data = typeof data === 'object' ? data : {};
        let result = new RuntimeMethodHandle();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Value"] = this.value ? this.value.toJSON() : <any>undefined;
        return data;
    }
}

export interface IRuntimeMethodHandle {
    value?: IntPtr;
}

export class RuntimeTypeHandle implements IRuntimeTypeHandle {
    value?: IntPtr;

    constructor(data?: IRuntimeTypeHandle) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["Value"] ? IntPtr.fromJS(_data["Value"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RuntimeTypeHandle {
        data = typeof data === 'object' ? data : {};
        let result = new RuntimeTypeHandle();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Value"] = this.value ? this.value.toJSON() : <any>undefined;
        return data;
    }
}

export interface IRuntimeTypeHandle {
    value?: IntPtr;
}

export class SafeWaitHandle implements ISafeWaitHandle {
    readonly isClosed?: boolean;
    readonly isInvalid?: boolean;

    constructor(data?: ISafeWaitHandle) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isClosed = _data["IsClosed"];
            (<any>this).isInvalid = _data["IsInvalid"];
        }
    }

    static fromJS(data: any): SafeWaitHandle {
        data = typeof data === 'object' ? data : {};
        let result = new SafeWaitHandle();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["IsClosed"] = this.isClosed;
        data["IsInvalid"] = this.isInvalid;
        return data;
    }
}

export interface ISafeWaitHandle {
    isClosed?: boolean;
    isInvalid?: boolean;
}

export class Sar implements ISar {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: ISar) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): Sar {
        data = typeof data === 'object' ? data : {};
        let result = new Sar();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface ISar {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class ScanType implements IScanType {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;

    constructor(data?: IScanType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.createdOn = _data["CreatedOn"] ? moment(_data["CreatedOn"].toString()) : <any>undefined;
            this.createdById = _data["CreatedById"];
            this.createdBy = _data["CreatedBy"] ? User.fromJS(_data["CreatedBy"]) : <any>undefined;
            this.updatedOn = _data["UpdatedOn"] ? moment(_data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedById = _data["UpdatedById"];
            this.updatedBy = _data["UpdatedBy"] ? User.fromJS(_data["UpdatedBy"]) : <any>undefined;
            this.deletedOn = _data["DeletedOn"] ? moment(_data["DeletedOn"].toString()) : <any>undefined;
            this.deletedById = _data["DeletedById"];
            this.deletedBy = _data["DeletedBy"] ? User.fromJS(_data["DeletedBy"]) : <any>undefined;
            this.isDeleted = _data["IsDeleted"];
            this.code = _data["Code"];
            this.description = _data["Description"];
            this.displayOrder = _data["DisplayOrder"];
            this.isActive = _data["IsActive"];
        }
    }

    static fromJS(data: any): ScanType {
        data = typeof data === 'object' ? data : {};
        let result = new ScanType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedById"] = this.createdById;
        data["CreatedBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["DeletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        data["DeletedById"] = this.deletedById;
        data["DeletedBy"] = this.deletedBy ? this.deletedBy.toJSON() : <any>undefined;
        data["IsDeleted"] = this.isDeleted;
        data["Code"] = this.code;
        data["Description"] = this.description;
        data["DisplayOrder"] = this.displayOrder;
        data["IsActive"] = this.isActive;
        return data;
    }
}

export interface IScanType {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;
}

export enum SecurityRuleSet {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export class Sek implements ISek {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: ISek) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): Sek {
        data = typeof data === 'object' ? data : {};
        let result = new Sek();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface ISek {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class Setting implements ISetting {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    key?: string | undefined;
    value?: string | undefined;

    constructor(data?: ISetting) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.createdOn = _data["CreatedOn"] ? moment(_data["CreatedOn"].toString()) : <any>undefined;
            this.createdById = _data["CreatedById"];
            this.createdBy = _data["CreatedBy"] ? User.fromJS(_data["CreatedBy"]) : <any>undefined;
            this.updatedOn = _data["UpdatedOn"] ? moment(_data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedById = _data["UpdatedById"];
            this.updatedBy = _data["UpdatedBy"] ? User.fromJS(_data["UpdatedBy"]) : <any>undefined;
            this.deletedOn = _data["DeletedOn"] ? moment(_data["DeletedOn"].toString()) : <any>undefined;
            this.deletedById = _data["DeletedById"];
            this.deletedBy = _data["DeletedBy"] ? User.fromJS(_data["DeletedBy"]) : <any>undefined;
            this.isDeleted = _data["IsDeleted"];
            this.key = _data["Key"];
            this.value = _data["Value"];
        }
    }

    static fromJS(data: any): Setting {
        data = typeof data === 'object' ? data : {};
        let result = new Setting();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedById"] = this.createdById;
        data["CreatedBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["DeletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        data["DeletedById"] = this.deletedById;
        data["DeletedBy"] = this.deletedBy ? this.deletedBy.toJSON() : <any>undefined;
        data["IsDeleted"] = this.isDeleted;
        data["Key"] = this.key;
        data["Value"] = this.value;
        return data;
    }
}

export interface ISetting {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    key?: string | undefined;
    value?: string | undefined;
}

export class StaticPage implements IStaticPage {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    title!: string;
    subTitle?: string | undefined;
    slug?: string | undefined;
    metaKeywords?: string | undefined;
    metaDescription?: string | undefined;
    body?: string | undefined;
    mediaId?: number | undefined;
    media?: Media;
    isPublished?: boolean;
    publishedOn?: moment.Moment | undefined;
    publishedTill?: moment.Moment | undefined;

    constructor(data?: IStaticPage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.createdOn = _data["CreatedOn"] ? moment(_data["CreatedOn"].toString()) : <any>undefined;
            this.createdById = _data["CreatedById"];
            this.createdBy = _data["CreatedBy"] ? User.fromJS(_data["CreatedBy"]) : <any>undefined;
            this.updatedOn = _data["UpdatedOn"] ? moment(_data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedById = _data["UpdatedById"];
            this.updatedBy = _data["UpdatedBy"] ? User.fromJS(_data["UpdatedBy"]) : <any>undefined;
            this.deletedOn = _data["DeletedOn"] ? moment(_data["DeletedOn"].toString()) : <any>undefined;
            this.deletedById = _data["DeletedById"];
            this.deletedBy = _data["DeletedBy"] ? User.fromJS(_data["DeletedBy"]) : <any>undefined;
            this.isDeleted = _data["IsDeleted"];
            this.title = _data["Title"];
            this.subTitle = _data["SubTitle"];
            this.slug = _data["Slug"];
            this.metaKeywords = _data["MetaKeywords"];
            this.metaDescription = _data["MetaDescription"];
            this.body = _data["Body"];
            this.mediaId = _data["MediaId"];
            this.media = _data["Media"] ? Media.fromJS(_data["Media"]) : <any>undefined;
            this.isPublished = _data["IsPublished"];
            this.publishedOn = _data["PublishedOn"] ? moment(_data["PublishedOn"].toString()) : <any>undefined;
            this.publishedTill = _data["PublishedTill"] ? moment(_data["PublishedTill"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): StaticPage {
        data = typeof data === 'object' ? data : {};
        let result = new StaticPage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedById"] = this.createdById;
        data["CreatedBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["DeletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        data["DeletedById"] = this.deletedById;
        data["DeletedBy"] = this.deletedBy ? this.deletedBy.toJSON() : <any>undefined;
        data["IsDeleted"] = this.isDeleted;
        data["Title"] = this.title;
        data["SubTitle"] = this.subTitle;
        data["Slug"] = this.slug;
        data["MetaKeywords"] = this.metaKeywords;
        data["MetaDescription"] = this.metaDescription;
        data["Body"] = this.body;
        data["MediaId"] = this.mediaId;
        data["Media"] = this.media ? this.media.toJSON() : <any>undefined;
        data["IsPublished"] = this.isPublished;
        data["PublishedOn"] = this.publishedOn ? this.publishedOn.toISOString() : <any>undefined;
        data["PublishedTill"] = this.publishedTill ? this.publishedTill.toISOString() : <any>undefined;
        return data;
    }
}

export interface IStaticPage {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    title: string;
    subTitle?: string | undefined;
    slug?: string | undefined;
    metaKeywords?: string | undefined;
    metaDescription?: string | undefined;
    body?: string | undefined;
    mediaId?: number | undefined;
    media?: Media;
    isPublished?: boolean;
    publishedOn?: moment.Moment | undefined;
    publishedTill?: moment.Moment | undefined;
}

export class Store implements IStore {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    name?: string | undefined;
    customer?: Customer;
    storeInvetories?: StoreInventory[] | undefined;

    constructor(data?: IStore) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.createdOn = _data["CreatedOn"] ? moment(_data["CreatedOn"].toString()) : <any>undefined;
            this.createdById = _data["CreatedById"];
            this.createdBy = _data["CreatedBy"] ? User.fromJS(_data["CreatedBy"]) : <any>undefined;
            this.updatedOn = _data["UpdatedOn"] ? moment(_data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedById = _data["UpdatedById"];
            this.updatedBy = _data["UpdatedBy"] ? User.fromJS(_data["UpdatedBy"]) : <any>undefined;
            this.deletedOn = _data["DeletedOn"] ? moment(_data["DeletedOn"].toString()) : <any>undefined;
            this.deletedById = _data["DeletedById"];
            this.deletedBy = _data["DeletedBy"] ? User.fromJS(_data["DeletedBy"]) : <any>undefined;
            this.isDeleted = _data["IsDeleted"];
            this.name = _data["Name"];
            this.customer = _data["Customer"] ? Customer.fromJS(_data["Customer"]) : <any>undefined;
            if (Array.isArray(_data["StoreInvetories"])) {
                this.storeInvetories = [] as any;
                for (let item of _data["StoreInvetories"])
                    this.storeInvetories!.push(StoreInventory.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Store {
        data = typeof data === 'object' ? data : {};
        let result = new Store();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedById"] = this.createdById;
        data["CreatedBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["DeletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        data["DeletedById"] = this.deletedById;
        data["DeletedBy"] = this.deletedBy ? this.deletedBy.toJSON() : <any>undefined;
        data["IsDeleted"] = this.isDeleted;
        data["Name"] = this.name;
        data["Customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        if (Array.isArray(this.storeInvetories)) {
            data["StoreInvetories"] = [];
            for (let item of this.storeInvetories)
                data["StoreInvetories"].push(item.toJSON());
        }
        return data;
    }
}

export interface IStore {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    name?: string | undefined;
    customer?: Customer;
    storeInvetories?: StoreInventory[] | undefined;
}

export class StoreInventory implements IStoreInventory {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    storeId?: number;
    store?: Store;
    productId?: number;
    product?: Product;
    quantity?: number;

    constructor(data?: IStoreInventory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.createdOn = _data["CreatedOn"] ? moment(_data["CreatedOn"].toString()) : <any>undefined;
            this.createdById = _data["CreatedById"];
            this.createdBy = _data["CreatedBy"] ? User.fromJS(_data["CreatedBy"]) : <any>undefined;
            this.updatedOn = _data["UpdatedOn"] ? moment(_data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedById = _data["UpdatedById"];
            this.updatedBy = _data["UpdatedBy"] ? User.fromJS(_data["UpdatedBy"]) : <any>undefined;
            this.deletedOn = _data["DeletedOn"] ? moment(_data["DeletedOn"].toString()) : <any>undefined;
            this.deletedById = _data["DeletedById"];
            this.deletedBy = _data["DeletedBy"] ? User.fromJS(_data["DeletedBy"]) : <any>undefined;
            this.isDeleted = _data["IsDeleted"];
            this.storeId = _data["StoreId"];
            this.store = _data["Store"] ? Store.fromJS(_data["Store"]) : <any>undefined;
            this.productId = _data["ProductId"];
            this.product = _data["Product"] ? Product.fromJS(_data["Product"]) : <any>undefined;
            this.quantity = _data["Quantity"];
        }
    }

    static fromJS(data: any): StoreInventory {
        data = typeof data === 'object' ? data : {};
        let result = new StoreInventory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedById"] = this.createdById;
        data["CreatedBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["DeletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        data["DeletedById"] = this.deletedById;
        data["DeletedBy"] = this.deletedBy ? this.deletedBy.toJSON() : <any>undefined;
        data["IsDeleted"] = this.isDeleted;
        data["StoreId"] = this.storeId;
        data["Store"] = this.store ? this.store.toJSON() : <any>undefined;
        data["ProductId"] = this.productId;
        data["Product"] = this.product ? this.product.toJSON() : <any>undefined;
        data["Quantity"] = this.quantity;
        return data;
    }
}

export interface IStoreInventory {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    storeId?: number;
    store?: Store;
    productId?: number;
    product?: Product;
    quantity?: number;
}

export class Stream implements IStream {
    readonly canRead?: boolean;
    readonly canSeek?: boolean;
    readonly canTimeout?: boolean;
    readonly canWrite?: boolean;
    readonly length?: number;
    position?: number;
    readTimeout?: number;
    writeTimeout?: number;

    constructor(data?: IStream) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).canRead = _data["CanRead"];
            (<any>this).canSeek = _data["CanSeek"];
            (<any>this).canTimeout = _data["CanTimeout"];
            (<any>this).canWrite = _data["CanWrite"];
            (<any>this).length = _data["Length"];
            this.position = _data["Position"];
            this.readTimeout = _data["ReadTimeout"];
            this.writeTimeout = _data["WriteTimeout"];
        }
    }

    static fromJS(data: any): Stream {
        data = typeof data === 'object' ? data : {};
        let result = new Stream();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["CanRead"] = this.canRead;
        data["CanSeek"] = this.canSeek;
        data["CanTimeout"] = this.canTimeout;
        data["CanWrite"] = this.canWrite;
        data["Length"] = this.length;
        data["Position"] = this.position;
        data["ReadTimeout"] = this.readTimeout;
        data["WriteTimeout"] = this.writeTimeout;
        return data;
    }
}

export interface IStream {
    canRead?: boolean;
    canSeek?: boolean;
    canTimeout?: boolean;
    canWrite?: boolean;
    length?: number;
    position?: number;
    readTimeout?: number;
    writeTimeout?: number;
}

export class StringFunc implements IStringFunc {
    readonly target?: any | undefined;
    method?: MethodInfo;

    constructor(data?: IStringFunc) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).target = _data["Target"];
            this.method = _data["Method"] ? MethodInfo.fromJS(_data["Method"]) : <any>undefined;
        }
    }

    static fromJS(data: any): StringFunc {
        data = typeof data === 'object' ? data : {};
        let result = new StringFunc();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Target"] = this.target;
        data["Method"] = this.method ? this.method.toJSON() : <any>undefined;
        return data;
    }
}

export interface IStringFunc {
    target?: any | undefined;
    method?: MethodInfo;
}

export class StringStringFunc implements IStringStringFunc {
    readonly target?: any | undefined;
    method?: MethodInfo;

    constructor(data?: IStringStringFunc) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).target = _data["Target"];
            this.method = _data["Method"] ? MethodInfo.fromJS(_data["Method"]) : <any>undefined;
        }
    }

    static fromJS(data: any): StringStringFunc {
        data = typeof data === 'object' ? data : {};
        let result = new StringStringFunc();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Target"] = this.target;
        data["Method"] = this.method ? this.method.toJSON() : <any>undefined;
        return data;
    }
}

export interface IStringStringFunc {
    target?: any | undefined;
    method?: MethodInfo;
}

export class StringStringKeyValuePair implements IStringStringKeyValuePair {
    readonly key?: string | undefined;
    readonly value?: string | undefined;

    constructor(data?: IStringStringKeyValuePair) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).key = _data["Key"];
            (<any>this).value = _data["Value"];
        }
    }

    static fromJS(data: any): StringStringKeyValuePair {
        data = typeof data === 'object' ? data : {};
        let result = new StringStringKeyValuePair();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Key"] = this.key;
        data["Value"] = this.value;
        return data;
    }
}

export interface IStringStringKeyValuePair {
    key?: string | undefined;
    value?: string | undefined;
}

export class StringStringStringFunc implements IStringStringStringFunc {
    readonly target?: any | undefined;
    method?: MethodInfo;

    constructor(data?: IStringStringStringFunc) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).target = _data["Target"];
            this.method = _data["Method"] ? MethodInfo.fromJS(_data["Method"]) : <any>undefined;
        }
    }

    static fromJS(data: any): StringStringStringFunc {
        data = typeof data === 'object' ? data : {};
        let result = new StringStringStringFunc();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Target"] = this.target;
        data["Method"] = this.method ? this.method.toJSON() : <any>undefined;
        return data;
    }
}

export interface IStringStringStringFunc {
    target?: any | undefined;
    method?: MethodInfo;
}

export class StringStringValuesKeyValuePair implements IStringStringValuesKeyValuePair {
    readonly key?: string | undefined;
    readonly value?: string[];

    constructor(data?: IStringStringValuesKeyValuePair) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).key = _data["Key"];
            if (Array.isArray(_data["Value"])) {
                (<any>this).value = [] as any;
                for (let item of _data["Value"])
                    (<any>this).value!.push(item);
            }
        }
    }

    static fromJS(data: any): StringStringValuesKeyValuePair {
        data = typeof data === 'object' ? data : {};
        let result = new StringStringValuesKeyValuePair();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Key"] = this.key;
        if (Array.isArray(this.value)) {
            data["Value"] = [];
            for (let item of this.value)
                data["Value"].push(item);
        }
        return data;
    }
}

export interface IStringStringValuesKeyValuePair {
    key?: string | undefined;
    value?: string[];
}

export class StructLayoutAttribute implements IStructLayoutAttribute {
    readonly typeId?: any | undefined;
    value?: LayoutKind;

    constructor(data?: IStructLayoutAttribute) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).typeId = _data["TypeId"];
            this.value = _data["Value"];
        }
    }

    static fromJS(data: any): StructLayoutAttribute {
        data = typeof data === 'object' ? data : {};
        let result = new StructLayoutAttribute();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["TypeId"] = this.typeId;
        data["Value"] = this.value;
        return data;
    }
}

export interface IStructLayoutAttribute {
    typeId?: any | undefined;
    value?: LayoutKind;
}

export class Symbol implements ISymbol {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    countryId?: string | undefined;
    country?: Country;
    symbolTypeId?: number;
    symbolType?: SymbolType;
    mediaId?: number | undefined;
    media?: Media;
    isoCode?: string | undefined;
    matriksId?: number;
    matriksCode?: string | undefined;
    name?: string | undefined;
    isActive?: boolean;
    isSyncRateEnabled?: boolean;
    isMainCurrency?: boolean;
    isTradeable?: boolean;
    buyAddPercent?: number;
    buyAddValue?: number;
    sellAddPercent?: number;
    sellAddValue?: number;

    constructor(data?: ISymbol) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.createdOn = _data["CreatedOn"] ? moment(_data["CreatedOn"].toString()) : <any>undefined;
            this.createdById = _data["CreatedById"];
            this.createdBy = _data["CreatedBy"] ? User.fromJS(_data["CreatedBy"]) : <any>undefined;
            this.updatedOn = _data["UpdatedOn"] ? moment(_data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedById = _data["UpdatedById"];
            this.updatedBy = _data["UpdatedBy"] ? User.fromJS(_data["UpdatedBy"]) : <any>undefined;
            this.deletedOn = _data["DeletedOn"] ? moment(_data["DeletedOn"].toString()) : <any>undefined;
            this.deletedById = _data["DeletedById"];
            this.deletedBy = _data["DeletedBy"] ? User.fromJS(_data["DeletedBy"]) : <any>undefined;
            this.isDeleted = _data["IsDeleted"];
            this.countryId = _data["CountryId"];
            this.country = _data["Country"] ? Country.fromJS(_data["Country"]) : <any>undefined;
            this.symbolTypeId = _data["SymbolTypeId"];
            this.symbolType = _data["SymbolType"] ? SymbolType.fromJS(_data["SymbolType"]) : <any>undefined;
            this.mediaId = _data["MediaId"];
            this.media = _data["Media"] ? Media.fromJS(_data["Media"]) : <any>undefined;
            this.isoCode = _data["IsoCode"];
            this.matriksId = _data["MatriksId"];
            this.matriksCode = _data["MatriksCode"];
            this.name = _data["Name"];
            this.isActive = _data["IsActive"];
            this.isSyncRateEnabled = _data["IsSyncRateEnabled"];
            this.isMainCurrency = _data["IsMainCurrency"];
            this.isTradeable = _data["IsTradeable"];
            this.buyAddPercent = _data["BuyAddPercent"];
            this.buyAddValue = _data["BuyAddValue"];
            this.sellAddPercent = _data["SellAddPercent"];
            this.sellAddValue = _data["SellAddValue"];
        }
    }

    static fromJS(data: any): Symbol {
        data = typeof data === 'object' ? data : {};
        let result = new Symbol();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedById"] = this.createdById;
        data["CreatedBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["DeletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        data["DeletedById"] = this.deletedById;
        data["DeletedBy"] = this.deletedBy ? this.deletedBy.toJSON() : <any>undefined;
        data["IsDeleted"] = this.isDeleted;
        data["CountryId"] = this.countryId;
        data["Country"] = this.country ? this.country.toJSON() : <any>undefined;
        data["SymbolTypeId"] = this.symbolTypeId;
        data["SymbolType"] = this.symbolType ? this.symbolType.toJSON() : <any>undefined;
        data["MediaId"] = this.mediaId;
        data["Media"] = this.media ? this.media.toJSON() : <any>undefined;
        data["IsoCode"] = this.isoCode;
        data["MatriksId"] = this.matriksId;
        data["MatriksCode"] = this.matriksCode;
        data["Name"] = this.name;
        data["IsActive"] = this.isActive;
        data["IsSyncRateEnabled"] = this.isSyncRateEnabled;
        data["IsMainCurrency"] = this.isMainCurrency;
        data["IsTradeable"] = this.isTradeable;
        data["BuyAddPercent"] = this.buyAddPercent;
        data["BuyAddValue"] = this.buyAddValue;
        data["SellAddPercent"] = this.sellAddPercent;
        data["SellAddValue"] = this.sellAddValue;
        return data;
    }
}

export interface ISymbol {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    countryId?: string | undefined;
    country?: Country;
    symbolTypeId?: number;
    symbolType?: SymbolType;
    mediaId?: number | undefined;
    media?: Media;
    isoCode?: string | undefined;
    matriksId?: number;
    matriksCode?: string | undefined;
    name?: string | undefined;
    isActive?: boolean;
    isSyncRateEnabled?: boolean;
    isMainCurrency?: boolean;
    isTradeable?: boolean;
    buyAddPercent?: number;
    buyAddValue?: number;
    sellAddPercent?: number;
    sellAddValue?: number;
}

export class SymbolType implements ISymbolType {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;

    constructor(data?: ISymbolType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.createdOn = _data["CreatedOn"] ? moment(_data["CreatedOn"].toString()) : <any>undefined;
            this.createdById = _data["CreatedById"];
            this.createdBy = _data["CreatedBy"] ? User.fromJS(_data["CreatedBy"]) : <any>undefined;
            this.updatedOn = _data["UpdatedOn"] ? moment(_data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedById = _data["UpdatedById"];
            this.updatedBy = _data["UpdatedBy"] ? User.fromJS(_data["UpdatedBy"]) : <any>undefined;
            this.deletedOn = _data["DeletedOn"] ? moment(_data["DeletedOn"].toString()) : <any>undefined;
            this.deletedById = _data["DeletedById"];
            this.deletedBy = _data["DeletedBy"] ? User.fromJS(_data["DeletedBy"]) : <any>undefined;
            this.isDeleted = _data["IsDeleted"];
            this.code = _data["Code"];
            this.description = _data["Description"];
            this.displayOrder = _data["DisplayOrder"];
            this.isActive = _data["IsActive"];
        }
    }

    static fromJS(data: any): SymbolType {
        data = typeof data === 'object' ? data : {};
        let result = new SymbolType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedById"] = this.createdById;
        data["CreatedBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["DeletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        data["DeletedById"] = this.deletedById;
        data["DeletedBy"] = this.deletedBy ? this.deletedBy.toJSON() : <any>undefined;
        data["IsDeleted"] = this.isDeleted;
        data["Code"] = this.code;
        data["Description"] = this.description;
        data["DisplayOrder"] = this.displayOrder;
        data["IsActive"] = this.isActive;
        return data;
    }
}

export interface ISymbolType {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;
}

export class TextWriter implements ITextWriter {
    formatProvider?: IFormatProvider;
    encoding?: Encoding;
    newLine?: string | undefined;

    constructor(data?: ITextWriter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.formatProvider = _data["FormatProvider"] ? IFormatProvider.fromJS(_data["FormatProvider"]) : <any>undefined;
            this.encoding = _data["Encoding"] ? Encoding.fromJS(_data["Encoding"]) : <any>undefined;
            this.newLine = _data["NewLine"];
        }
    }

    static fromJS(data: any): TextWriter {
        data = typeof data === 'object' ? data : {};
        let result = new TextWriter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["FormatProvider"] = this.formatProvider ? this.formatProvider.toJSON() : <any>undefined;
        data["Encoding"] = this.encoding ? this.encoding.toJSON() : <any>undefined;
        data["NewLine"] = this.newLine;
        return data;
    }
}

export interface ITextWriter {
    formatProvider?: IFormatProvider;
    encoding?: Encoding;
    newLine?: string | undefined;
}

export class TimeSpan implements ITimeSpan {
    readonly ticks?: number;
    readonly days?: number;
    readonly hours?: number;
    readonly milliseconds?: number;
    readonly minutes?: number;
    readonly seconds?: number;
    readonly totalDays?: number;
    readonly totalHours?: number;
    readonly totalMilliseconds?: number;
    readonly totalMinutes?: number;
    readonly totalSeconds?: number;

    constructor(data?: ITimeSpan) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).ticks = _data["Ticks"];
            (<any>this).days = _data["Days"];
            (<any>this).hours = _data["Hours"];
            (<any>this).milliseconds = _data["Milliseconds"];
            (<any>this).minutes = _data["Minutes"];
            (<any>this).seconds = _data["Seconds"];
            (<any>this).totalDays = _data["TotalDays"];
            (<any>this).totalHours = _data["TotalHours"];
            (<any>this).totalMilliseconds = _data["TotalMilliseconds"];
            (<any>this).totalMinutes = _data["TotalMinutes"];
            (<any>this).totalSeconds = _data["TotalSeconds"];
        }
    }

    static fromJS(data: any): TimeSpan {
        data = typeof data === 'object' ? data : {};
        let result = new TimeSpan();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Ticks"] = this.ticks;
        data["Days"] = this.days;
        data["Hours"] = this.hours;
        data["Milliseconds"] = this.milliseconds;
        data["Minutes"] = this.minutes;
        data["Seconds"] = this.seconds;
        data["TotalDays"] = this.totalDays;
        data["TotalHours"] = this.totalHours;
        data["TotalMilliseconds"] = this.totalMilliseconds;
        data["TotalMinutes"] = this.totalMinutes;
        data["TotalSeconds"] = this.totalSeconds;
        return data;
    }
}

export interface ITimeSpan {
    ticks?: number;
    days?: number;
    hours?: number;
    milliseconds?: number;
    minutes?: number;
    seconds?: number;
    totalDays?: number;
    totalHours?: number;
    totalMilliseconds?: number;
    totalMinutes?: number;
    totalSeconds?: number;
}

export class Transaction implements ITransaction {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    customerId?: number;
    customer?: Customer;
    symbolId?: number;
    symbol?: Symbol;
    transactionTypeId?: number;
    transactionType?: TransactionType;
    paymentTypeId?: number;
    paymentType?: PaymentType;
    actionDate?: moment.Moment;
    quantity?: number;
    amount?: number;
    netAmount?: number;
    commissionAmount?: number;
    tax?: number;
    kpayTxnId?: string | undefined;
    paymentCardId?: string | undefined;
    paymentMessage?: string | undefined;
    description?: string | undefined;

    constructor(data?: ITransaction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.createdOn = _data["CreatedOn"] ? moment(_data["CreatedOn"].toString()) : <any>undefined;
            this.createdById = _data["CreatedById"];
            this.createdBy = _data["CreatedBy"] ? User.fromJS(_data["CreatedBy"]) : <any>undefined;
            this.updatedOn = _data["UpdatedOn"] ? moment(_data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedById = _data["UpdatedById"];
            this.updatedBy = _data["UpdatedBy"] ? User.fromJS(_data["UpdatedBy"]) : <any>undefined;
            this.deletedOn = _data["DeletedOn"] ? moment(_data["DeletedOn"].toString()) : <any>undefined;
            this.deletedById = _data["DeletedById"];
            this.deletedBy = _data["DeletedBy"] ? User.fromJS(_data["DeletedBy"]) : <any>undefined;
            this.isDeleted = _data["IsDeleted"];
            this.customerId = _data["CustomerId"];
            this.customer = _data["Customer"] ? Customer.fromJS(_data["Customer"]) : <any>undefined;
            this.symbolId = _data["SymbolId"];
            this.symbol = _data["Symbol"] ? Symbol.fromJS(_data["Symbol"]) : <any>undefined;
            this.transactionTypeId = _data["TransactionTypeId"];
            this.transactionType = _data["TransactionType"] ? TransactionType.fromJS(_data["TransactionType"]) : <any>undefined;
            this.paymentTypeId = _data["PaymentTypeId"];
            this.paymentType = _data["PaymentType"] ? PaymentType.fromJS(_data["PaymentType"]) : <any>undefined;
            this.actionDate = _data["ActionDate"] ? moment(_data["ActionDate"].toString()) : <any>undefined;
            this.quantity = _data["Quantity"];
            this.amount = _data["Amount"];
            this.netAmount = _data["NetAmount"];
            this.commissionAmount = _data["CommissionAmount"];
            this.tax = _data["Tax"];
            this.kpayTxnId = _data["KpayTxnId"];
            this.paymentCardId = _data["PaymentCardId"];
            this.paymentMessage = _data["PaymentMessage"];
            this.description = _data["Description"];
        }
    }

    static fromJS(data: any): Transaction {
        data = typeof data === 'object' ? data : {};
        let result = new Transaction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedById"] = this.createdById;
        data["CreatedBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["DeletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        data["DeletedById"] = this.deletedById;
        data["DeletedBy"] = this.deletedBy ? this.deletedBy.toJSON() : <any>undefined;
        data["IsDeleted"] = this.isDeleted;
        data["CustomerId"] = this.customerId;
        data["Customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        data["SymbolId"] = this.symbolId;
        data["Symbol"] = this.symbol ? this.symbol.toJSON() : <any>undefined;
        data["TransactionTypeId"] = this.transactionTypeId;
        data["TransactionType"] = this.transactionType ? this.transactionType.toJSON() : <any>undefined;
        data["PaymentTypeId"] = this.paymentTypeId;
        data["PaymentType"] = this.paymentType ? this.paymentType.toJSON() : <any>undefined;
        data["ActionDate"] = this.actionDate ? this.actionDate.toISOString() : <any>undefined;
        data["Quantity"] = this.quantity;
        data["Amount"] = this.amount;
        data["NetAmount"] = this.netAmount;
        data["CommissionAmount"] = this.commissionAmount;
        data["Tax"] = this.tax;
        data["KpayTxnId"] = this.kpayTxnId;
        data["PaymentCardId"] = this.paymentCardId;
        data["PaymentMessage"] = this.paymentMessage;
        data["Description"] = this.description;
        return data;
    }
}

export interface ITransaction {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    customerId?: number;
    customer?: Customer;
    symbolId?: number;
    symbol?: Symbol;
    transactionTypeId?: number;
    transactionType?: TransactionType;
    paymentTypeId?: number;
    paymentType?: PaymentType;
    actionDate?: moment.Moment;
    quantity?: number;
    amount?: number;
    netAmount?: number;
    commissionAmount?: number;
    tax?: number;
    kpayTxnId?: string | undefined;
    paymentCardId?: string | undefined;
    paymentMessage?: string | undefined;
    description?: string | undefined;
}

export class TransactionRequestModel implements ITransactionRequestModel {
    customerId?: number;
    symbolId?: number;
    transactionTypeId?: number;
    startDate?: moment.Moment;
    endDate?: moment.Moment;

    constructor(data?: ITransactionRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.customerId = _data["CustomerId"];
            this.symbolId = _data["SymbolId"];
            this.transactionTypeId = _data["TransactionTypeId"];
            this.startDate = _data["StartDate"] ? moment(_data["StartDate"].toString()) : <any>undefined;
            this.endDate = _data["EndDate"] ? moment(_data["EndDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): TransactionRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["CustomerId"] = this.customerId;
        data["SymbolId"] = this.symbolId;
        data["TransactionTypeId"] = this.transactionTypeId;
        data["StartDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["EndDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface ITransactionRequestModel {
    customerId?: number;
    symbolId?: number;
    transactionTypeId?: number;
    startDate?: moment.Moment;
    endDate?: moment.Moment;
}

export class TransactionType implements ITransactionType {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;

    constructor(data?: ITransactionType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.createdOn = _data["CreatedOn"] ? moment(_data["CreatedOn"].toString()) : <any>undefined;
            this.createdById = _data["CreatedById"];
            this.createdBy = _data["CreatedBy"] ? User.fromJS(_data["CreatedBy"]) : <any>undefined;
            this.updatedOn = _data["UpdatedOn"] ? moment(_data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedById = _data["UpdatedById"];
            this.updatedBy = _data["UpdatedBy"] ? User.fromJS(_data["UpdatedBy"]) : <any>undefined;
            this.deletedOn = _data["DeletedOn"] ? moment(_data["DeletedOn"].toString()) : <any>undefined;
            this.deletedById = _data["DeletedById"];
            this.deletedBy = _data["DeletedBy"] ? User.fromJS(_data["DeletedBy"]) : <any>undefined;
            this.isDeleted = _data["IsDeleted"];
            this.code = _data["Code"];
            this.description = _data["Description"];
            this.displayOrder = _data["DisplayOrder"];
            this.isActive = _data["IsActive"];
        }
    }

    static fromJS(data: any): TransactionType {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedById"] = this.createdById;
        data["CreatedBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["DeletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        data["DeletedById"] = this.deletedById;
        data["DeletedBy"] = this.deletedBy ? this.deletedBy.toJSON() : <any>undefined;
        data["IsDeleted"] = this.isDeleted;
        data["Code"] = this.code;
        data["Description"] = this.description;
        data["DisplayOrder"] = this.displayOrder;
        data["IsActive"] = this.isActive;
        return data;
    }
}

export interface ITransactionType {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;
}

export class Type implements IType {
    readonly name?: string | undefined;
    readonly customAttributes?: CustomAttributeData[] | undefined;
    readonly isCollectible?: boolean;
    readonly metadataToken?: number;
    readonly isInterface?: boolean;
    memberType?: MemberTypes;
    readonly namespace?: string | undefined;
    readonly assemblyQualifiedName?: string | undefined;
    readonly fullName?: string | undefined;
    assembly?: Assembly;
    module?: Module;
    readonly isNested?: boolean;
    declaringType?: Type;
    declaringMethod?: MethodBase;
    reflectedType?: Type;
    underlyingSystemType?: Type;
    readonly isTypeDefinition?: boolean;
    readonly isArray?: boolean;
    readonly isByRef?: boolean;
    readonly isPointer?: boolean;
    readonly isConstructedGenericType?: boolean;
    readonly isGenericParameter?: boolean;
    readonly isGenericTypeParameter?: boolean;
    readonly isGenericMethodParameter?: boolean;
    readonly isGenericType?: boolean;
    readonly isGenericTypeDefinition?: boolean;
    readonly isSZArray?: boolean;
    readonly isVariableBoundArray?: boolean;
    readonly isByRefLike?: boolean;
    readonly hasElementType?: boolean;
    readonly genericTypeArguments?: Type[] | undefined;
    readonly genericParameterPosition?: number;
    genericParameterAttributes?: GenericParameterAttributes;
    attributes?: TypeAttributes;
    readonly isAbstract?: boolean;
    readonly isImport?: boolean;
    readonly isSealed?: boolean;
    readonly isSpecialName?: boolean;
    readonly isClass?: boolean;
    readonly isNestedAssembly?: boolean;
    readonly isNestedFamANDAssem?: boolean;
    readonly isNestedFamily?: boolean;
    readonly isNestedFamORAssem?: boolean;
    readonly isNestedPrivate?: boolean;
    readonly isNestedPublic?: boolean;
    readonly isNotPublic?: boolean;
    readonly isPublic?: boolean;
    readonly isAutoLayout?: boolean;
    readonly isExplicitLayout?: boolean;
    readonly isLayoutSequential?: boolean;
    readonly isAnsiClass?: boolean;
    readonly isAutoClass?: boolean;
    readonly isUnicodeClass?: boolean;
    readonly isCOMObject?: boolean;
    readonly isContextful?: boolean;
    readonly isEnum?: boolean;
    readonly isMarshalByRef?: boolean;
    readonly isPrimitive?: boolean;
    readonly isValueType?: boolean;
    readonly isSignatureType?: boolean;
    readonly isSecurityCritical?: boolean;
    readonly isSecuritySafeCritical?: boolean;
    readonly isSecurityTransparent?: boolean;
    structLayoutAttribute?: StructLayoutAttribute;
    typeInitializer?: ConstructorInfo;
    typeHandle?: RuntimeTypeHandle;
    readonly gUID?: string;
    baseType?: Type;
    readonly isSerializable?: boolean;
    readonly containsGenericParameters?: boolean;
    readonly isVisible?: boolean;

    constructor(data?: IType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).name = _data["Name"];
            if (Array.isArray(_data["CustomAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["CustomAttributes"])
                    (<any>this).customAttributes!.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).isCollectible = _data["IsCollectible"];
            (<any>this).metadataToken = _data["MetadataToken"];
            (<any>this).isInterface = _data["IsInterface"];
            this.memberType = _data["MemberType"];
            (<any>this).namespace = _data["Namespace"];
            (<any>this).assemblyQualifiedName = _data["AssemblyQualifiedName"];
            (<any>this).fullName = _data["FullName"];
            this.assembly = _data["Assembly"] ? Assembly.fromJS(_data["Assembly"]) : <any>undefined;
            this.module = _data["Module"] ? Module.fromJS(_data["Module"]) : <any>undefined;
            (<any>this).isNested = _data["IsNested"];
            this.declaringType = _data["DeclaringType"] ? Type.fromJS(_data["DeclaringType"]) : <any>undefined;
            this.declaringMethod = _data["DeclaringMethod"] ? MethodBase.fromJS(_data["DeclaringMethod"]) : <any>undefined;
            this.reflectedType = _data["ReflectedType"] ? Type.fromJS(_data["ReflectedType"]) : <any>undefined;
            this.underlyingSystemType = _data["UnderlyingSystemType"] ? Type.fromJS(_data["UnderlyingSystemType"]) : <any>undefined;
            (<any>this).isTypeDefinition = _data["IsTypeDefinition"];
            (<any>this).isArray = _data["IsArray"];
            (<any>this).isByRef = _data["IsByRef"];
            (<any>this).isPointer = _data["IsPointer"];
            (<any>this).isConstructedGenericType = _data["IsConstructedGenericType"];
            (<any>this).isGenericParameter = _data["IsGenericParameter"];
            (<any>this).isGenericTypeParameter = _data["IsGenericTypeParameter"];
            (<any>this).isGenericMethodParameter = _data["IsGenericMethodParameter"];
            (<any>this).isGenericType = _data["IsGenericType"];
            (<any>this).isGenericTypeDefinition = _data["IsGenericTypeDefinition"];
            (<any>this).isSZArray = _data["IsSZArray"];
            (<any>this).isVariableBoundArray = _data["IsVariableBoundArray"];
            (<any>this).isByRefLike = _data["IsByRefLike"];
            (<any>this).hasElementType = _data["HasElementType"];
            if (Array.isArray(_data["GenericTypeArguments"])) {
                (<any>this).genericTypeArguments = [] as any;
                for (let item of _data["GenericTypeArguments"])
                    (<any>this).genericTypeArguments!.push(Type.fromJS(item));
            }
            (<any>this).genericParameterPosition = _data["GenericParameterPosition"];
            this.genericParameterAttributes = _data["GenericParameterAttributes"];
            this.attributes = _data["Attributes"];
            (<any>this).isAbstract = _data["IsAbstract"];
            (<any>this).isImport = _data["IsImport"];
            (<any>this).isSealed = _data["IsSealed"];
            (<any>this).isSpecialName = _data["IsSpecialName"];
            (<any>this).isClass = _data["IsClass"];
            (<any>this).isNestedAssembly = _data["IsNestedAssembly"];
            (<any>this).isNestedFamANDAssem = _data["IsNestedFamANDAssem"];
            (<any>this).isNestedFamily = _data["IsNestedFamily"];
            (<any>this).isNestedFamORAssem = _data["IsNestedFamORAssem"];
            (<any>this).isNestedPrivate = _data["IsNestedPrivate"];
            (<any>this).isNestedPublic = _data["IsNestedPublic"];
            (<any>this).isNotPublic = _data["IsNotPublic"];
            (<any>this).isPublic = _data["IsPublic"];
            (<any>this).isAutoLayout = _data["IsAutoLayout"];
            (<any>this).isExplicitLayout = _data["IsExplicitLayout"];
            (<any>this).isLayoutSequential = _data["IsLayoutSequential"];
            (<any>this).isAnsiClass = _data["IsAnsiClass"];
            (<any>this).isAutoClass = _data["IsAutoClass"];
            (<any>this).isUnicodeClass = _data["IsUnicodeClass"];
            (<any>this).isCOMObject = _data["IsCOMObject"];
            (<any>this).isContextful = _data["IsContextful"];
            (<any>this).isEnum = _data["IsEnum"];
            (<any>this).isMarshalByRef = _data["IsMarshalByRef"];
            (<any>this).isPrimitive = _data["IsPrimitive"];
            (<any>this).isValueType = _data["IsValueType"];
            (<any>this).isSignatureType = _data["IsSignatureType"];
            (<any>this).isSecurityCritical = _data["IsSecurityCritical"];
            (<any>this).isSecuritySafeCritical = _data["IsSecuritySafeCritical"];
            (<any>this).isSecurityTransparent = _data["IsSecurityTransparent"];
            this.structLayoutAttribute = _data["StructLayoutAttribute"] ? StructLayoutAttribute.fromJS(_data["StructLayoutAttribute"]) : <any>undefined;
            this.typeInitializer = _data["TypeInitializer"] ? ConstructorInfo.fromJS(_data["TypeInitializer"]) : <any>undefined;
            this.typeHandle = _data["TypeHandle"] ? RuntimeTypeHandle.fromJS(_data["TypeHandle"]) : <any>undefined;
            (<any>this).gUID = _data["GUID"];
            this.baseType = _data["BaseType"] ? Type.fromJS(_data["BaseType"]) : <any>undefined;
            (<any>this).isSerializable = _data["IsSerializable"];
            (<any>this).containsGenericParameters = _data["ContainsGenericParameters"];
            (<any>this).isVisible = _data["IsVisible"];
        }
    }

    static fromJS(data: any): Type {
        data = typeof data === 'object' ? data : {};
        let result = new Type();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Name"] = this.name;
        if (Array.isArray(this.customAttributes)) {
            data["CustomAttributes"] = [];
            for (let item of this.customAttributes)
                data["CustomAttributes"].push(item.toJSON());
        }
        data["IsCollectible"] = this.isCollectible;
        data["MetadataToken"] = this.metadataToken;
        data["IsInterface"] = this.isInterface;
        data["MemberType"] = this.memberType;
        data["Namespace"] = this.namespace;
        data["AssemblyQualifiedName"] = this.assemblyQualifiedName;
        data["FullName"] = this.fullName;
        data["Assembly"] = this.assembly ? this.assembly.toJSON() : <any>undefined;
        data["Module"] = this.module ? this.module.toJSON() : <any>undefined;
        data["IsNested"] = this.isNested;
        data["DeclaringType"] = this.declaringType ? this.declaringType.toJSON() : <any>undefined;
        data["DeclaringMethod"] = this.declaringMethod ? this.declaringMethod.toJSON() : <any>undefined;
        data["ReflectedType"] = this.reflectedType ? this.reflectedType.toJSON() : <any>undefined;
        data["UnderlyingSystemType"] = this.underlyingSystemType ? this.underlyingSystemType.toJSON() : <any>undefined;
        data["IsTypeDefinition"] = this.isTypeDefinition;
        data["IsArray"] = this.isArray;
        data["IsByRef"] = this.isByRef;
        data["IsPointer"] = this.isPointer;
        data["IsConstructedGenericType"] = this.isConstructedGenericType;
        data["IsGenericParameter"] = this.isGenericParameter;
        data["IsGenericTypeParameter"] = this.isGenericTypeParameter;
        data["IsGenericMethodParameter"] = this.isGenericMethodParameter;
        data["IsGenericType"] = this.isGenericType;
        data["IsGenericTypeDefinition"] = this.isGenericTypeDefinition;
        data["IsSZArray"] = this.isSZArray;
        data["IsVariableBoundArray"] = this.isVariableBoundArray;
        data["IsByRefLike"] = this.isByRefLike;
        data["HasElementType"] = this.hasElementType;
        if (Array.isArray(this.genericTypeArguments)) {
            data["GenericTypeArguments"] = [];
            for (let item of this.genericTypeArguments)
                data["GenericTypeArguments"].push(item.toJSON());
        }
        data["GenericParameterPosition"] = this.genericParameterPosition;
        data["GenericParameterAttributes"] = this.genericParameterAttributes;
        data["Attributes"] = this.attributes;
        data["IsAbstract"] = this.isAbstract;
        data["IsImport"] = this.isImport;
        data["IsSealed"] = this.isSealed;
        data["IsSpecialName"] = this.isSpecialName;
        data["IsClass"] = this.isClass;
        data["IsNestedAssembly"] = this.isNestedAssembly;
        data["IsNestedFamANDAssem"] = this.isNestedFamANDAssem;
        data["IsNestedFamily"] = this.isNestedFamily;
        data["IsNestedFamORAssem"] = this.isNestedFamORAssem;
        data["IsNestedPrivate"] = this.isNestedPrivate;
        data["IsNestedPublic"] = this.isNestedPublic;
        data["IsNotPublic"] = this.isNotPublic;
        data["IsPublic"] = this.isPublic;
        data["IsAutoLayout"] = this.isAutoLayout;
        data["IsExplicitLayout"] = this.isExplicitLayout;
        data["IsLayoutSequential"] = this.isLayoutSequential;
        data["IsAnsiClass"] = this.isAnsiClass;
        data["IsAutoClass"] = this.isAutoClass;
        data["IsUnicodeClass"] = this.isUnicodeClass;
        data["IsCOMObject"] = this.isCOMObject;
        data["IsContextful"] = this.isContextful;
        data["IsEnum"] = this.isEnum;
        data["IsMarshalByRef"] = this.isMarshalByRef;
        data["IsPrimitive"] = this.isPrimitive;
        data["IsValueType"] = this.isValueType;
        data["IsSignatureType"] = this.isSignatureType;
        data["IsSecurityCritical"] = this.isSecurityCritical;
        data["IsSecuritySafeCritical"] = this.isSecuritySafeCritical;
        data["IsSecurityTransparent"] = this.isSecurityTransparent;
        data["StructLayoutAttribute"] = this.structLayoutAttribute ? this.structLayoutAttribute.toJSON() : <any>undefined;
        data["TypeInitializer"] = this.typeInitializer ? this.typeInitializer.toJSON() : <any>undefined;
        data["TypeHandle"] = this.typeHandle ? this.typeHandle.toJSON() : <any>undefined;
        data["GUID"] = this.gUID;
        data["BaseType"] = this.baseType ? this.baseType.toJSON() : <any>undefined;
        data["IsSerializable"] = this.isSerializable;
        data["ContainsGenericParameters"] = this.containsGenericParameters;
        data["IsVisible"] = this.isVisible;
        return data;
    }
}

export interface IType {
    name?: string | undefined;
    customAttributes?: CustomAttributeData[] | undefined;
    isCollectible?: boolean;
    metadataToken?: number;
    isInterface?: boolean;
    memberType?: MemberTypes;
    namespace?: string | undefined;
    assemblyQualifiedName?: string | undefined;
    fullName?: string | undefined;
    assembly?: Assembly;
    module?: Module;
    isNested?: boolean;
    declaringType?: Type;
    declaringMethod?: MethodBase;
    reflectedType?: Type;
    underlyingSystemType?: Type;
    isTypeDefinition?: boolean;
    isArray?: boolean;
    isByRef?: boolean;
    isPointer?: boolean;
    isConstructedGenericType?: boolean;
    isGenericParameter?: boolean;
    isGenericTypeParameter?: boolean;
    isGenericMethodParameter?: boolean;
    isGenericType?: boolean;
    isGenericTypeDefinition?: boolean;
    isSZArray?: boolean;
    isVariableBoundArray?: boolean;
    isByRefLike?: boolean;
    hasElementType?: boolean;
    genericTypeArguments?: Type[] | undefined;
    genericParameterPosition?: number;
    genericParameterAttributes?: GenericParameterAttributes;
    attributes?: TypeAttributes;
    isAbstract?: boolean;
    isImport?: boolean;
    isSealed?: boolean;
    isSpecialName?: boolean;
    isClass?: boolean;
    isNestedAssembly?: boolean;
    isNestedFamANDAssem?: boolean;
    isNestedFamily?: boolean;
    isNestedFamORAssem?: boolean;
    isNestedPrivate?: boolean;
    isNestedPublic?: boolean;
    isNotPublic?: boolean;
    isPublic?: boolean;
    isAutoLayout?: boolean;
    isExplicitLayout?: boolean;
    isLayoutSequential?: boolean;
    isAnsiClass?: boolean;
    isAutoClass?: boolean;
    isUnicodeClass?: boolean;
    isCOMObject?: boolean;
    isContextful?: boolean;
    isEnum?: boolean;
    isMarshalByRef?: boolean;
    isPrimitive?: boolean;
    isValueType?: boolean;
    isSignatureType?: boolean;
    isSecurityCritical?: boolean;
    isSecuritySafeCritical?: boolean;
    isSecurityTransparent?: boolean;
    structLayoutAttribute?: StructLayoutAttribute;
    typeInitializer?: ConstructorInfo;
    typeHandle?: RuntimeTypeHandle;
    gUID?: string;
    baseType?: Type;
    isSerializable?: boolean;
    containsGenericParameters?: boolean;
    isVisible?: boolean;
}

export enum TypeAttributes {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _8 = 8,
    _16 = 16,
    _24 = 24,
    _32 = 32,
    _128 = 128,
    _256 = 256,
    _1024 = 1024,
    _2048 = 2048,
    _4096 = 4096,
    _8192 = 8192,
    _16384 = 16384,
    _65536 = 65536,
    _131072 = 131072,
    _196608 = 196608,
    _262144 = 262144,
    _264192 = 264192,
    _1048576 = 1048576,
    _12582912 = 12582912,
}

export class TypeInfo implements ITypeInfo {
    readonly name?: string | undefined;
    readonly customAttributes?: CustomAttributeData[] | undefined;
    readonly isCollectible?: boolean;
    readonly metadataToken?: number;
    readonly isInterface?: boolean;
    memberType?: MemberTypes;
    readonly namespace?: string | undefined;
    readonly assemblyQualifiedName?: string | undefined;
    readonly fullName?: string | undefined;
    assembly?: Assembly;
    module?: Module;
    readonly isNested?: boolean;
    declaringType?: Type;
    declaringMethod?: MethodBase;
    reflectedType?: Type;
    underlyingSystemType?: Type;
    readonly isTypeDefinition?: boolean;
    readonly isArray?: boolean;
    readonly isByRef?: boolean;
    readonly isPointer?: boolean;
    readonly isConstructedGenericType?: boolean;
    readonly isGenericParameter?: boolean;
    readonly isGenericTypeParameter?: boolean;
    readonly isGenericMethodParameter?: boolean;
    readonly isGenericType?: boolean;
    readonly isGenericTypeDefinition?: boolean;
    readonly isSZArray?: boolean;
    readonly isVariableBoundArray?: boolean;
    readonly isByRefLike?: boolean;
    readonly hasElementType?: boolean;
    readonly genericTypeArguments?: Type[] | undefined;
    readonly genericParameterPosition?: number;
    genericParameterAttributes?: GenericParameterAttributes;
    attributes?: TypeAttributes;
    readonly isAbstract?: boolean;
    readonly isImport?: boolean;
    readonly isSealed?: boolean;
    readonly isSpecialName?: boolean;
    readonly isClass?: boolean;
    readonly isNestedAssembly?: boolean;
    readonly isNestedFamANDAssem?: boolean;
    readonly isNestedFamily?: boolean;
    readonly isNestedFamORAssem?: boolean;
    readonly isNestedPrivate?: boolean;
    readonly isNestedPublic?: boolean;
    readonly isNotPublic?: boolean;
    readonly isPublic?: boolean;
    readonly isAutoLayout?: boolean;
    readonly isExplicitLayout?: boolean;
    readonly isLayoutSequential?: boolean;
    readonly isAnsiClass?: boolean;
    readonly isAutoClass?: boolean;
    readonly isUnicodeClass?: boolean;
    readonly isCOMObject?: boolean;
    readonly isContextful?: boolean;
    readonly isEnum?: boolean;
    readonly isMarshalByRef?: boolean;
    readonly isPrimitive?: boolean;
    readonly isValueType?: boolean;
    readonly isSignatureType?: boolean;
    readonly isSecurityCritical?: boolean;
    readonly isSecuritySafeCritical?: boolean;
    readonly isSecurityTransparent?: boolean;
    structLayoutAttribute?: StructLayoutAttribute;
    typeInitializer?: ConstructorInfo;
    typeHandle?: RuntimeTypeHandle;
    readonly gUID?: string;
    baseType?: Type;
    readonly isSerializable?: boolean;
    readonly containsGenericParameters?: boolean;
    readonly isVisible?: boolean;
    readonly genericTypeParameters?: Type[] | undefined;
    readonly declaredConstructors?: ConstructorInfo[] | undefined;
    readonly declaredEvents?: EventInfo[] | undefined;
    readonly declaredFields?: FieldInfo[] | undefined;
    readonly declaredMembers?: MemberInfo[] | undefined;
    readonly declaredMethods?: MethodInfo[] | undefined;
    readonly declaredNestedTypes?: TypeInfo[] | undefined;
    readonly declaredProperties?: PropertyInfo[] | undefined;
    readonly implementedInterfaces?: Type[] | undefined;

    constructor(data?: ITypeInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).name = _data["Name"];
            if (Array.isArray(_data["CustomAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["CustomAttributes"])
                    (<any>this).customAttributes!.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).isCollectible = _data["IsCollectible"];
            (<any>this).metadataToken = _data["MetadataToken"];
            (<any>this).isInterface = _data["IsInterface"];
            this.memberType = _data["MemberType"];
            (<any>this).namespace = _data["Namespace"];
            (<any>this).assemblyQualifiedName = _data["AssemblyQualifiedName"];
            (<any>this).fullName = _data["FullName"];
            this.assembly = _data["Assembly"] ? Assembly.fromJS(_data["Assembly"]) : <any>undefined;
            this.module = _data["Module"] ? Module.fromJS(_data["Module"]) : <any>undefined;
            (<any>this).isNested = _data["IsNested"];
            this.declaringType = _data["DeclaringType"] ? Type.fromJS(_data["DeclaringType"]) : <any>undefined;
            this.declaringMethod = _data["DeclaringMethod"] ? MethodBase.fromJS(_data["DeclaringMethod"]) : <any>undefined;
            this.reflectedType = _data["ReflectedType"] ? Type.fromJS(_data["ReflectedType"]) : <any>undefined;
            this.underlyingSystemType = _data["UnderlyingSystemType"] ? Type.fromJS(_data["UnderlyingSystemType"]) : <any>undefined;
            (<any>this).isTypeDefinition = _data["IsTypeDefinition"];
            (<any>this).isArray = _data["IsArray"];
            (<any>this).isByRef = _data["IsByRef"];
            (<any>this).isPointer = _data["IsPointer"];
            (<any>this).isConstructedGenericType = _data["IsConstructedGenericType"];
            (<any>this).isGenericParameter = _data["IsGenericParameter"];
            (<any>this).isGenericTypeParameter = _data["IsGenericTypeParameter"];
            (<any>this).isGenericMethodParameter = _data["IsGenericMethodParameter"];
            (<any>this).isGenericType = _data["IsGenericType"];
            (<any>this).isGenericTypeDefinition = _data["IsGenericTypeDefinition"];
            (<any>this).isSZArray = _data["IsSZArray"];
            (<any>this).isVariableBoundArray = _data["IsVariableBoundArray"];
            (<any>this).isByRefLike = _data["IsByRefLike"];
            (<any>this).hasElementType = _data["HasElementType"];
            if (Array.isArray(_data["GenericTypeArguments"])) {
                (<any>this).genericTypeArguments = [] as any;
                for (let item of _data["GenericTypeArguments"])
                    (<any>this).genericTypeArguments!.push(Type.fromJS(item));
            }
            (<any>this).genericParameterPosition = _data["GenericParameterPosition"];
            this.genericParameterAttributes = _data["GenericParameterAttributes"];
            this.attributes = _data["Attributes"];
            (<any>this).isAbstract = _data["IsAbstract"];
            (<any>this).isImport = _data["IsImport"];
            (<any>this).isSealed = _data["IsSealed"];
            (<any>this).isSpecialName = _data["IsSpecialName"];
            (<any>this).isClass = _data["IsClass"];
            (<any>this).isNestedAssembly = _data["IsNestedAssembly"];
            (<any>this).isNestedFamANDAssem = _data["IsNestedFamANDAssem"];
            (<any>this).isNestedFamily = _data["IsNestedFamily"];
            (<any>this).isNestedFamORAssem = _data["IsNestedFamORAssem"];
            (<any>this).isNestedPrivate = _data["IsNestedPrivate"];
            (<any>this).isNestedPublic = _data["IsNestedPublic"];
            (<any>this).isNotPublic = _data["IsNotPublic"];
            (<any>this).isPublic = _data["IsPublic"];
            (<any>this).isAutoLayout = _data["IsAutoLayout"];
            (<any>this).isExplicitLayout = _data["IsExplicitLayout"];
            (<any>this).isLayoutSequential = _data["IsLayoutSequential"];
            (<any>this).isAnsiClass = _data["IsAnsiClass"];
            (<any>this).isAutoClass = _data["IsAutoClass"];
            (<any>this).isUnicodeClass = _data["IsUnicodeClass"];
            (<any>this).isCOMObject = _data["IsCOMObject"];
            (<any>this).isContextful = _data["IsContextful"];
            (<any>this).isEnum = _data["IsEnum"];
            (<any>this).isMarshalByRef = _data["IsMarshalByRef"];
            (<any>this).isPrimitive = _data["IsPrimitive"];
            (<any>this).isValueType = _data["IsValueType"];
            (<any>this).isSignatureType = _data["IsSignatureType"];
            (<any>this).isSecurityCritical = _data["IsSecurityCritical"];
            (<any>this).isSecuritySafeCritical = _data["IsSecuritySafeCritical"];
            (<any>this).isSecurityTransparent = _data["IsSecurityTransparent"];
            this.structLayoutAttribute = _data["StructLayoutAttribute"] ? StructLayoutAttribute.fromJS(_data["StructLayoutAttribute"]) : <any>undefined;
            this.typeInitializer = _data["TypeInitializer"] ? ConstructorInfo.fromJS(_data["TypeInitializer"]) : <any>undefined;
            this.typeHandle = _data["TypeHandle"] ? RuntimeTypeHandle.fromJS(_data["TypeHandle"]) : <any>undefined;
            (<any>this).gUID = _data["GUID"];
            this.baseType = _data["BaseType"] ? Type.fromJS(_data["BaseType"]) : <any>undefined;
            (<any>this).isSerializable = _data["IsSerializable"];
            (<any>this).containsGenericParameters = _data["ContainsGenericParameters"];
            (<any>this).isVisible = _data["IsVisible"];
            if (Array.isArray(_data["GenericTypeParameters"])) {
                (<any>this).genericTypeParameters = [] as any;
                for (let item of _data["GenericTypeParameters"])
                    (<any>this).genericTypeParameters!.push(Type.fromJS(item));
            }
            if (Array.isArray(_data["DeclaredConstructors"])) {
                (<any>this).declaredConstructors = [] as any;
                for (let item of _data["DeclaredConstructors"])
                    (<any>this).declaredConstructors!.push(ConstructorInfo.fromJS(item));
            }
            if (Array.isArray(_data["DeclaredEvents"])) {
                (<any>this).declaredEvents = [] as any;
                for (let item of _data["DeclaredEvents"])
                    (<any>this).declaredEvents!.push(EventInfo.fromJS(item));
            }
            if (Array.isArray(_data["DeclaredFields"])) {
                (<any>this).declaredFields = [] as any;
                for (let item of _data["DeclaredFields"])
                    (<any>this).declaredFields!.push(FieldInfo.fromJS(item));
            }
            if (Array.isArray(_data["DeclaredMembers"])) {
                (<any>this).declaredMembers = [] as any;
                for (let item of _data["DeclaredMembers"])
                    (<any>this).declaredMembers!.push(MemberInfo.fromJS(item));
            }
            if (Array.isArray(_data["DeclaredMethods"])) {
                (<any>this).declaredMethods = [] as any;
                for (let item of _data["DeclaredMethods"])
                    (<any>this).declaredMethods!.push(MethodInfo.fromJS(item));
            }
            if (Array.isArray(_data["DeclaredNestedTypes"])) {
                (<any>this).declaredNestedTypes = [] as any;
                for (let item of _data["DeclaredNestedTypes"])
                    (<any>this).declaredNestedTypes!.push(TypeInfo.fromJS(item));
            }
            if (Array.isArray(_data["DeclaredProperties"])) {
                (<any>this).declaredProperties = [] as any;
                for (let item of _data["DeclaredProperties"])
                    (<any>this).declaredProperties!.push(PropertyInfo.fromJS(item));
            }
            if (Array.isArray(_data["ImplementedInterfaces"])) {
                (<any>this).implementedInterfaces = [] as any;
                for (let item of _data["ImplementedInterfaces"])
                    (<any>this).implementedInterfaces!.push(Type.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TypeInfo {
        data = typeof data === 'object' ? data : {};
        let result = new TypeInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Name"] = this.name;
        if (Array.isArray(this.customAttributes)) {
            data["CustomAttributes"] = [];
            for (let item of this.customAttributes)
                data["CustomAttributes"].push(item.toJSON());
        }
        data["IsCollectible"] = this.isCollectible;
        data["MetadataToken"] = this.metadataToken;
        data["IsInterface"] = this.isInterface;
        data["MemberType"] = this.memberType;
        data["Namespace"] = this.namespace;
        data["AssemblyQualifiedName"] = this.assemblyQualifiedName;
        data["FullName"] = this.fullName;
        data["Assembly"] = this.assembly ? this.assembly.toJSON() : <any>undefined;
        data["Module"] = this.module ? this.module.toJSON() : <any>undefined;
        data["IsNested"] = this.isNested;
        data["DeclaringType"] = this.declaringType ? this.declaringType.toJSON() : <any>undefined;
        data["DeclaringMethod"] = this.declaringMethod ? this.declaringMethod.toJSON() : <any>undefined;
        data["ReflectedType"] = this.reflectedType ? this.reflectedType.toJSON() : <any>undefined;
        data["UnderlyingSystemType"] = this.underlyingSystemType ? this.underlyingSystemType.toJSON() : <any>undefined;
        data["IsTypeDefinition"] = this.isTypeDefinition;
        data["IsArray"] = this.isArray;
        data["IsByRef"] = this.isByRef;
        data["IsPointer"] = this.isPointer;
        data["IsConstructedGenericType"] = this.isConstructedGenericType;
        data["IsGenericParameter"] = this.isGenericParameter;
        data["IsGenericTypeParameter"] = this.isGenericTypeParameter;
        data["IsGenericMethodParameter"] = this.isGenericMethodParameter;
        data["IsGenericType"] = this.isGenericType;
        data["IsGenericTypeDefinition"] = this.isGenericTypeDefinition;
        data["IsSZArray"] = this.isSZArray;
        data["IsVariableBoundArray"] = this.isVariableBoundArray;
        data["IsByRefLike"] = this.isByRefLike;
        data["HasElementType"] = this.hasElementType;
        if (Array.isArray(this.genericTypeArguments)) {
            data["GenericTypeArguments"] = [];
            for (let item of this.genericTypeArguments)
                data["GenericTypeArguments"].push(item.toJSON());
        }
        data["GenericParameterPosition"] = this.genericParameterPosition;
        data["GenericParameterAttributes"] = this.genericParameterAttributes;
        data["Attributes"] = this.attributes;
        data["IsAbstract"] = this.isAbstract;
        data["IsImport"] = this.isImport;
        data["IsSealed"] = this.isSealed;
        data["IsSpecialName"] = this.isSpecialName;
        data["IsClass"] = this.isClass;
        data["IsNestedAssembly"] = this.isNestedAssembly;
        data["IsNestedFamANDAssem"] = this.isNestedFamANDAssem;
        data["IsNestedFamily"] = this.isNestedFamily;
        data["IsNestedFamORAssem"] = this.isNestedFamORAssem;
        data["IsNestedPrivate"] = this.isNestedPrivate;
        data["IsNestedPublic"] = this.isNestedPublic;
        data["IsNotPublic"] = this.isNotPublic;
        data["IsPublic"] = this.isPublic;
        data["IsAutoLayout"] = this.isAutoLayout;
        data["IsExplicitLayout"] = this.isExplicitLayout;
        data["IsLayoutSequential"] = this.isLayoutSequential;
        data["IsAnsiClass"] = this.isAnsiClass;
        data["IsAutoClass"] = this.isAutoClass;
        data["IsUnicodeClass"] = this.isUnicodeClass;
        data["IsCOMObject"] = this.isCOMObject;
        data["IsContextful"] = this.isContextful;
        data["IsEnum"] = this.isEnum;
        data["IsMarshalByRef"] = this.isMarshalByRef;
        data["IsPrimitive"] = this.isPrimitive;
        data["IsValueType"] = this.isValueType;
        data["IsSignatureType"] = this.isSignatureType;
        data["IsSecurityCritical"] = this.isSecurityCritical;
        data["IsSecuritySafeCritical"] = this.isSecuritySafeCritical;
        data["IsSecurityTransparent"] = this.isSecurityTransparent;
        data["StructLayoutAttribute"] = this.structLayoutAttribute ? this.structLayoutAttribute.toJSON() : <any>undefined;
        data["TypeInitializer"] = this.typeInitializer ? this.typeInitializer.toJSON() : <any>undefined;
        data["TypeHandle"] = this.typeHandle ? this.typeHandle.toJSON() : <any>undefined;
        data["GUID"] = this.gUID;
        data["BaseType"] = this.baseType ? this.baseType.toJSON() : <any>undefined;
        data["IsSerializable"] = this.isSerializable;
        data["ContainsGenericParameters"] = this.containsGenericParameters;
        data["IsVisible"] = this.isVisible;
        if (Array.isArray(this.genericTypeParameters)) {
            data["GenericTypeParameters"] = [];
            for (let item of this.genericTypeParameters)
                data["GenericTypeParameters"].push(item.toJSON());
        }
        if (Array.isArray(this.declaredConstructors)) {
            data["DeclaredConstructors"] = [];
            for (let item of this.declaredConstructors)
                data["DeclaredConstructors"].push(item.toJSON());
        }
        if (Array.isArray(this.declaredEvents)) {
            data["DeclaredEvents"] = [];
            for (let item of this.declaredEvents)
                data["DeclaredEvents"].push(item.toJSON());
        }
        if (Array.isArray(this.declaredFields)) {
            data["DeclaredFields"] = [];
            for (let item of this.declaredFields)
                data["DeclaredFields"].push(item.toJSON());
        }
        if (Array.isArray(this.declaredMembers)) {
            data["DeclaredMembers"] = [];
            for (let item of this.declaredMembers)
                data["DeclaredMembers"].push(item.toJSON());
        }
        if (Array.isArray(this.declaredMethods)) {
            data["DeclaredMethods"] = [];
            for (let item of this.declaredMethods)
                data["DeclaredMethods"].push(item.toJSON());
        }
        if (Array.isArray(this.declaredNestedTypes)) {
            data["DeclaredNestedTypes"] = [];
            for (let item of this.declaredNestedTypes)
                data["DeclaredNestedTypes"].push(item.toJSON());
        }
        if (Array.isArray(this.declaredProperties)) {
            data["DeclaredProperties"] = [];
            for (let item of this.declaredProperties)
                data["DeclaredProperties"].push(item.toJSON());
        }
        if (Array.isArray(this.implementedInterfaces)) {
            data["ImplementedInterfaces"] = [];
            for (let item of this.implementedInterfaces)
                data["ImplementedInterfaces"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITypeInfo {
    name?: string | undefined;
    customAttributes?: CustomAttributeData[] | undefined;
    isCollectible?: boolean;
    metadataToken?: number;
    isInterface?: boolean;
    memberType?: MemberTypes;
    namespace?: string | undefined;
    assemblyQualifiedName?: string | undefined;
    fullName?: string | undefined;
    assembly?: Assembly;
    module?: Module;
    isNested?: boolean;
    declaringType?: Type;
    declaringMethod?: MethodBase;
    reflectedType?: Type;
    underlyingSystemType?: Type;
    isTypeDefinition?: boolean;
    isArray?: boolean;
    isByRef?: boolean;
    isPointer?: boolean;
    isConstructedGenericType?: boolean;
    isGenericParameter?: boolean;
    isGenericTypeParameter?: boolean;
    isGenericMethodParameter?: boolean;
    isGenericType?: boolean;
    isGenericTypeDefinition?: boolean;
    isSZArray?: boolean;
    isVariableBoundArray?: boolean;
    isByRefLike?: boolean;
    hasElementType?: boolean;
    genericTypeArguments?: Type[] | undefined;
    genericParameterPosition?: number;
    genericParameterAttributes?: GenericParameterAttributes;
    attributes?: TypeAttributes;
    isAbstract?: boolean;
    isImport?: boolean;
    isSealed?: boolean;
    isSpecialName?: boolean;
    isClass?: boolean;
    isNestedAssembly?: boolean;
    isNestedFamANDAssem?: boolean;
    isNestedFamily?: boolean;
    isNestedFamORAssem?: boolean;
    isNestedPrivate?: boolean;
    isNestedPublic?: boolean;
    isNotPublic?: boolean;
    isPublic?: boolean;
    isAutoLayout?: boolean;
    isExplicitLayout?: boolean;
    isLayoutSequential?: boolean;
    isAnsiClass?: boolean;
    isAutoClass?: boolean;
    isUnicodeClass?: boolean;
    isCOMObject?: boolean;
    isContextful?: boolean;
    isEnum?: boolean;
    isMarshalByRef?: boolean;
    isPrimitive?: boolean;
    isValueType?: boolean;
    isSignatureType?: boolean;
    isSecurityCritical?: boolean;
    isSecuritySafeCritical?: boolean;
    isSecurityTransparent?: boolean;
    structLayoutAttribute?: StructLayoutAttribute;
    typeInitializer?: ConstructorInfo;
    typeHandle?: RuntimeTypeHandle;
    gUID?: string;
    baseType?: Type;
    isSerializable?: boolean;
    containsGenericParameters?: boolean;
    isVisible?: boolean;
    genericTypeParameters?: Type[] | undefined;
    declaredConstructors?: ConstructorInfo[] | undefined;
    declaredEvents?: EventInfo[] | undefined;
    declaredFields?: FieldInfo[] | undefined;
    declaredMembers?: MemberInfo[] | undefined;
    declaredMethods?: MethodInfo[] | undefined;
    declaredNestedTypes?: TypeInfo[] | undefined;
    declaredProperties?: PropertyInfo[] | undefined;
    implementedInterfaces?: Type[] | undefined;
}

export class TypeObjectKeyValuePair implements ITypeObjectKeyValuePair {
    key?: Type;
    readonly value?: any | undefined;

    constructor(data?: ITypeObjectKeyValuePair) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["Key"] ? Type.fromJS(_data["Key"]) : <any>undefined;
            (<any>this).value = _data["Value"];
        }
    }

    static fromJS(data: any): TypeObjectKeyValuePair {
        data = typeof data === 'object' ? data : {};
        let result = new TypeObjectKeyValuePair();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Key"] = this.key ? this.key.toJSON() : <any>undefined;
        data["Value"] = this.value;
        return data;
    }
}

export interface ITypeObjectKeyValuePair {
    key?: Type;
    value?: any | undefined;
}

export class UrlEncoder implements IUrlEncoder {
    readonly maxOutputCharactersPerInputCharacter?: number;

    constructor(data?: IUrlEncoder) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).maxOutputCharactersPerInputCharacter = _data["MaxOutputCharactersPerInputCharacter"];
        }
    }

    static fromJS(data: any): UrlEncoder {
        data = typeof data === 'object' ? data : {};
        let result = new UrlEncoder();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["MaxOutputCharactersPerInputCharacter"] = this.maxOutputCharactersPerInputCharacter;
        return data;
    }
}

export interface IUrlEncoder {
    maxOutputCharactersPerInputCharacter?: number;
}

export class Usd implements IUsd {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IUsd) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): Usd {
        data = typeof data === 'object' ? data : {};
        let result = new Usd();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IUsd {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class User implements IUser {
    id?: number;
    userName?: string | undefined;
    normalizedUserName?: string | undefined;
    email?: string | undefined;
    normalizedEmail?: string | undefined;
    emailConfirmed?: boolean;
    passwordHash?: string | undefined;
    securityStamp?: string | undefined;
    concurrencyStamp?: string | undefined;
    phoneNumber?: string | undefined;
    phoneNumberConfirmed?: boolean;
    twoFactorEnabled?: boolean;
    lockoutEnd?: moment.Moment | undefined;
    lockoutEnabled?: boolean;
    accessFailedCount?: number;
    userGuid?: string;
    customerId?: number | undefined;
    customer?: Customer;
    version?: number;
    isAcceptKvk?: boolean;
    isAcceptTerms?: boolean;
    isAcceptContact?: boolean;
    isActive?: boolean;
    isDeleted?: boolean;
    userRoles?: UserRole[] | undefined;

    constructor(data?: IUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.userName = _data["UserName"];
            this.normalizedUserName = _data["NormalizedUserName"];
            this.email = _data["Email"];
            this.normalizedEmail = _data["NormalizedEmail"];
            this.emailConfirmed = _data["EmailConfirmed"];
            this.passwordHash = _data["PasswordHash"];
            this.securityStamp = _data["SecurityStamp"];
            this.concurrencyStamp = _data["ConcurrencyStamp"];
            this.phoneNumber = _data["PhoneNumber"];
            this.phoneNumberConfirmed = _data["PhoneNumberConfirmed"];
            this.twoFactorEnabled = _data["TwoFactorEnabled"];
            this.lockoutEnd = _data["LockoutEnd"] ? moment(_data["LockoutEnd"].toString()) : <any>undefined;
            this.lockoutEnabled = _data["LockoutEnabled"];
            this.accessFailedCount = _data["AccessFailedCount"];
            this.userGuid = _data["UserGuid"];
            this.customerId = _data["CustomerId"];
            this.customer = _data["Customer"] ? Customer.fromJS(_data["Customer"]) : <any>undefined;
            this.version = _data["Version"];
            this.isAcceptKvk = _data["IsAcceptKvk"];
            this.isAcceptTerms = _data["IsAcceptTerms"];
            this.isAcceptContact = _data["IsAcceptContact"];
            this.isActive = _data["IsActive"];
            this.isDeleted = _data["IsDeleted"];
            if (Array.isArray(_data["UserRoles"])) {
                this.userRoles = [] as any;
                for (let item of _data["UserRoles"])
                    this.userRoles!.push(UserRole.fromJS(item));
            }
        }
    }

    static fromJS(data: any): User {
        data = typeof data === 'object' ? data : {};
        let result = new User();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["UserName"] = this.userName;
        data["NormalizedUserName"] = this.normalizedUserName;
        data["Email"] = this.email;
        data["NormalizedEmail"] = this.normalizedEmail;
        data["EmailConfirmed"] = this.emailConfirmed;
        data["PasswordHash"] = this.passwordHash;
        data["SecurityStamp"] = this.securityStamp;
        data["ConcurrencyStamp"] = this.concurrencyStamp;
        data["PhoneNumber"] = this.phoneNumber;
        data["PhoneNumberConfirmed"] = this.phoneNumberConfirmed;
        data["TwoFactorEnabled"] = this.twoFactorEnabled;
        data["LockoutEnd"] = this.lockoutEnd ? this.lockoutEnd.toISOString() : <any>undefined;
        data["LockoutEnabled"] = this.lockoutEnabled;
        data["AccessFailedCount"] = this.accessFailedCount;
        data["UserGuid"] = this.userGuid;
        data["CustomerId"] = this.customerId;
        data["Customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        data["Version"] = this.version;
        data["IsAcceptKvk"] = this.isAcceptKvk;
        data["IsAcceptTerms"] = this.isAcceptTerms;
        data["IsAcceptContact"] = this.isAcceptContact;
        data["IsActive"] = this.isActive;
        data["IsDeleted"] = this.isDeleted;
        if (Array.isArray(this.userRoles)) {
            data["UserRoles"] = [];
            for (let item of this.userRoles)
                data["UserRoles"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUser {
    id?: number;
    userName?: string | undefined;
    normalizedUserName?: string | undefined;
    email?: string | undefined;
    normalizedEmail?: string | undefined;
    emailConfirmed?: boolean;
    passwordHash?: string | undefined;
    securityStamp?: string | undefined;
    concurrencyStamp?: string | undefined;
    phoneNumber?: string | undefined;
    phoneNumberConfirmed?: boolean;
    twoFactorEnabled?: boolean;
    lockoutEnd?: moment.Moment | undefined;
    lockoutEnabled?: boolean;
    accessFailedCount?: number;
    userGuid?: string;
    customerId?: number | undefined;
    customer?: Customer;
    version?: number;
    isAcceptKvk?: boolean;
    isAcceptTerms?: boolean;
    isAcceptContact?: boolean;
    isActive?: boolean;
    isDeleted?: boolean;
    userRoles?: UserRole[] | undefined;
}

export class UserRole implements IUserRole {
    userId?: number;
    user?: User;
    roleId?: number;
    role?: Role;

    constructor(data?: IUserRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["UserId"];
            this.user = _data["User"] ? User.fromJS(_data["User"]) : <any>undefined;
            this.roleId = _data["RoleId"];
            this.role = _data["Role"] ? Role.fromJS(_data["Role"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UserRole {
        data = typeof data === 'object' ? data : {};
        let result = new UserRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["UserId"] = this.userId;
        data["User"] = this.user ? this.user.toJSON() : <any>undefined;
        data["RoleId"] = this.roleId;
        data["Role"] = this.role ? this.role.toJSON() : <any>undefined;
        return data;
    }
}

export interface IUserRole {
    userId?: number;
    user?: User;
    roleId?: number;
    role?: Role;
}

export class ViewContext implements IViewContext {
    actionDescriptor?: ActionDescriptor;
    httpContext?: HttpContext;
    readonly modelState?: { [key: string]: ModelStateEntry; } | undefined;
    routeData?: RouteData;
    formContext?: FormContext;
    clientValidationEnabled?: boolean;
    html5DateRenderingMode?: Html5DateRenderingMode;
    validationSummaryMessageElement?: string | undefined;
    validationMessageElement?: string | undefined;
    checkBoxHiddenInputRenderMode?: CheckBoxHiddenInputRenderMode;
    readonly viewBag?: any | undefined;
    view?: IView;
    viewData?: { [key: string]: any; } | undefined;
    tempData?: { [key: string]: any; } | undefined;
    writer?: TextWriter;
    executingFilePath?: string | undefined;

    constructor(data?: IViewContext) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.actionDescriptor = _data["ActionDescriptor"] ? ActionDescriptor.fromJS(_data["ActionDescriptor"]) : <any>undefined;
            this.httpContext = _data["HttpContext"] ? HttpContext.fromJS(_data["HttpContext"]) : <any>undefined;
            if (_data["ModelState"]) {
                (<any>this).modelState = {} as any;
                for (let key in _data["ModelState"]) {
                    if (_data["ModelState"].hasOwnProperty(key))
                        (<any>(<any>this).modelState)![key] = _data["ModelState"][key] ? ModelStateEntry.fromJS(_data["ModelState"][key]) : new ModelStateEntry();
                }
            }
            this.routeData = _data["RouteData"] ? RouteData.fromJS(_data["RouteData"]) : <any>undefined;
            this.formContext = _data["FormContext"] ? FormContext.fromJS(_data["FormContext"]) : <any>undefined;
            this.clientValidationEnabled = _data["ClientValidationEnabled"];
            this.html5DateRenderingMode = _data["Html5DateRenderingMode"];
            this.validationSummaryMessageElement = _data["ValidationSummaryMessageElement"];
            this.validationMessageElement = _data["ValidationMessageElement"];
            this.checkBoxHiddenInputRenderMode = _data["CheckBoxHiddenInputRenderMode"];
            (<any>this).viewBag = _data["ViewBag"];
            this.view = _data["View"] ? IView.fromJS(_data["View"]) : <any>undefined;
            if (_data["ViewData"]) {
                this.viewData = {} as any;
                for (let key in _data["ViewData"]) {
                    if (_data["ViewData"].hasOwnProperty(key))
                        (<any>this.viewData)![key] = _data["ViewData"][key];
                }
            }
            if (_data["TempData"]) {
                this.tempData = {} as any;
                for (let key in _data["TempData"]) {
                    if (_data["TempData"].hasOwnProperty(key))
                        (<any>this.tempData)![key] = _data["TempData"][key];
                }
            }
            this.writer = _data["Writer"] ? TextWriter.fromJS(_data["Writer"]) : <any>undefined;
            this.executingFilePath = _data["ExecutingFilePath"];
        }
    }

    static fromJS(data: any): ViewContext {
        data = typeof data === 'object' ? data : {};
        let result = new ViewContext();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ActionDescriptor"] = this.actionDescriptor ? this.actionDescriptor.toJSON() : <any>undefined;
        data["HttpContext"] = this.httpContext ? this.httpContext.toJSON() : <any>undefined;
        if (this.modelState) {
            data["ModelState"] = {};
            for (let key in this.modelState) {
                if (this.modelState.hasOwnProperty(key))
                    (<any>data["ModelState"])[key] = this.modelState[key] ? this.modelState[key].toJSON() : <any>undefined;
            }
        }
        data["RouteData"] = this.routeData ? this.routeData.toJSON() : <any>undefined;
        data["FormContext"] = this.formContext ? this.formContext.toJSON() : <any>undefined;
        data["ClientValidationEnabled"] = this.clientValidationEnabled;
        data["Html5DateRenderingMode"] = this.html5DateRenderingMode;
        data["ValidationSummaryMessageElement"] = this.validationSummaryMessageElement;
        data["ValidationMessageElement"] = this.validationMessageElement;
        data["CheckBoxHiddenInputRenderMode"] = this.checkBoxHiddenInputRenderMode;
        data["ViewBag"] = this.viewBag;
        data["View"] = this.view ? this.view.toJSON() : <any>undefined;
        if (this.viewData) {
            data["ViewData"] = {};
            for (let key in this.viewData) {
                if (this.viewData.hasOwnProperty(key))
                    (<any>data["ViewData"])[key] = this.viewData[key];
            }
        }
        if (this.tempData) {
            data["TempData"] = {};
            for (let key in this.tempData) {
                if (this.tempData.hasOwnProperty(key))
                    (<any>data["TempData"])[key] = this.tempData[key];
            }
        }
        data["Writer"] = this.writer ? this.writer.toJSON() : <any>undefined;
        data["ExecutingFilePath"] = this.executingFilePath;
        return data;
    }
}

export interface IViewContext {
    actionDescriptor?: ActionDescriptor;
    httpContext?: HttpContext;
    modelState?: { [key: string]: ModelStateEntry; } | undefined;
    routeData?: RouteData;
    formContext?: FormContext;
    clientValidationEnabled?: boolean;
    html5DateRenderingMode?: Html5DateRenderingMode;
    validationSummaryMessageElement?: string | undefined;
    validationMessageElement?: string | undefined;
    checkBoxHiddenInputRenderMode?: CheckBoxHiddenInputRenderMode;
    viewBag?: any | undefined;
    view?: IView;
    viewData?: { [key: string]: any; } | undefined;
    tempData?: { [key: string]: any; } | undefined;
    writer?: TextWriter;
    executingFilePath?: string | undefined;
}

export class WaitHandle implements IWaitHandle {
    handle?: IntPtr;
    safeWaitHandle?: SafeWaitHandle;

    constructor(data?: IWaitHandle) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.handle = _data["Handle"] ? IntPtr.fromJS(_data["Handle"]) : <any>undefined;
            this.safeWaitHandle = _data["SafeWaitHandle"] ? SafeWaitHandle.fromJS(_data["SafeWaitHandle"]) : <any>undefined;
        }
    }

    static fromJS(data: any): WaitHandle {
        data = typeof data === 'object' ? data : {};
        let result = new WaitHandle();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Handle"] = this.handle ? this.handle.toJSON() : <any>undefined;
        data["SafeWaitHandle"] = this.safeWaitHandle ? this.safeWaitHandle.toJSON() : <any>undefined;
        return data;
    }
}

export interface IWaitHandle {
    handle?: IntPtr;
    safeWaitHandle?: SafeWaitHandle;
}

export class WebSocketManager implements IWebSocketManager {
    readonly isWebSocketRequest?: boolean;
    readonly webSocketRequestedProtocols?: string[] | undefined;

    constructor(data?: IWebSocketManager) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isWebSocketRequest = _data["IsWebSocketRequest"];
            if (Array.isArray(_data["WebSocketRequestedProtocols"])) {
                (<any>this).webSocketRequestedProtocols = [] as any;
                for (let item of _data["WebSocketRequestedProtocols"])
                    (<any>this).webSocketRequestedProtocols!.push(item);
            }
        }
    }

    static fromJS(data: any): WebSocketManager {
        data = typeof data === 'object' ? data : {};
        let result = new WebSocketManager();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["IsWebSocketRequest"] = this.isWebSocketRequest;
        if (Array.isArray(this.webSocketRequestedProtocols)) {
            data["WebSocketRequestedProtocols"] = [];
            for (let item of this.webSocketRequestedProtocols)
                data["WebSocketRequestedProtocols"].push(item);
        }
        return data;
    }
}

export interface IWebSocketManager {
    isWebSocketRequest?: boolean;
    webSocketRequestedProtocols?: string[] | undefined;
}

export class X500DistinguishedName implements IX500DistinguishedName {
    oid?: Oid;
    rawData?: string | undefined;
    readonly name?: string | undefined;

    constructor(data?: IX500DistinguishedName) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.oid = _data["Oid"] ? Oid.fromJS(_data["Oid"]) : <any>undefined;
            this.rawData = _data["RawData"];
            (<any>this).name = _data["Name"];
        }
    }

    static fromJS(data: any): X500DistinguishedName {
        data = typeof data === 'object' ? data : {};
        let result = new X500DistinguishedName();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Oid"] = this.oid ? this.oid.toJSON() : <any>undefined;
        data["RawData"] = this.rawData;
        data["Name"] = this.name;
        return data;
    }
}

export interface IX500DistinguishedName {
    oid?: Oid;
    rawData?: string | undefined;
    name?: string | undefined;
}

export class X509Certificate2 implements IX509Certificate2 {
    handle?: IntPtr;
    readonly issuer?: string | undefined;
    readonly subject?: string | undefined;
    archived?: boolean;
    readonly extensions?: any[] | undefined;
    friendlyName?: string | undefined;
    readonly hasPrivateKey?: boolean;
    privateKey?: AsymmetricAlgorithm;
    issuerName?: X500DistinguishedName;
    readonly notAfter?: moment.Moment;
    readonly notBefore?: moment.Moment;
    publicKey?: PublicKey;
    readonly rawData?: string | undefined;
    readonly serialNumber?: string | undefined;
    signatureAlgorithm?: Oid;
    subjectName?: X500DistinguishedName;
    readonly thumbprint?: string | undefined;
    readonly version?: number;

    constructor(data?: IX509Certificate2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.handle = _data["Handle"] ? IntPtr.fromJS(_data["Handle"]) : <any>undefined;
            (<any>this).issuer = _data["Issuer"];
            (<any>this).subject = _data["Subject"];
            this.archived = _data["Archived"];
            if (Array.isArray(_data["Extensions"])) {
                (<any>this).extensions = [] as any;
                for (let item of _data["Extensions"])
                    (<any>this).extensions!.push(item);
            }
            this.friendlyName = _data["FriendlyName"];
            (<any>this).hasPrivateKey = _data["HasPrivateKey"];
            this.privateKey = _data["PrivateKey"] ? AsymmetricAlgorithm.fromJS(_data["PrivateKey"]) : <any>undefined;
            this.issuerName = _data["IssuerName"] ? X500DistinguishedName.fromJS(_data["IssuerName"]) : <any>undefined;
            (<any>this).notAfter = _data["NotAfter"] ? moment(_data["NotAfter"].toString()) : <any>undefined;
            (<any>this).notBefore = _data["NotBefore"] ? moment(_data["NotBefore"].toString()) : <any>undefined;
            this.publicKey = _data["PublicKey"] ? PublicKey.fromJS(_data["PublicKey"]) : <any>undefined;
            (<any>this).rawData = _data["RawData"];
            (<any>this).serialNumber = _data["SerialNumber"];
            this.signatureAlgorithm = _data["SignatureAlgorithm"] ? Oid.fromJS(_data["SignatureAlgorithm"]) : <any>undefined;
            this.subjectName = _data["SubjectName"] ? X500DistinguishedName.fromJS(_data["SubjectName"]) : <any>undefined;
            (<any>this).thumbprint = _data["Thumbprint"];
            (<any>this).version = _data["Version"];
        }
    }

    static fromJS(data: any): X509Certificate2 {
        data = typeof data === 'object' ? data : {};
        let result = new X509Certificate2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Handle"] = this.handle ? this.handle.toJSON() : <any>undefined;
        data["Issuer"] = this.issuer;
        data["Subject"] = this.subject;
        data["Archived"] = this.archived;
        if (Array.isArray(this.extensions)) {
            data["Extensions"] = [];
            for (let item of this.extensions)
                data["Extensions"].push(item);
        }
        data["FriendlyName"] = this.friendlyName;
        data["HasPrivateKey"] = this.hasPrivateKey;
        data["PrivateKey"] = this.privateKey ? this.privateKey.toJSON() : <any>undefined;
        data["IssuerName"] = this.issuerName ? this.issuerName.toJSON() : <any>undefined;
        data["NotAfter"] = this.notAfter ? this.notAfter.toISOString() : <any>undefined;
        data["NotBefore"] = this.notBefore ? this.notBefore.toISOString() : <any>undefined;
        data["PublicKey"] = this.publicKey ? this.publicKey.toJSON() : <any>undefined;
        data["RawData"] = this.rawData;
        data["SerialNumber"] = this.serialNumber;
        data["SignatureAlgorithm"] = this.signatureAlgorithm ? this.signatureAlgorithm.toJSON() : <any>undefined;
        data["SubjectName"] = this.subjectName ? this.subjectName.toJSON() : <any>undefined;
        data["Thumbprint"] = this.thumbprint;
        data["Version"] = this.version;
        return data;
    }
}

export interface IX509Certificate2 {
    handle?: IntPtr;
    issuer?: string | undefined;
    subject?: string | undefined;
    archived?: boolean;
    extensions?: any[] | undefined;
    friendlyName?: string | undefined;
    hasPrivateKey?: boolean;
    privateKey?: AsymmetricAlgorithm;
    issuerName?: X500DistinguishedName;
    notAfter?: moment.Moment;
    notBefore?: moment.Moment;
    publicKey?: PublicKey;
    rawData?: string | undefined;
    serialNumber?: string | undefined;
    signatureAlgorithm?: Oid;
    subjectName?: X500DistinguishedName;
    thumbprint?: string | undefined;
    version?: number;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}