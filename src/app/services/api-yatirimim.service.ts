//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import * as moment from 'moment';

export const MARITZA_API_URL = new InjectionToken<string>('MARITZA_API_URL');

@Injectable()
export class AnalysisApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://192.168.253.100:5000";
    }

    /**
     * @return Success
     */
    getlist(): Observable<AnalysisModel[]> {
        let url_ = this.baseUrl + "/api/contents/analysis/getlist";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetlist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AnalysisModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AnalysisModel[]>;
        }));
    }

    protected processGetlist(response: HttpResponseBase): Observable<AnalysisModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AnalysisModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AnalysisModel[]>(null as any);
    }
}

@Injectable()
export class AssetsApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://192.168.253.100:5000";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getbyid(id: number | undefined): Observable<AssetModel> {
        let url_ = this.baseUrl + "/api/finance/assets/getbyid?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AssetModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AssetModel>;
        }));
    }

    protected processGetbyid(response: HttpResponseBase): Observable<AssetModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssetModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssetModel>(null as any);
    }

    /**
     * @param customerId (optional) 
     * @return Success
     */
    getassetlist(customerId: number | undefined): Observable<AssetModel[]> {
        let url_ = this.baseUrl + "/api/finance/assets/getassetlist?";
        if (customerId === null)
            throw new Error("The parameter 'customerId' cannot be null.");
        else if (customerId !== undefined)
            url_ += "customerId=" + encodeURIComponent("" + customerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetassetlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetassetlist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AssetModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AssetModel[]>;
        }));
    }

    protected processGetassetlist(response: HttpResponseBase): Observable<AssetModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AssetModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssetModel[]>(null as any);
    }

    /**
     * @param customerId (optional) 
     * @return Success
     */
    getwallet(customerId: number | undefined): Observable<AssetModel[]> {
        let url_ = this.baseUrl + "/api/finance/assets/getwallet?";
        if (customerId === null)
            throw new Error("The parameter 'customerId' cannot be null.");
        else if (customerId !== undefined)
            url_ += "customerId=" + encodeURIComponent("" + customerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetwallet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetwallet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AssetModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AssetModel[]>;
        }));
    }

    protected processGetwallet(response: HttpResponseBase): Observable<AssetModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AssetModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssetModel[]>(null as any);
    }
}

@Injectable()
export class AuthApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://192.168.253.100:5000";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    login(body: LoginModel | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/auth/auth/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processLogin(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData400)) {
                result400 = [] as any;
                for (let item of resultData400)
                    result400!.push(ErrorDto.fromJS(item));
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    verify(body: VerifyModel | undefined): Observable<TokenModel> {
        let url_ = this.baseUrl + "/api/auth/auth/verify";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerify(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerify(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TokenModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TokenModel>;
        }));
    }

    protected processVerify(response: HttpResponseBase): Observable<TokenModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TokenModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData400)) {
                result400 = [] as any;
                for (let item of resultData400)
                    result400!.push(ErrorDto.fromJS(item));
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TokenModel>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    forgot(body: ForgotModel | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/auth/auth/forgot";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processForgot(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processForgot(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processForgot(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData400)) {
                result400 = [] as any;
                for (let item of resultData400)
                    result400!.push(ErrorDto.fromJS(item));
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param phoneNumber (optional) 
     * @return Success
     */
    checkphonenumber(phoneNumber: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/auth/auth/checkphonenumber?";
        if (phoneNumber === null)
            throw new Error("The parameter 'phoneNumber' cannot be null.");
        else if (phoneNumber !== undefined)
            url_ += "phoneNumber=" + encodeURIComponent("" + phoneNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckphonenumber(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckphonenumber(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCheckphonenumber(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData400)) {
                result400 = [] as any;
                for (let item of resultData400)
                    result400!.push(ErrorDto.fromJS(item));
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param identityNo (optional) 
     * @return Success
     */
    checkidentityno(identityNo: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/auth/auth/checkidentityno?";
        if (identityNo === null)
            throw new Error("The parameter 'identityNo' cannot be null.");
        else if (identityNo !== undefined)
            url_ += "identityNo=" + encodeURIComponent("" + identityNo) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckidentityno(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckidentityno(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCheckidentityno(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData400)) {
                result400 = [] as any;
                for (let item of resultData400)
                    result400!.push(ErrorDto.fromJS(item));
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    register(body: RegisterModel | undefined): Observable<TokenModel> {
        let url_ = this.baseUrl + "/api/auth/auth/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TokenModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TokenModel>;
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<TokenModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TokenModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData400)) {
                result400 = [] as any;
                for (let item of resultData400)
                    result400!.push(ErrorDto.fromJS(item));
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TokenModel>(null as any);
    }
}

@Injectable()
export class BankApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://192.168.253.100:5000";
    }

    /**
     * @return Success
     */
    getlist(): Observable<BankModel[]> {
        let url_ = this.baseUrl + "/api/settings/core/bank/getlist";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetlist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BankModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BankModel[]>;
        }));
    }

    protected processGetlist(response: HttpResponseBase): Observable<BankModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(BankModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BankModel[]>(null as any);
    }
}

@Injectable()
export class BankaccountApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://192.168.253.100:5000";
    }

    /**
     * @param customerId (optional) 
     * @return Success
     */
    getcustomeraccountdetail(customerId: number | undefined): Observable<CustomerBankAccountModel[]> {
        let url_ = this.baseUrl + "/api/auth/bankaccount/getcustomeraccountdetail?";
        if (customerId === null)
            throw new Error("The parameter 'customerId' cannot be null.");
        else if (customerId !== undefined)
            url_ += "customerId=" + encodeURIComponent("" + customerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetcustomeraccountdetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetcustomeraccountdetail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CustomerBankAccountModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CustomerBankAccountModel[]>;
        }));
    }

    protected processGetcustomeraccountdetail(response: HttpResponseBase): Observable<CustomerBankAccountModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CustomerBankAccountModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CustomerBankAccountModel[]>(null as any);
    }
}

@Injectable()
export class BloodtypeApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://192.168.253.100:5000";
    }

    /**
     * @return Success
     */
    getlist(): Observable<BloodTypeModel[]> {
        let url_ = this.baseUrl + "/api/settings/code/bloodtype/getlist";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetlist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BloodTypeModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BloodTypeModel[]>;
        }));
    }

    protected processGetlist(response: HttpResponseBase): Observable<BloodTypeModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(BloodTypeModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BloodTypeModel[]>(null as any);
    }
}

@Injectable()
export class CardApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://192.168.253.100:5000";
    }

    /**
     * @param cardId (optional) 
     * @return Success
     */
    getcard(cardId: string | undefined): Observable<CardDTO> {
        let url_ = this.baseUrl + "/api/auth/card/getcard?";
        if (cardId === null)
            throw new Error("The parameter 'cardId' cannot be null.");
        else if (cardId !== undefined)
            url_ += "cardId=" + encodeURIComponent("" + cardId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetcard(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetcard(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CardDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CardDTO>;
        }));
    }

    protected processGetcard(response: HttpResponseBase): Observable<CardDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CardDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData400)) {
                result400 = [] as any;
                for (let item of resultData400)
                    result400!.push(ErrorDto.fromJS(item));
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardDTO>(null as any);
    }

    /**
     * @return Success
     */
    getcards(): Observable<CardDTO[]> {
        let url_ = this.baseUrl + "/api/auth/card/getcards";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetcards(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetcards(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CardDTO[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CardDTO[]>;
        }));
    }

    protected processGetcards(response: HttpResponseBase): Observable<CardDTO[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CardDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData400)) {
                result400 = [] as any;
                for (let item of resultData400)
                    result400!.push(ErrorDto.fromJS(item));
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardDTO[]>(null as any);
    }

    /**
     * @param memberID (optional) 
     * @param body (optional) 
     * @return Success
     */
    savecard(memberID: string | undefined, body: CardCreateDTO | undefined): Observable<CardDTO> {
        let url_ = this.baseUrl + "/api/auth/card/savecard?";
        if (memberID === null)
            throw new Error("The parameter 'memberID' cannot be null.");
        else if (memberID !== undefined)
            url_ += "memberID=" + encodeURIComponent("" + memberID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSavecard(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSavecard(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CardDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CardDTO>;
        }));
    }

    protected processSavecard(response: HttpResponseBase): Observable<CardDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CardDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData400)) {
                result400 = [] as any;
                for (let item of resultData400)
                    result400!.push(ErrorDto.fromJS(item));
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardDTO>(null as any);
    }

    /**
     * @param cardId (optional) 
     * @return Success
     */
    deletecard(cardId: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/auth/card/deletecard?";
        if (cardId === null)
            throw new Error("The parameter 'cardId' cannot be null.");
        else if (cardId !== undefined)
            url_ += "cardId=" + encodeURIComponent("" + cardId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletecard(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletecard(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeletecard(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData400)) {
                result400 = [] as any;
                for (let item of resultData400)
                    result400!.push(ErrorDto.fromJS(item));
            }
            else {
                result400 = <any>null;
            }
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class ChanneltypeApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://192.168.253.100:5000";
    }

    /**
     * @return Success
     */
    getlist(): Observable<ChannelTypeModel[]> {
        let url_ = this.baseUrl + "/api/settings/code/channeltype/getlist";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetlist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ChannelTypeModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ChannelTypeModel[]>;
        }));
    }

    protected processGetlist(response: HttpResponseBase): Observable<ChannelTypeModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ChannelTypeModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ChannelTypeModel[]>(null as any);
    }
}

@Injectable()
export class CommissionApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://192.168.253.100:5000";
    }

    /**
     * @return Success
     */
    getlist(): Observable<CommissionModel[]> {
        let url_ = this.baseUrl + "/api/settings/finance/commission/getlist";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetlist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CommissionModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CommissionModel[]>;
        }));
    }

    protected processGetlist(response: HttpResponseBase): Observable<CommissionModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CommissionModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommissionModel[]>(null as any);
    }
}

@Injectable()
export class ContacstypeApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://192.168.253.100:5000";
    }

    /**
     * @return Success
     */
    getlist(): Observable<ContactTypeModel[]> {
        let url_ = this.baseUrl + "/api/settings/code/contacstype/getlist";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetlist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContactTypeModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContactTypeModel[]>;
        }));
    }

    protected processGetlist(response: HttpResponseBase): Observable<ContactTypeModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ContactTypeModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContactTypeModel[]>(null as any);
    }
}

@Injectable()
export class CorporateApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://192.168.253.100:5000";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    add(body: CorporateModel | undefined): Observable<CorporateModel> {
        let url_ = this.baseUrl + "/api/auth/corporate/add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CorporateModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CorporateModel>;
        }));
    }

    protected processAdd(response: HttpResponseBase): Observable<CorporateModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CorporateModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CorporateModel>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getbyid(id: number | undefined): Observable<CorporateModel> {
        let url_ = this.baseUrl + "/api/auth/corporate/getbyid?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CorporateModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CorporateModel>;
        }));
    }

    protected processGetbyid(response: HttpResponseBase): Observable<CorporateModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CorporateModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CorporateModel>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: CorporateModel | undefined): Observable<CorporateModel> {
        let url_ = this.baseUrl + "/api/auth/corporate/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CorporateModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CorporateModel>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<CorporateModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CorporateModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CorporateModel>(null as any);
    }
}

@Injectable()
export class ReadApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://192.168.253.100:5000";
    }

    /**
     * @return Success
     */
    getcorporatelist(): Observable<CorporateModel[]> {
        let url_ = this.baseUrl + "/api/auth/corporate/read/getcorporatelist";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetcorporatelist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetcorporatelist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CorporateModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CorporateModel[]>;
        }));
    }

    protected processGetcorporatelist(response: HttpResponseBase): Observable<CorporateModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CorporateModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CorporateModel[]>(null as any);
    }
}

@Injectable()
export class CorporatecategoriesApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://192.168.253.100:5000";
    }

    /**
     * @return Success
     */
    getlist(): Observable<CorporateCategoryModel[]> {
        let url_ = this.baseUrl + "/api/settings/code/corporatecategories/getlist";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetlist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CorporateCategoryModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CorporateCategoryModel[]>;
        }));
    }

    protected processGetlist(response: HttpResponseBase): Observable<CorporateCategoryModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CorporateCategoryModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CorporateCategoryModel[]>(null as any);
    }
}

@Injectable()
export class CountryApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://192.168.253.100:5000";
    }

    /**
     * @return Success
     */
    getlist(): Observable<CountryModel[]> {
        let url_ = this.baseUrl + "/api/settings/place/country/getlist";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetlist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CountryModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CountryModel[]>;
        }));
    }

    protected processGetlist(response: HttpResponseBase): Observable<CountryModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CountryModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CountryModel[]>(null as any);
    }
}

@Injectable()
export class CreditcardpaymentApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://192.168.253.100:5000";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    paywithcard(body: CreditCardPaymentRequestModel | undefined): Observable<CreditCardPaymentSummaryModel> {
        let url_ = this.baseUrl + "/api/finance/creditcardpayment/paywithcard";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPaywithcard(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPaywithcard(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreditCardPaymentSummaryModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreditCardPaymentSummaryModel>;
        }));
    }

    protected processPaywithcard(response: HttpResponseBase): Observable<CreditCardPaymentSummaryModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreditCardPaymentSummaryModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = APIResultDTOApiException.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreditCardPaymentSummaryModel>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    paywithstoredcard(body: CreditCardMemberPaymentRequestModel | undefined): Observable<CreditCardPaymentSummaryModel> {
        let url_ = this.baseUrl + "/api/finance/creditcardpayment/paywithstoredcard";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPaywithstoredcard(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPaywithstoredcard(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreditCardPaymentSummaryModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreditCardPaymentSummaryModel>;
        }));
    }

    protected processPaywithstoredcard(response: HttpResponseBase): Observable<CreditCardPaymentSummaryModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreditCardPaymentSummaryModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = APIResultDTOApiException.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreditCardPaymentSummaryModel>(null as any);
    }

    /**
     * @param transactionId (optional) 
     * @return Success
     */
    getpaymentstatus(transactionId: string | undefined): Observable<PaymentStatusEnum> {
        let url_ = this.baseUrl + "/api/finance/creditcardpayment/getpaymentstatus?";
        if (transactionId === null)
            throw new Error("The parameter 'transactionId' cannot be null.");
        else if (transactionId !== undefined)
            url_ += "transactionId=" + encodeURIComponent("" + transactionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetpaymentstatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetpaymentstatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentStatusEnum>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentStatusEnum>;
        }));
    }

    protected processGetpaymentstatus(response: HttpResponseBase): Observable<PaymentStatusEnum> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = APIResultDTOApiException.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaymentStatusEnum>(null as any);
    }
}

@Injectable()
export class DemandtypesApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://192.168.253.100:5000";
    }

    /**
     * @return Success
     */
    getlist(): Observable<DemandTypeModel[]> {
        let url_ = this.baseUrl + "/api/settings/code/demandtypes/getlist";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetlist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DemandTypeModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DemandTypeModel[]>;
        }));
    }

    protected processGetlist(response: HttpResponseBase): Observable<DemandTypeModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DemandTypeModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DemandTypeModel[]>(null as any);
    }
}

@Injectable()
export class DepositsApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://192.168.253.100:5000";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addphysical(body: Request | undefined): Observable<Request> {
        let url_ = this.baseUrl + "/api/finance/deposits/addphysical";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddphysical(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddphysical(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Request>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Request>;
        }));
    }

    protected processAddphysical(response: HttpResponseBase): Observable<Request> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Request.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Request>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    adddigital(body: Request | undefined): Observable<Request> {
        let url_ = this.baseUrl + "/api/finance/deposits/adddigital";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdddigital(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdddigital(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Request>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Request>;
        }));
    }

    protected processAdddigital(response: HttpResponseBase): Observable<Request> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Request.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Request>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getbyid(id: number | undefined): Observable<Request> {
        let url_ = this.baseUrl + "/api/finance/deposits/getbyid?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Request>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Request>;
        }));
    }

    protected processGetbyid(response: HttpResponseBase): Observable<Request> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Request.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Request>(null as any);
    }

    getdetailbyid(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/finance/deposits/getdetailbyid?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetdetailbyid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetdetailbyid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetdetailbyid(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param customerId (optional) 
     * @return Success
     */
    getdigitalrequestlist(customerId: number | undefined): Observable<Request[]> {
        let url_ = this.baseUrl + "/api/finance/deposits/getdigitalrequestlist?";
        if (customerId === null)
            throw new Error("The parameter 'customerId' cannot be null.");
        else if (customerId !== undefined)
            url_ += "customerId=" + encodeURIComponent("" + customerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetdigitalrequestlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetdigitalrequestlist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Request[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Request[]>;
        }));
    }

    protected processGetdigitalrequestlist(response: HttpResponseBase): Observable<Request[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Request.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Request[]>(null as any);
    }

    /**
     * @param customerId (optional) 
     * @return Success
     */
    getphysicalrequestlist(customerId: number | undefined): Observable<Request[]> {
        let url_ = this.baseUrl + "/api/finance/deposits/getphysicalrequestlist?";
        if (customerId === null)
            throw new Error("The parameter 'customerId' cannot be null.");
        else if (customerId !== undefined)
            url_ += "customerId=" + encodeURIComponent("" + customerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetphysicalrequestlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetphysicalrequestlist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Request[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Request[]>;
        }));
    }

    protected processGetphysicalrequestlist(response: HttpResponseBase): Observable<Request[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Request.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Request[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: Request | undefined): Observable<Request> {
        let url_ = this.baseUrl + "/api/finance/deposits/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Request>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Request>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<Request> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Request.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Request>(null as any);
    }
}

@Injectable()
export class DocumenttypesApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://192.168.253.100:5000";
    }

    /**
     * @return Success
     */
    getlist(): Observable<DocumentTypeModel[]> {
        let url_ = this.baseUrl + "/api/settings/code/documenttypes/getlist";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetlist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DocumentTypeModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DocumentTypeModel[]>;
        }));
    }

    protected processGetlist(response: HttpResponseBase): Observable<DocumentTypeModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DocumentTypeModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DocumentTypeModel[]>(null as any);
    }
}

@Injectable()
export class GenderApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://192.168.253.100:5000";
    }

    /**
     * @return Success
     */
    getlist(): Observable<GenderModel[]> {
        let url_ = this.baseUrl + "/api/settings/code/gender/getlist";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetlist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GenderModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GenderModel[]>;
        }));
    }

    protected processGetlist(response: HttpResponseBase): Observable<GenderModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GenderModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GenderModel[]>(null as any);
    }
}

@Injectable()
export class InvoicestatusApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://192.168.253.100:5000";
    }

    /**
     * @return Success
     */
    getlist(): Observable<InvoiceStatusModel[]> {
        let url_ = this.baseUrl + "/api/settings/code/invoicestatus/getlist";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetlist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvoiceStatusModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvoiceStatusModel[]>;
        }));
    }

    protected processGetlist(response: HttpResponseBase): Observable<InvoiceStatusModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(InvoiceStatusModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvoiceStatusModel[]>(null as any);
    }
}

@Injectable()
export class KnowledgebaseApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://192.168.253.100:5000";
    }

    /**
     * @return Success
     */
    getlist(): Observable<KnowledgeBaseModel[]> {
        let url_ = this.baseUrl + "/api/contents/knowledgebase/getlist";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetlist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<KnowledgeBaseModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<KnowledgeBaseModel[]>;
        }));
    }

    protected processGetlist(response: HttpResponseBase): Observable<KnowledgeBaseModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(KnowledgeBaseModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<KnowledgeBaseModel[]>(null as any);
    }
}

@Injectable()
export class MatriksApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://192.168.253.100:5000";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getturkeydebenturedata(body: string[] | undefined): Observable<DebentureModel> {
        let url_ = this.baseUrl + "/api/proxy/matriks/getturkeydebenturedata";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetturkeydebenturedata(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetturkeydebenturedata(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DebentureModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DebentureModel>;
        }));
    }

    protected processGetturkeydebenturedata(response: HttpResponseBase): Observable<DebentureModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DebentureModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DebentureModel>(null as any);
    }

    /**
     * @param graphic (optional) 
     * @param symbol (optional) 
     * @return Success
     */
    getgraphdata(graphic: MatriksGraphType | undefined, symbol: string | undefined): Observable<GraphicDataModel> {
        let url_ = this.baseUrl + "/api/proxy/matriks/getgraphdata?";
        if (graphic === null)
            throw new Error("The parameter 'graphic' cannot be null.");
        else if (graphic !== undefined)
            url_ += "graphic=" + encodeURIComponent("" + graphic) + "&";
        if (symbol === null)
            throw new Error("The parameter 'symbol' cannot be null.");
        else if (symbol !== undefined)
            url_ += "symbol=" + encodeURIComponent("" + symbol) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetgraphdata(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetgraphdata(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GraphicDataModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GraphicDataModel>;
        }));
    }

    protected processGetgraphdata(response: HttpResponseBase): Observable<GraphicDataModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GraphicDataModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GraphicDataModel>(null as any);
    }

    /**
     * @return Success
     */
    getmatriksnewsdata(): Observable<MatriksNewsModel> {
        let url_ = this.baseUrl + "/api/proxy/matriks/getmatriksnewsdata";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetmatriksnewsdata(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetmatriksnewsdata(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MatriksNewsModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MatriksNewsModel>;
        }));
    }

    protected processGetmatriksnewsdata(response: HttpResponseBase): Observable<MatriksNewsModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MatriksNewsModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MatriksNewsModel>(null as any);
    }

    /**
     * @param newsId (optional) 
     * @return Success
     */
    getmatriksnewsdetaildata(newsId: string | undefined): Observable<MatriksNewsModel> {
        let url_ = this.baseUrl + "/api/proxy/matriks/getmatriksnewsdetaildata?";
        if (newsId === null)
            throw new Error("The parameter 'newsId' cannot be null.");
        else if (newsId !== undefined)
            url_ += "newsId=" + encodeURIComponent("" + newsId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetmatriksnewsdetaildata(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetmatriksnewsdetaildata(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MatriksNewsModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MatriksNewsModel>;
        }));
    }

    protected processGetmatriksnewsdetaildata(response: HttpResponseBase): Observable<MatriksNewsModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MatriksNewsModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MatriksNewsModel>(null as any);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    getmatrikseconomynewsdata(startDate: moment.Moment | undefined, endDate: moment.Moment | undefined): Observable<MatriksEconomyNewsModel> {
        let url_ = this.baseUrl + "/api/proxy/matriks/getmatrikseconomynewsdata?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetmatrikseconomynewsdata(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetmatrikseconomynewsdata(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MatriksEconomyNewsModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MatriksEconomyNewsModel>;
        }));
    }

    protected processGetmatrikseconomynewsdata(response: HttpResponseBase): Observable<MatriksEconomyNewsModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MatriksEconomyNewsModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MatriksEconomyNewsModel>(null as any);
    }

    /**
     * @return Success
     */
    getmatriksmarketmodeldata(): Observable<MarketModel> {
        let url_ = this.baseUrl + "/api/proxy/matriks/getmatriksmarketmodeldata";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetmatriksmarketmodeldata(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetmatriksmarketmodeldata(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MarketModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MarketModel>;
        }));
    }

    protected processGetmatriksmarketmodeldata(response: HttpResponseBase): Observable<MarketModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MarketModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MarketModel>(null as any);
    }
}

@Injectable()
export class MediatypeApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://192.168.253.100:5000";
    }

    /**
     * @return Success
     */
    getlist(): Observable<MediaTypeModel[]> {
        let url_ = this.baseUrl + "/api/settings/code/mediatype/getlist";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetlist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MediaTypeModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MediaTypeModel[]>;
        }));
    }

    protected processGetlist(response: HttpResponseBase): Observable<MediaTypeModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MediaTypeModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MediaTypeModel[]>(null as any);
    }
}

@Injectable()
export class NotificationApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://192.168.253.100:5000";
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    getnotifications(userId: number | undefined): Observable<NotificationModel[]> {
        let url_ = this.baseUrl + "/api/contents/notification/getnotifications?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetnotifications(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetnotifications(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NotificationModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NotificationModel[]>;
        }));
    }

    protected processGetnotifications(response: HttpResponseBase): Observable<NotificationModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NotificationModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NotificationModel[]>(null as any);
    }

    /**
     * @param notificationId (optional) 
     * @return Success
     */
    deletenotification(notificationId: number | undefined): Observable<NotificationModel> {
        let url_ = this.baseUrl + "/api/contents/notification/deletenotification?";
        if (notificationId === null)
            throw new Error("The parameter 'notificationId' cannot be null.");
        else if (notificationId !== undefined)
            url_ += "notificationId=" + encodeURIComponent("" + notificationId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletenotification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletenotification(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NotificationModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NotificationModel>;
        }));
    }

    protected processDeletenotification(response: HttpResponseBase): Observable<NotificationModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NotificationModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NotificationModel>(null as any);
    }
}

@Injectable()
export class NotificationtypeApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://192.168.253.100:5000";
    }

    /**
     * @return Success
     */
    getlist(): Observable<NotificationTypeModel[]> {
        let url_ = this.baseUrl + "/api/settings/code/notificationtype/getlist";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetlist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NotificationTypeModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NotificationTypeModel[]>;
        }));
    }

    protected processGetlist(response: HttpResponseBase): Observable<NotificationTypeModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NotificationTypeModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NotificationTypeModel[]>(null as any);
    }
}

@Injectable()
export class OrderApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://192.168.253.100:5000";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    adddigitalorder(body: RequestCompleteDigitalOrderModel | undefined): Observable<RequestCompleteDigitalOrderModel> {
        let url_ = this.baseUrl + "/api/commerce/order/adddigitalorder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdddigitalorder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdddigitalorder(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RequestCompleteDigitalOrderModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RequestCompleteDigitalOrderModel>;
        }));
    }

    protected processAdddigitalorder(response: HttpResponseBase): Observable<RequestCompleteDigitalOrderModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RequestCompleteDigitalOrderModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RequestCompleteDigitalOrderModel>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addphysicalorder(body: RequestPhysicalOrderModel | undefined): Observable<ResponsePhysicalOrderModel> {
        let url_ = this.baseUrl + "/api/commerce/order/addphysicalorder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddphysicalorder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddphysicalorder(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponsePhysicalOrderModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponsePhysicalOrderModel>;
        }));
    }

    protected processAddphysicalorder(response: HttpResponseBase): Observable<ResponsePhysicalOrderModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponsePhysicalOrderModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponsePhysicalOrderModel>(null as any);
    }

    /**
     * @param orderId (optional) 
     * @return Success
     */
    canceldigitalorder(orderId: number | undefined): Observable<ResponseDigitalOrderModel> {
        let url_ = this.baseUrl + "/api/commerce/order/canceldigitalorder?";
        if (orderId === null)
            throw new Error("The parameter 'orderId' cannot be null.");
        else if (orderId !== undefined)
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCanceldigitalorder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCanceldigitalorder(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseDigitalOrderModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseDigitalOrderModel>;
        }));
    }

    protected processCanceldigitalorder(response: HttpResponseBase): Observable<ResponseDigitalOrderModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseDigitalOrderModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseDigitalOrderModel>(null as any);
    }

    /**
     * @param orderId (optional) 
     * @return Success
     */
    cancelphysicalorder(orderId: number | undefined): Observable<ResponsePhysicalOrderModel> {
        let url_ = this.baseUrl + "/api/commerce/order/cancelphysicalorder?";
        if (orderId === null)
            throw new Error("The parameter 'orderId' cannot be null.");
        else if (orderId !== undefined)
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancelphysicalorder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelphysicalorder(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponsePhysicalOrderModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponsePhysicalOrderModel>;
        }));
    }

    protected processCancelphysicalorder(response: HttpResponseBase): Observable<ResponsePhysicalOrderModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponsePhysicalOrderModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponsePhysicalOrderModel>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    completedigitalorder(body: CompleDigitalOrderModel | undefined): Observable<ResponseDigitalOrderModel> {
        let url_ = this.baseUrl + "/api/commerce/order/completedigitalorder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCompletedigitalorder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCompletedigitalorder(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseDigitalOrderModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseDigitalOrderModel>;
        }));
    }

    protected processCompletedigitalorder(response: HttpResponseBase): Observable<ResponseDigitalOrderModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseDigitalOrderModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseDigitalOrderModel>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    completephysicalorder(body: ComplePhysicalOrderModel | undefined): Observable<ResponsePhysicalOrderModel> {
        let url_ = this.baseUrl + "/api/commerce/order/completephysicalorder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCompletephysicalorder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCompletephysicalorder(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponsePhysicalOrderModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponsePhysicalOrderModel>;
        }));
    }

    protected processCompletephysicalorder(response: HttpResponseBase): Observable<ResponsePhysicalOrderModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponsePhysicalOrderModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponsePhysicalOrderModel>(null as any);
    }

    /**
     * @param orderId (optional) 
     * @return Success
     */
    getdigitalorderbyid(orderId: number | undefined): Observable<ResponseDigitalOrderModel> {
        let url_ = this.baseUrl + "/api/commerce/order/getdigitalorderbyid?";
        if (orderId === null)
            throw new Error("The parameter 'orderId' cannot be null.");
        else if (orderId !== undefined)
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetdigitalorderbyid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetdigitalorderbyid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseDigitalOrderModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseDigitalOrderModel>;
        }));
    }

    protected processGetdigitalorderbyid(response: HttpResponseBase): Observable<ResponseDigitalOrderModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseDigitalOrderModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseDigitalOrderModel>(null as any);
    }

    /**
     * @param orderId (optional) 
     * @return Success
     */
    getphysicalorderbyid(orderId: number | undefined): Observable<RequestPhysicalOrderModel> {
        let url_ = this.baseUrl + "/api/commerce/order/getphysicalorderbyid?";
        if (orderId === null)
            throw new Error("The parameter 'orderId' cannot be null.");
        else if (orderId !== undefined)
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetphysicalorderbyid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetphysicalorderbyid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RequestPhysicalOrderModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RequestPhysicalOrderModel>;
        }));
    }

    protected processGetphysicalorderbyid(response: HttpResponseBase): Observable<RequestPhysicalOrderModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RequestPhysicalOrderModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RequestPhysicalOrderModel>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updatedigitalorder(body: ResponseDigitalOrderModel | undefined): Observable<ResponseDigitalOrderModel> {
        let url_ = this.baseUrl + "/api/commerce/order/updatedigitalorder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatedigitalorder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatedigitalorder(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseDigitalOrderModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseDigitalOrderModel>;
        }));
    }

    protected processUpdatedigitalorder(response: HttpResponseBase): Observable<ResponseDigitalOrderModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseDigitalOrderModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseDigitalOrderModel>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updatephysicalorder(body: ResponsePhysicalOrderModel | undefined): Observable<ResponsePhysicalOrderModel> {
        let url_ = this.baseUrl + "/api/commerce/order/updatephysicalorder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatephysicalorder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatephysicalorder(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponsePhysicalOrderModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponsePhysicalOrderModel>;
        }));
    }

    protected processUpdatephysicalorder(response: HttpResponseBase): Observable<ResponsePhysicalOrderModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponsePhysicalOrderModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponsePhysicalOrderModel>(null as any);
    }
}

@Injectable()
export class OrderstatusApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://192.168.253.100:5000";
    }

    /**
     * @return Success
     */
    getlist(): Observable<OrderStatusModel[]> {
        let url_ = this.baseUrl + "/api/settings/code/orderstatus/getlist";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetlist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrderStatusModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrderStatusModel[]>;
        }));
    }

    protected processGetlist(response: HttpResponseBase): Observable<OrderStatusModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OrderStatusModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrderStatusModel[]>(null as any);
    }
}

@Injectable()
export class PaymenttypeApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://192.168.253.100:5000";
    }

    /**
     * @return Success
     */
    getlist(): Observable<PaymentTypeModel[]> {
        let url_ = this.baseUrl + "/api/settings/code/paymenttype/getlist";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetlist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentTypeModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentTypeModel[]>;
        }));
    }

    protected processGetlist(response: HttpResponseBase): Observable<PaymentTypeModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PaymentTypeModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaymentTypeModel[]>(null as any);
    }
}

@Injectable()
export class PostApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://192.168.253.100:5000";
    }

    /**
     * @return Success
     */
    getlist(): Observable<PostModel[]> {
        let url_ = this.baseUrl + "/api/contents/post/getlist";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetlist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PostModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PostModel[]>;
        }));
    }

    protected processGetlist(response: HttpResponseBase): Observable<PostModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PostModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PostModel[]>(null as any);
    }
}

@Injectable()
export class ProducttypeApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://192.168.253.100:5000";
    }

    /**
     * @return Success
     */
    getlist(): Observable<ProductTypeModel[]> {
        let url_ = this.baseUrl + "/api/settings/code/producttype/getlist";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetlist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductTypeModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductTypeModel[]>;
        }));
    }

    protected processGetlist(response: HttpResponseBase): Observable<ProductTypeModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProductTypeModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductTypeModel[]>(null as any);
    }
}

@Injectable()
export class ProductunitApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://192.168.253.100:5000";
    }

    /**
     * @return Success
     */
    getlist(): Observable<ProductUnitModel[]> {
        let url_ = this.baseUrl + "/api/settings/code/productunit/getlist";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetlist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProductUnitModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProductUnitModel[]>;
        }));
    }

    protected processGetlist(response: HttpResponseBase): Observable<ProductUnitModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProductUnitModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductUnitModel[]>(null as any);
    }
}

@Injectable()
export class ProvinceApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://192.168.253.100:5000";
    }

    /**
     * @return Success
     */
    getlist(): Observable<ProvinceModel[]> {
        let url_ = this.baseUrl + "/api/settings/place/province/getlist";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetlist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProvinceModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProvinceModel[]>;
        }));
    }

    protected processGetlist(response: HttpResponseBase): Observable<ProvinceModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProvinceModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProvinceModel[]>(null as any);
    }
}

@Injectable()
export class RequeststatusApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://192.168.253.100:5000";
    }

    /**
     * @return Success
     */
    getlist(): Observable<RequestStatusModel[]> {
        let url_ = this.baseUrl + "/api/settings/code/requeststatus/getlist";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetlist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RequestStatusModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RequestStatusModel[]>;
        }));
    }

    protected processGetlist(response: HttpResponseBase): Observable<RequestStatusModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RequestStatusModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RequestStatusModel[]>(null as any);
    }
}

@Injectable()
export class RequesttypeApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://192.168.253.100:5000";
    }

    /**
     * @return Success
     */
    getlist(): Observable<RequestTypeModel[]> {
        let url_ = this.baseUrl + "/api/settings/code/requesttype/getlist";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetlist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RequestTypeModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RequestTypeModel[]>;
        }));
    }

    protected processGetlist(response: HttpResponseBase): Observable<RequestTypeModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RequestTypeModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RequestTypeModel[]>(null as any);
    }
}

@Injectable()
export class RetailApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://192.168.253.100:5000";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    add(body: Retail | undefined): Observable<RetailModel> {
        let url_ = this.baseUrl + "/api/auth/retail/add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RetailModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RetailModel>;
        }));
    }

    protected processAdd(response: HttpResponseBase): Observable<RetailModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RetailModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RetailModel>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getbyid(id: number | undefined): Observable<RetailModel> {
        let url_ = this.baseUrl + "/api/auth/retail/getbyid?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RetailModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RetailModel>;
        }));
    }

    protected processGetbyid(response: HttpResponseBase): Observable<RetailModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RetailModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RetailModel>(null as any);
    }

    /**
     * @return Success
     */
    read(): Observable<RetailModel[]> {
        let url_ = this.baseUrl + "/api/auth/retail/read";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRead(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RetailModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RetailModel[]>;
        }));
    }

    protected processRead(response: HttpResponseBase): Observable<RetailModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RetailModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RetailModel[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: Retail | undefined): Observable<RetailModel> {
        let url_ = this.baseUrl + "/api/auth/retail/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RetailModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RetailModel>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<RetailModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RetailModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RetailModel>(null as any);
    }
}

@Injectable()
export class RssfeedApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://192.168.253.100:5000";
    }

    /**
     * @return Success
     */
    getlist(): Observable<RssFeedModel[]> {
        let url_ = this.baseUrl + "/api/contents/rssfeed/getlist";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetlist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RssFeedModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RssFeedModel[]>;
        }));
    }

    protected processGetlist(response: HttpResponseBase): Observable<RssFeedModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RssFeedModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RssFeedModel[]>(null as any);
    }
}

@Injectable()
export class ScantypeApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://192.168.253.100:5000";
    }

    /**
     * @return Success
     */
    getlist(): Observable<ScanTypeModel[]> {
        let url_ = this.baseUrl + "/api/settings/code/scantype/getlist";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetlist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ScanTypeModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ScanTypeModel[]>;
        }));
    }

    protected processGetlist(response: HttpResponseBase): Observable<ScanTypeModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ScanTypeModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ScanTypeModel[]>(null as any);
    }
}

@Injectable()
export class SettingApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://192.168.253.100:5000";
    }

    /**
     * @return Success
     */
    getlist(): Observable<SettingModel[]> {
        let url_ = this.baseUrl + "/api/settings/core/setting/getlist";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetlist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SettingModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SettingModel[]>;
        }));
    }

    protected processGetlist(response: HttpResponseBase): Observable<SettingModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SettingModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SettingModel[]>(null as any);
    }
}

@Injectable()
export class SlideApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://192.168.253.100:5000";
    }

    /**
     * @param slideTypeId (optional) 
     * @return Success
     */
    getslides(slideTypeId: number | undefined): Observable<SlideModel[]> {
        let url_ = this.baseUrl + "/api/contents/slide/getslides?";
        if (slideTypeId === null)
            throw new Error("The parameter 'slideTypeId' cannot be null.");
        else if (slideTypeId !== undefined)
            url_ += "slideTypeId=" + encodeURIComponent("" + slideTypeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetslides(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetslides(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SlideModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SlideModel[]>;
        }));
    }

    protected processGetslides(response: HttpResponseBase): Observable<SlideModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SlideModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SlideModel[]>(null as any);
    }
}

@Injectable()
export class StaticpageApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://192.168.253.100:5000";
    }

    /**
     * @return Success
     */
    getlist(): Observable<StaticPageModel[]> {
        let url_ = this.baseUrl + "/api/contents/staticpage/getlist";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetlist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StaticPageModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StaticPageModel[]>;
        }));
    }

    protected processGetlist(response: HttpResponseBase): Observable<StaticPageModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(StaticPageModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StaticPageModel[]>(null as any);
    }
}

@Injectable()
export class SymbolsApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://192.168.253.100:5000";
    }

    /**
     * @return Success
     */
    getsymbollist(): Observable<SymbolModel[]> {
        let url_ = this.baseUrl + "/api/finance/symbols/getsymbollist";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetsymbollist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetsymbollist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SymbolModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SymbolModel[]>;
        }));
    }

    protected processGetsymbollist(response: HttpResponseBase): Observable<SymbolModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SymbolModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SymbolModel[]>(null as any);
    }

    /**
     * @return Success
     */
    getsymbolrates(): Observable<SymbolRateModel[]> {
        let url_ = this.baseUrl + "/api/finance/symbols/getsymbolrates";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetsymbolrates(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetsymbolrates(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SymbolRateModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SymbolRateModel[]>;
        }));
    }

    protected processGetsymbolrates(response: HttpResponseBase): Observable<SymbolRateModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SymbolRateModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SymbolRateModel[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addsymbolalarm(body: SymbolAlarmModel | undefined): Observable<SymbolAlarmModel> {
        let url_ = this.baseUrl + "/api/finance/symbols/addsymbolalarm";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddsymbolalarm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddsymbolalarm(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SymbolAlarmModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SymbolAlarmModel>;
        }));
    }

    protected processAddsymbolalarm(response: HttpResponseBase): Observable<SymbolAlarmModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SymbolAlarmModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SymbolAlarmModel>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deletesymbolalarm(body: SymbolAlarmModel | undefined): Observable<SymbolAlarmModel> {
        let url_ = this.baseUrl + "/api/finance/symbols/deletesymbolalarm";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletesymbolalarm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletesymbolalarm(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SymbolAlarmModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SymbolAlarmModel>;
        }));
    }

    protected processDeletesymbolalarm(response: HttpResponseBase): Observable<SymbolAlarmModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SymbolAlarmModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SymbolAlarmModel>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    togglesymbolvote(body: SymbolVoteRequestModel | undefined): Observable<SymbolVoteSummaryModel> {
        let url_ = this.baseUrl + "/api/finance/symbols/togglesymbolvote";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTogglesymbolvote(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTogglesymbolvote(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SymbolVoteSummaryModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SymbolVoteSummaryModel>;
        }));
    }

    protected processTogglesymbolvote(response: HttpResponseBase): Observable<SymbolVoteSummaryModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SymbolVoteSummaryModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SymbolVoteSummaryModel>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getsymbolvotesummary(body: SymbolVoteRequestModel | undefined): Observable<SymbolVoteSummaryModel> {
        let url_ = this.baseUrl + "/api/finance/symbols/getsymbolvotesummary";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetsymbolvotesummary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetsymbolvotesummary(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SymbolVoteSummaryModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SymbolVoteSummaryModel>;
        }));
    }

    protected processGetsymbolvotesummary(response: HttpResponseBase): Observable<SymbolVoteSummaryModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SymbolVoteSummaryModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SymbolVoteSummaryModel>(null as any);
    }
}

@Injectable()
export class SymboltypeApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://192.168.253.100:5000";
    }

    /**
     * @return Success
     */
    getlist(): Observable<SymbolTypeModel[]> {
        let url_ = this.baseUrl + "/api/settings/code/symboltype/getlist";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetlist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SymbolTypeModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SymbolTypeModel[]>;
        }));
    }

    protected processGetlist(response: HttpResponseBase): Observable<SymbolTypeModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SymbolTypeModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SymbolTypeModel[]>(null as any);
    }
}

@Injectable()
export class TransactionsApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://192.168.253.100:5000";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    gettransactionhistory(body: TransactionRequestModel | undefined): Observable<TransactionModel[]> {
        let url_ = this.baseUrl + "/api/finance/transactions/gettransactionhistory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGettransactionhistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGettransactionhistory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TransactionModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TransactionModel[]>;
        }));
    }

    protected processGettransactionhistory(response: HttpResponseBase): Observable<TransactionModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TransactionModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransactionModel[]>(null as any);
    }
}

@Injectable()
export class TransactiontypeApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://192.168.253.100:5000";
    }

    /**
     * @return Success
     */
    getlist(): Observable<TransactionTypeModel[]> {
        let url_ = this.baseUrl + "/api/settings/code/transactiontype/getlist";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetlist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TransactionTypeModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TransactionTypeModel[]>;
        }));
    }

    protected processGetlist(response: HttpResponseBase): Observable<TransactionTypeModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TransactionTypeModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransactionTypeModel[]>(null as any);
    }
}

@Injectable()
export class WithdrawalsApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://192.168.253.100:5000";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addphysical(body: Request | undefined): Observable<RequestModel> {
        let url_ = this.baseUrl + "/api/finance/withdrawals/addphysical";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddphysical(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddphysical(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RequestModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RequestModel>;
        }));
    }

    protected processAddphysical(response: HttpResponseBase): Observable<RequestModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RequestModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RequestModel>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    adddigital(body: Request | undefined): Observable<RequestModel> {
        let url_ = this.baseUrl + "/api/finance/withdrawals/adddigital";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdddigital(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdddigital(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RequestModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RequestModel>;
        }));
    }

    protected processAdddigital(response: HttpResponseBase): Observable<RequestModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RequestModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RequestModel>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getbyid(id: number | undefined): Observable<RequestModel> {
        let url_ = this.baseUrl + "/api/finance/withdrawals/getbyid?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RequestModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RequestModel>;
        }));
    }

    protected processGetbyid(response: HttpResponseBase): Observable<RequestModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RequestModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RequestModel>(null as any);
    }

    getdetailbyid(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/finance/withdrawals/getdetailbyid?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetdetailbyid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetdetailbyid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetdetailbyid(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param customerId (optional) 
     * @return Success
     */
    getdigitalrequestlist(customerId: number | undefined): Observable<RequestModel[]> {
        let url_ = this.baseUrl + "/api/finance/withdrawals/getdigitalrequestlist?";
        if (customerId === null)
            throw new Error("The parameter 'customerId' cannot be null.");
        else if (customerId !== undefined)
            url_ += "customerId=" + encodeURIComponent("" + customerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetdigitalrequestlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetdigitalrequestlist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RequestModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RequestModel[]>;
        }));
    }

    protected processGetdigitalrequestlist(response: HttpResponseBase): Observable<RequestModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RequestModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RequestModel[]>(null as any);
    }

    /**
     * @param customerId (optional) 
     * @return Success
     */
    getphysicalrequestlist(customerId: number | undefined): Observable<RequestModel[]> {
        let url_ = this.baseUrl + "/api/finance/withdrawals/getphysicalrequestlist?";
        if (customerId === null)
            throw new Error("The parameter 'customerId' cannot be null.");
        else if (customerId !== undefined)
            url_ += "customerId=" + encodeURIComponent("" + customerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetphysicalrequestlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetphysicalrequestlist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RequestModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RequestModel[]>;
        }));
    }

    protected processGetphysicalrequestlist(response: HttpResponseBase): Observable<RequestModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RequestModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RequestModel[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: Request | undefined): Observable<RequestModel> {
        let url_ = this.baseUrl + "/api/finance/withdrawals/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RequestModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RequestModel>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<RequestModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RequestModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RequestModel>(null as any);
    }
}

export class Address implements IAddress {
    id?: number;
    name?: string | undefined;
    contactName?: string | undefined;
    phone?: string | undefined;
    addressLine?: string | undefined;
    directions?: string | undefined;
    latitude?: number;
    longitude?: number;
    neighborhoodId?: number | undefined;
    neighborhood?: Neighborhood;
    districtId?: number | undefined;
    district?: District;
    provinceId?: number;
    province?: Province;
    countryId?: string | undefined;
    country?: Country;

    constructor(data?: IAddress) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.name = _data["Name"];
            this.contactName = _data["ContactName"];
            this.phone = _data["Phone"];
            this.addressLine = _data["AddressLine"];
            this.directions = _data["Directions"];
            this.latitude = _data["Latitude"];
            this.longitude = _data["Longitude"];
            this.neighborhoodId = _data["NeighborhoodId"];
            this.neighborhood = _data["Neighborhood"] ? Neighborhood.fromJS(_data["Neighborhood"]) : <any>undefined;
            this.districtId = _data["DistrictId"];
            this.district = _data["District"] ? District.fromJS(_data["District"]) : <any>undefined;
            this.provinceId = _data["ProvinceId"];
            this.province = _data["Province"] ? Province.fromJS(_data["Province"]) : <any>undefined;
            this.countryId = _data["CountryId"];
            this.country = _data["Country"] ? Country.fromJS(_data["Country"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Address {
        data = typeof data === 'object' ? data : {};
        let result = new Address();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Name"] = this.name;
        data["ContactName"] = this.contactName;
        data["Phone"] = this.phone;
        data["AddressLine"] = this.addressLine;
        data["Directions"] = this.directions;
        data["Latitude"] = this.latitude;
        data["Longitude"] = this.longitude;
        data["NeighborhoodId"] = this.neighborhoodId;
        data["Neighborhood"] = this.neighborhood ? this.neighborhood.toJSON() : <any>undefined;
        data["DistrictId"] = this.districtId;
        data["District"] = this.district ? this.district.toJSON() : <any>undefined;
        data["ProvinceId"] = this.provinceId;
        data["Province"] = this.province ? this.province.toJSON() : <any>undefined;
        data["CountryId"] = this.countryId;
        data["Country"] = this.country ? this.country.toJSON() : <any>undefined;
        return data;
    }
}

export interface IAddress {
    id?: number;
    name?: string | undefined;
    contactName?: string | undefined;
    phone?: string | undefined;
    addressLine?: string | undefined;
    directions?: string | undefined;
    latitude?: number;
    longitude?: number;
    neighborhoodId?: number | undefined;
    neighborhood?: Neighborhood;
    districtId?: number | undefined;
    district?: District;
    provinceId?: number;
    province?: Province;
    countryId?: string | undefined;
    country?: Country;
}

export class Altin implements IAltin {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IAltin) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): Altin {
        data = typeof data === 'object' ? data : {};
        let result = new Altin();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IAltin {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class Altincum implements IAltincum {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IAltincum) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): Altincum {
        data = typeof data === 'object' ? data : {};
        let result = new Altincum();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IAltincum {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class AltinfixEurAm implements IAltinfixEurAm {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IAltinfixEurAm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): AltinfixEurAm {
        data = typeof data === 'object' ? data : {};
        let result = new AltinfixEurAm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IAltinfixEurAm {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class AltinfixEurPm implements IAltinfixEurPm {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IAltinfixEurPm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): AltinfixEurPm {
        data = typeof data === 'object' ? data : {};
        let result = new AltinfixEurPm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IAltinfixEurPm {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class AltinfixGbpAm implements IAltinfixGbpAm {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IAltinfixGbpAm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): AltinfixGbpAm {
        data = typeof data === 'object' ? data : {};
        let result = new AltinfixGbpAm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IAltinfixGbpAm {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class AltinfixGbpPm implements IAltinfixGbpPm {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IAltinfixGbpPm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): AltinfixGbpPm {
        data = typeof data === 'object' ? data : {};
        let result = new AltinfixGbpPm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IAltinfixGbpPm {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class AltinfixUsdAm implements IAltinfixUsdAm {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IAltinfixUsdAm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): AltinfixUsdAm {
        data = typeof data === 'object' ? data : {};
        let result = new AltinfixUsdAm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IAltinfixUsdAm {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class AltinfixUsdPm implements IAltinfixUsdPm {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IAltinfixUsdPm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): AltinfixUsdPm {
        data = typeof data === 'object' ? data : {};
        let result = new AltinfixUsdPm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IAltinfixUsdPm {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class Altingldc implements IAltingldc {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IAltingldc) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): Altingldc {
        data = typeof data === 'object' ? data : {};
        let result = new Altingldc();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IAltingldc {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class Altingldt implements IAltingldt {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IAltingldt) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): Altingldt {
        data = typeof data === 'object' ? data : {};
        let result = new Altingldt();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IAltingldt {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class Altingldy implements IAltingldy {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IAltingldy) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): Altingldy {
        data = typeof data === 'object' ? data : {};
        let result = new Altingldy();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IAltingldy {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class Altingr implements IAltingr {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IAltingr) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): Altingr {
        data = typeof data === 'object' ? data : {};
        let result = new Altingr();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IAltingr {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class Altinkgtl implements IAltinkgtl {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IAltinkgtl) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): Altinkgtl {
        data = typeof data === 'object' ? data : {};
        let result = new Altinkgtl();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IAltinkgtl {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class Altinkgusd implements IAltinkgusd {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IAltinkgusd) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): Altinkgusd {
        data = typeof data === 'object' ? data : {};
        let result = new Altinkgusd();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IAltinkgusd {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class Altinres implements IAltinres {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IAltinres) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): Altinres {
        data = typeof data === 'object' ? data : {};
        let result = new Altinres();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IAltinres {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class Altinresk implements IAltinresk {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IAltinresk) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): Altinresk {
        data = typeof data === 'object' ? data : {};
        let result = new Altinresk();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IAltinresk {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class Altinusd implements IAltinusd {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IAltinusd) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): Altinusd {
        data = typeof data === 'object' ? data : {};
        let result = new Altinusd();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IAltinusd {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class AnalysisModel implements IAnalysisModel {
    title!: string;
    subTitle?: string | undefined;
    slug?: string | undefined;
    metaKeywords?: string | undefined;
    metaDescription?: string | undefined;
    body?: string | undefined;
    mediaId?: number | undefined;
    media?: MediaModel;
    isPublished?: boolean;
    publishedOn?: moment.Moment | undefined;
    publishedTill?: moment.Moment | undefined;
    symbolId?: number | undefined;
    symbol?: SymbolModel;

    constructor(data?: IAnalysisModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["Title"];
            this.subTitle = _data["SubTitle"];
            this.slug = _data["Slug"];
            this.metaKeywords = _data["MetaKeywords"];
            this.metaDescription = _data["MetaDescription"];
            this.body = _data["Body"];
            this.mediaId = _data["MediaId"];
            this.media = _data["Media"] ? MediaModel.fromJS(_data["Media"]) : <any>undefined;
            this.isPublished = _data["IsPublished"];
            this.publishedOn = _data["PublishedOn"] ? moment(_data["PublishedOn"].toString()) : <any>undefined;
            this.publishedTill = _data["PublishedTill"] ? moment(_data["PublishedTill"].toString()) : <any>undefined;
            this.symbolId = _data["SymbolId"];
            this.symbol = _data["Symbol"] ? SymbolModel.fromJS(_data["Symbol"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AnalysisModel {
        data = typeof data === 'object' ? data : {};
        let result = new AnalysisModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Title"] = this.title;
        data["SubTitle"] = this.subTitle;
        data["Slug"] = this.slug;
        data["MetaKeywords"] = this.metaKeywords;
        data["MetaDescription"] = this.metaDescription;
        data["Body"] = this.body;
        data["MediaId"] = this.mediaId;
        data["Media"] = this.media ? this.media.toJSON() : <any>undefined;
        data["IsPublished"] = this.isPublished;
        data["PublishedOn"] = this.publishedOn ? this.publishedOn.toISOString() : <any>undefined;
        data["PublishedTill"] = this.publishedTill ? this.publishedTill.toISOString() : <any>undefined;
        data["SymbolId"] = this.symbolId;
        data["Symbol"] = this.symbol ? this.symbol.toJSON() : <any>undefined;
        return data;
    }
}

export interface IAnalysisModel {
    title: string;
    subTitle?: string | undefined;
    slug?: string | undefined;
    metaKeywords?: string | undefined;
    metaDescription?: string | undefined;
    body?: string | undefined;
    mediaId?: number | undefined;
    media?: MediaModel;
    isPublished?: boolean;
    publishedOn?: moment.Moment | undefined;
    publishedTill?: moment.Moment | undefined;
    symbolId?: number | undefined;
    symbol?: SymbolModel;
}

export class APIResultDTO implements IAPIResultDTO {
    code?: number;
    message!: string;
    errors?: string[] | undefined;
    additionalProperties?: { [key: string]: any; } | undefined;

    constructor(data?: IAPIResultDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["Code"];
            this.message = _data["Message"];
            if (Array.isArray(_data["Errors"])) {
                this.errors = [] as any;
                for (let item of _data["Errors"])
                    this.errors!.push(item);
            }
            if (_data["AdditionalProperties"]) {
                this.additionalProperties = {} as any;
                for (let key in _data["AdditionalProperties"]) {
                    if (_data["AdditionalProperties"].hasOwnProperty(key))
                        (<any>this.additionalProperties)![key] = _data["AdditionalProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): APIResultDTO {
        data = typeof data === 'object' ? data : {};
        let result = new APIResultDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Code"] = this.code;
        data["Message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["Errors"] = [];
            for (let item of this.errors)
                data["Errors"].push(item);
        }
        if (this.additionalProperties) {
            data["AdditionalProperties"] = {};
            for (let key in this.additionalProperties) {
                if (this.additionalProperties.hasOwnProperty(key))
                    (<any>data["AdditionalProperties"])[key] = this.additionalProperties[key];
            }
        }
        return data;
    }
}

export interface IAPIResultDTO {
    code?: number;
    message: string;
    errors?: string[] | undefined;
    additionalProperties?: { [key: string]: any; } | undefined;
}

export class APIResultDTOApiException implements IAPIResultDTOApiException {
    targetSite?: MethodBase;
    readonly stackTrace?: string | undefined;
    readonly message?: string | undefined;
    readonly data?: { [key: string]: any; } | undefined;
    innerException?: Exception;
    helpLink?: string | undefined;
    source?: string | undefined;
    hResult?: number;
    readonly statusCode?: number;
    readonly response?: string | undefined;
    readonly headers?: { [key: string]: string[]; } | undefined;
    result?: APIResultDTO;

    constructor(data?: IAPIResultDTOApiException) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.targetSite = _data["TargetSite"] ? MethodBase.fromJS(_data["TargetSite"]) : <any>undefined;
            (<any>this).stackTrace = _data["StackTrace"];
            (<any>this).message = _data["Message"];
            if (_data["Data"]) {
                (<any>this).data = {} as any;
                for (let key in _data["Data"]) {
                    if (_data["Data"].hasOwnProperty(key))
                        (<any>(<any>this).data)![key] = _data["Data"][key];
                }
            }
            this.innerException = _data["InnerException"] ? Exception.fromJS(_data["InnerException"]) : <any>undefined;
            this.helpLink = _data["HelpLink"];
            this.source = _data["Source"];
            this.hResult = _data["HResult"];
            (<any>this).statusCode = _data["StatusCode"];
            (<any>this).response = _data["Response"];
            if (_data["Headers"]) {
                (<any>this).headers = {} as any;
                for (let key in _data["Headers"]) {
                    if (_data["Headers"].hasOwnProperty(key))
                        (<any>(<any>this).headers)![key] = _data["Headers"][key] !== undefined ? _data["Headers"][key] : [];
                }
            }
            this.result = _data["Result"] ? APIResultDTO.fromJS(_data["Result"]) : <any>undefined;
        }
    }

    static fromJS(data: any): APIResultDTOApiException {
        data = typeof data === 'object' ? data : {};
        let result = new APIResultDTOApiException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["TargetSite"] = this.targetSite ? this.targetSite.toJSON() : <any>undefined;
        data["StackTrace"] = this.stackTrace;
        data["Message"] = this.message;
        if (this.data) {
            data["Data"] = {};
            for (let key in this.data) {
                if (this.data.hasOwnProperty(key))
                    (<any>data["Data"])[key] = this.data[key];
            }
        }
        data["InnerException"] = this.innerException ? this.innerException.toJSON() : <any>undefined;
        data["HelpLink"] = this.helpLink;
        data["Source"] = this.source;
        data["HResult"] = this.hResult;
        data["StatusCode"] = this.statusCode;
        data["Response"] = this.response;
        if (this.headers) {
            data["Headers"] = {};
            for (let key in this.headers) {
                if (this.headers.hasOwnProperty(key))
                    (<any>data["Headers"])[key] = this.headers[key];
            }
        }
        data["Result"] = this.result ? this.result.toJSON() : <any>undefined;
        return data;
    }
}

export interface IAPIResultDTOApiException {
    targetSite?: MethodBase;
    stackTrace?: string | undefined;
    message?: string | undefined;
    data?: { [key: string]: any; } | undefined;
    innerException?: Exception;
    helpLink?: string | undefined;
    source?: string | undefined;
    hResult?: number;
    statusCode?: number;
    response?: string | undefined;
    headers?: { [key: string]: string[]; } | undefined;
    result?: APIResultDTO;
}

export class Assembly implements IAssembly {
    readonly definedTypes?: TypeInfo[] | undefined;
    readonly exportedTypes?: Type[] | undefined;
    readonly codeBase?: string | undefined;
    entryPoint?: MethodInfo;
    readonly fullName?: string | undefined;
    readonly imageRuntimeVersion?: string | undefined;
    readonly isDynamic?: boolean;
    readonly location?: string | undefined;
    readonly reflectionOnly?: boolean;
    readonly isCollectible?: boolean;
    readonly isFullyTrusted?: boolean;
    readonly customAttributes?: CustomAttributeData[] | undefined;
    readonly escapedCodeBase?: string | undefined;
    manifestModule?: Module;
    readonly modules?: Module[] | undefined;
    readonly globalAssemblyCache?: boolean;
    readonly hostContext?: number;
    securityRuleSet?: SecurityRuleSet;

    constructor(data?: IAssembly) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["DefinedTypes"])) {
                (<any>this).definedTypes = [] as any;
                for (let item of _data["DefinedTypes"])
                    (<any>this).definedTypes!.push(TypeInfo.fromJS(item));
            }
            if (Array.isArray(_data["ExportedTypes"])) {
                (<any>this).exportedTypes = [] as any;
                for (let item of _data["ExportedTypes"])
                    (<any>this).exportedTypes!.push(Type.fromJS(item));
            }
            (<any>this).codeBase = _data["CodeBase"];
            this.entryPoint = _data["EntryPoint"] ? MethodInfo.fromJS(_data["EntryPoint"]) : <any>undefined;
            (<any>this).fullName = _data["FullName"];
            (<any>this).imageRuntimeVersion = _data["ImageRuntimeVersion"];
            (<any>this).isDynamic = _data["IsDynamic"];
            (<any>this).location = _data["Location"];
            (<any>this).reflectionOnly = _data["ReflectionOnly"];
            (<any>this).isCollectible = _data["IsCollectible"];
            (<any>this).isFullyTrusted = _data["IsFullyTrusted"];
            if (Array.isArray(_data["CustomAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["CustomAttributes"])
                    (<any>this).customAttributes!.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).escapedCodeBase = _data["EscapedCodeBase"];
            this.manifestModule = _data["ManifestModule"] ? Module.fromJS(_data["ManifestModule"]) : <any>undefined;
            if (Array.isArray(_data["Modules"])) {
                (<any>this).modules = [] as any;
                for (let item of _data["Modules"])
                    (<any>this).modules!.push(Module.fromJS(item));
            }
            (<any>this).globalAssemblyCache = _data["GlobalAssemblyCache"];
            (<any>this).hostContext = _data["HostContext"];
            this.securityRuleSet = _data["SecurityRuleSet"];
        }
    }

    static fromJS(data: any): Assembly {
        data = typeof data === 'object' ? data : {};
        let result = new Assembly();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.definedTypes)) {
            data["DefinedTypes"] = [];
            for (let item of this.definedTypes)
                data["DefinedTypes"].push(item.toJSON());
        }
        if (Array.isArray(this.exportedTypes)) {
            data["ExportedTypes"] = [];
            for (let item of this.exportedTypes)
                data["ExportedTypes"].push(item.toJSON());
        }
        data["CodeBase"] = this.codeBase;
        data["EntryPoint"] = this.entryPoint ? this.entryPoint.toJSON() : <any>undefined;
        data["FullName"] = this.fullName;
        data["ImageRuntimeVersion"] = this.imageRuntimeVersion;
        data["IsDynamic"] = this.isDynamic;
        data["Location"] = this.location;
        data["ReflectionOnly"] = this.reflectionOnly;
        data["IsCollectible"] = this.isCollectible;
        data["IsFullyTrusted"] = this.isFullyTrusted;
        if (Array.isArray(this.customAttributes)) {
            data["CustomAttributes"] = [];
            for (let item of this.customAttributes)
                data["CustomAttributes"].push(item.toJSON());
        }
        data["EscapedCodeBase"] = this.escapedCodeBase;
        data["ManifestModule"] = this.manifestModule ? this.manifestModule.toJSON() : <any>undefined;
        if (Array.isArray(this.modules)) {
            data["Modules"] = [];
            for (let item of this.modules)
                data["Modules"].push(item.toJSON());
        }
        data["GlobalAssemblyCache"] = this.globalAssemblyCache;
        data["HostContext"] = this.hostContext;
        data["SecurityRuleSet"] = this.securityRuleSet;
        return data;
    }
}

export interface IAssembly {
    definedTypes?: TypeInfo[] | undefined;
    exportedTypes?: Type[] | undefined;
    codeBase?: string | undefined;
    entryPoint?: MethodInfo;
    fullName?: string | undefined;
    imageRuntimeVersion?: string | undefined;
    isDynamic?: boolean;
    location?: string | undefined;
    reflectionOnly?: boolean;
    isCollectible?: boolean;
    isFullyTrusted?: boolean;
    customAttributes?: CustomAttributeData[] | undefined;
    escapedCodeBase?: string | undefined;
    manifestModule?: Module;
    modules?: Module[] | undefined;
    globalAssemblyCache?: boolean;
    hostContext?: number;
    securityRuleSet?: SecurityRuleSet;
}

export class Asset implements IAsset {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    customerId?: number;
    customer?: Customer;
    symbolId?: number;
    symbol?: Symbol;
    quantity?: number;
    price?: number;

    constructor(data?: IAsset) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.createdOn = _data["CreatedOn"] ? moment(_data["CreatedOn"].toString()) : <any>undefined;
            this.createdById = _data["CreatedById"];
            this.createdBy = _data["CreatedBy"] ? User.fromJS(_data["CreatedBy"]) : <any>undefined;
            this.updatedOn = _data["UpdatedOn"] ? moment(_data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedById = _data["UpdatedById"];
            this.updatedBy = _data["UpdatedBy"] ? User.fromJS(_data["UpdatedBy"]) : <any>undefined;
            this.deletedOn = _data["DeletedOn"] ? moment(_data["DeletedOn"].toString()) : <any>undefined;
            this.deletedById = _data["DeletedById"];
            this.deletedBy = _data["DeletedBy"] ? User.fromJS(_data["DeletedBy"]) : <any>undefined;
            this.isDeleted = _data["IsDeleted"];
            this.customerId = _data["CustomerId"];
            this.customer = _data["Customer"] ? Customer.fromJS(_data["Customer"]) : <any>undefined;
            this.symbolId = _data["SymbolId"];
            this.symbol = _data["Symbol"] ? Symbol.fromJS(_data["Symbol"]) : <any>undefined;
            this.quantity = _data["Quantity"];
            this.price = _data["Price"];
        }
    }

    static fromJS(data: any): Asset {
        data = typeof data === 'object' ? data : {};
        let result = new Asset();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedById"] = this.createdById;
        data["CreatedBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["DeletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        data["DeletedById"] = this.deletedById;
        data["DeletedBy"] = this.deletedBy ? this.deletedBy.toJSON() : <any>undefined;
        data["IsDeleted"] = this.isDeleted;
        data["CustomerId"] = this.customerId;
        data["Customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        data["SymbolId"] = this.symbolId;
        data["Symbol"] = this.symbol ? this.symbol.toJSON() : <any>undefined;
        data["Quantity"] = this.quantity;
        data["Price"] = this.price;
        return data;
    }
}

export interface IAsset {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    customerId?: number;
    customer?: Customer;
    symbolId?: number;
    symbol?: Symbol;
    quantity?: number;
    price?: number;
}

export class AssetModel implements IAssetModel {
    id?: number;
    customerId?: number;
    customer?: CustomerModel;
    symbolId?: number;
    symbol?: SymbolModel;
    quantity?: number;
    price?: number;

    constructor(data?: IAssetModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.customerId = _data["CustomerId"];
            this.customer = _data["Customer"] ? CustomerModel.fromJS(_data["Customer"]) : <any>undefined;
            this.symbolId = _data["SymbolId"];
            this.symbol = _data["Symbol"] ? SymbolModel.fromJS(_data["Symbol"]) : <any>undefined;
            this.quantity = _data["Quantity"];
            this.price = _data["Price"];
        }
    }

    static fromJS(data: any): AssetModel {
        data = typeof data === 'object' ? data : {};
        let result = new AssetModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CustomerId"] = this.customerId;
        data["Customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        data["SymbolId"] = this.symbolId;
        data["Symbol"] = this.symbol ? this.symbol.toJSON() : <any>undefined;
        data["Quantity"] = this.quantity;
        data["Price"] = this.price;
        return data;
    }
}

export interface IAssetModel {
    id?: number;
    customerId?: number;
    customer?: CustomerModel;
    symbolId?: number;
    symbol?: SymbolModel;
    quantity?: number;
    price?: number;
}

export class Aud implements IAud {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IAud) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): Aud {
        data = typeof data === 'object' ? data : {};
        let result = new Aud();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IAud {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class Bank implements IBank {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    name!: string;
    logoId?: number | undefined;
    logo?: Media;
    description?: string | undefined;
    isActive?: boolean;

    constructor(data?: IBank) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.createdOn = _data["CreatedOn"] ? moment(_data["CreatedOn"].toString()) : <any>undefined;
            this.createdById = _data["CreatedById"];
            this.createdBy = _data["CreatedBy"] ? User.fromJS(_data["CreatedBy"]) : <any>undefined;
            this.updatedOn = _data["UpdatedOn"] ? moment(_data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedById = _data["UpdatedById"];
            this.updatedBy = _data["UpdatedBy"] ? User.fromJS(_data["UpdatedBy"]) : <any>undefined;
            this.deletedOn = _data["DeletedOn"] ? moment(_data["DeletedOn"].toString()) : <any>undefined;
            this.deletedById = _data["DeletedById"];
            this.deletedBy = _data["DeletedBy"] ? User.fromJS(_data["DeletedBy"]) : <any>undefined;
            this.isDeleted = _data["IsDeleted"];
            this.name = _data["Name"];
            this.logoId = _data["LogoId"];
            this.logo = _data["Logo"] ? Media.fromJS(_data["Logo"]) : <any>undefined;
            this.description = _data["Description"];
            this.isActive = _data["IsActive"];
        }
    }

    static fromJS(data: any): Bank {
        data = typeof data === 'object' ? data : {};
        let result = new Bank();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedById"] = this.createdById;
        data["CreatedBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["DeletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        data["DeletedById"] = this.deletedById;
        data["DeletedBy"] = this.deletedBy ? this.deletedBy.toJSON() : <any>undefined;
        data["IsDeleted"] = this.isDeleted;
        data["Name"] = this.name;
        data["LogoId"] = this.logoId;
        data["Logo"] = this.logo ? this.logo.toJSON() : <any>undefined;
        data["Description"] = this.description;
        data["IsActive"] = this.isActive;
        return data;
    }
}

export interface IBank {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    name: string;
    logoId?: number | undefined;
    logo?: Media;
    description?: string | undefined;
    isActive?: boolean;
}

export class BankModel implements IBankModel {
    id?: number;
    name?: string | undefined;
    description?: string | undefined;
    isActive?: boolean;

    constructor(data?: IBankModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.name = _data["Name"];
            this.description = _data["Description"];
            this.isActive = _data["IsActive"];
        }
    }

    static fromJS(data: any): BankModel {
        data = typeof data === 'object' ? data : {};
        let result = new BankModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Name"] = this.name;
        data["Description"] = this.description;
        data["IsActive"] = this.isActive;
        return data;
    }
}

export interface IBankModel {
    id?: number;
    name?: string | undefined;
    description?: string | undefined;
    isActive?: boolean;
}

export class BloodType implements IBloodType {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    code?: string | undefined;
    group?: string | undefined;
    rhPositive?: boolean;
    displayOrder?: number;
    readonly name?: string | undefined;

    constructor(data?: IBloodType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.createdOn = _data["CreatedOn"] ? moment(_data["CreatedOn"].toString()) : <any>undefined;
            this.createdById = _data["CreatedById"];
            this.createdBy = _data["CreatedBy"] ? User.fromJS(_data["CreatedBy"]) : <any>undefined;
            this.updatedOn = _data["UpdatedOn"] ? moment(_data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedById = _data["UpdatedById"];
            this.updatedBy = _data["UpdatedBy"] ? User.fromJS(_data["UpdatedBy"]) : <any>undefined;
            this.deletedOn = _data["DeletedOn"] ? moment(_data["DeletedOn"].toString()) : <any>undefined;
            this.deletedById = _data["DeletedById"];
            this.deletedBy = _data["DeletedBy"] ? User.fromJS(_data["DeletedBy"]) : <any>undefined;
            this.isDeleted = _data["IsDeleted"];
            this.code = _data["Code"];
            this.group = _data["Group"];
            this.rhPositive = _data["RhPositive"];
            this.displayOrder = _data["DisplayOrder"];
            (<any>this).name = _data["Name"];
        }
    }

    static fromJS(data: any): BloodType {
        data = typeof data === 'object' ? data : {};
        let result = new BloodType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedById"] = this.createdById;
        data["CreatedBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["DeletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        data["DeletedById"] = this.deletedById;
        data["DeletedBy"] = this.deletedBy ? this.deletedBy.toJSON() : <any>undefined;
        data["IsDeleted"] = this.isDeleted;
        data["Code"] = this.code;
        data["Group"] = this.group;
        data["RhPositive"] = this.rhPositive;
        data["DisplayOrder"] = this.displayOrder;
        data["Name"] = this.name;
        return data;
    }
}

export interface IBloodType {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    code?: string | undefined;
    group?: string | undefined;
    rhPositive?: boolean;
    displayOrder?: number;
    name?: string | undefined;
}

export class BloodTypeModel implements IBloodTypeModel {
    id?: number;
    code?: string | undefined;
    group?: string | undefined;
    rhPositive?: boolean;
    displayOrder?: number;
    name?: string | undefined;

    constructor(data?: IBloodTypeModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.code = _data["Code"];
            this.group = _data["Group"];
            this.rhPositive = _data["RhPositive"];
            this.displayOrder = _data["DisplayOrder"];
            this.name = _data["Name"];
        }
    }

    static fromJS(data: any): BloodTypeModel {
        data = typeof data === 'object' ? data : {};
        let result = new BloodTypeModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Code"] = this.code;
        data["Group"] = this.group;
        data["RhPositive"] = this.rhPositive;
        data["DisplayOrder"] = this.displayOrder;
        data["Name"] = this.name;
        return data;
    }
}

export interface IBloodTypeModel {
    id?: number;
    code?: string | undefined;
    group?: string | undefined;
    rhPositive?: boolean;
    displayOrder?: number;
    name?: string | undefined;
}

export class Bonus implements IBonus {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    customerId?: number;
    customer?: Customer;
    symbolId?: number;
    symbol?: Symbol;
    quantity?: number;
    price?: number;
    isUsed?: boolean;
    isActive?: boolean;

    constructor(data?: IBonus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.createdOn = _data["CreatedOn"] ? moment(_data["CreatedOn"].toString()) : <any>undefined;
            this.createdById = _data["CreatedById"];
            this.createdBy = _data["CreatedBy"] ? User.fromJS(_data["CreatedBy"]) : <any>undefined;
            this.updatedOn = _data["UpdatedOn"] ? moment(_data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedById = _data["UpdatedById"];
            this.updatedBy = _data["UpdatedBy"] ? User.fromJS(_data["UpdatedBy"]) : <any>undefined;
            this.deletedOn = _data["DeletedOn"] ? moment(_data["DeletedOn"].toString()) : <any>undefined;
            this.deletedById = _data["DeletedById"];
            this.deletedBy = _data["DeletedBy"] ? User.fromJS(_data["DeletedBy"]) : <any>undefined;
            this.isDeleted = _data["IsDeleted"];
            this.customerId = _data["CustomerId"];
            this.customer = _data["Customer"] ? Customer.fromJS(_data["Customer"]) : <any>undefined;
            this.symbolId = _data["SymbolId"];
            this.symbol = _data["Symbol"] ? Symbol.fromJS(_data["Symbol"]) : <any>undefined;
            this.quantity = _data["Quantity"];
            this.price = _data["Price"];
            this.isUsed = _data["IsUsed"];
            this.isActive = _data["IsActive"];
        }
    }

    static fromJS(data: any): Bonus {
        data = typeof data === 'object' ? data : {};
        let result = new Bonus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedById"] = this.createdById;
        data["CreatedBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["DeletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        data["DeletedById"] = this.deletedById;
        data["DeletedBy"] = this.deletedBy ? this.deletedBy.toJSON() : <any>undefined;
        data["IsDeleted"] = this.isDeleted;
        data["CustomerId"] = this.customerId;
        data["Customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        data["SymbolId"] = this.symbolId;
        data["Symbol"] = this.symbol ? this.symbol.toJSON() : <any>undefined;
        data["Quantity"] = this.quantity;
        data["Price"] = this.price;
        data["IsUsed"] = this.isUsed;
        data["IsActive"] = this.isActive;
        return data;
    }
}

export interface IBonus {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    customerId?: number;
    customer?: Customer;
    symbolId?: number;
    symbol?: Symbol;
    quantity?: number;
    price?: number;
    isUsed?: boolean;
    isActive?: boolean;
}

export class Cad implements ICad {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: ICad) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): Cad {
        data = typeof data === 'object' ? data : {};
        let result = new Cad();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface ICad {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export enum CallingConventions {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _32 = 32,
    _64 = 64,
}

export class CardCreateDTO implements ICardCreateDTO {
    alias!: string;
    cardHolder!: string;
    pAN!: string;
    expiryMonth!: string;
    expiryYear!: string;
    cVC!: string;
    useThreeDS?: boolean | undefined;
    additionalProperties?: { [key: string]: any; } | undefined;

    constructor(data?: ICardCreateDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alias = _data["Alias"];
            this.cardHolder = _data["CardHolder"];
            this.pAN = _data["PAN"];
            this.expiryMonth = _data["ExpiryMonth"];
            this.expiryYear = _data["ExpiryYear"];
            this.cVC = _data["CVC"];
            this.useThreeDS = _data["UseThreeDS"];
            if (_data["AdditionalProperties"]) {
                this.additionalProperties = {} as any;
                for (let key in _data["AdditionalProperties"]) {
                    if (_data["AdditionalProperties"].hasOwnProperty(key))
                        (<any>this.additionalProperties)![key] = _data["AdditionalProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): CardCreateDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CardCreateDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alias"] = this.alias;
        data["CardHolder"] = this.cardHolder;
        data["PAN"] = this.pAN;
        data["ExpiryMonth"] = this.expiryMonth;
        data["ExpiryYear"] = this.expiryYear;
        data["CVC"] = this.cVC;
        data["UseThreeDS"] = this.useThreeDS;
        if (this.additionalProperties) {
            data["AdditionalProperties"] = {};
            for (let key in this.additionalProperties) {
                if (this.additionalProperties.hasOwnProperty(key))
                    (<any>data["AdditionalProperties"])[key] = this.additionalProperties[key];
            }
        }
        return data;
    }
}

export interface ICardCreateDTO {
    alias: string;
    cardHolder: string;
    pAN: string;
    expiryMonth: string;
    expiryYear: string;
    cVC: string;
    useThreeDS?: boolean | undefined;
    additionalProperties?: { [key: string]: any; } | undefined;
}

export class CardDTO implements ICardDTO {
    alias?: string | undefined;
    cardID?: string | undefined;
    cardHolder?: string | undefined;
    pAN?: string | undefined;
    bankName?: string | undefined;
    familyName?: string | undefined;
    isBusinessCard?: boolean | undefined;
    isCVCRequired?: boolean | undefined;
    creditCardType?: CreditCardTypeEnum;
    creationTimeStamp?: moment.Moment | undefined;
    modificationTimeStamp?: moment.Moment | undefined;
    isThreeDS?: boolean | undefined;
    threeDS_HTML?: string | undefined;
    kPayTxnID?: string | undefined;
    additionalProperties?: { [key: string]: any; } | undefined;

    constructor(data?: ICardDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alias = _data["Alias"];
            this.cardID = _data["CardID"];
            this.cardHolder = _data["CardHolder"];
            this.pAN = _data["PAN"];
            this.bankName = _data["BankName"];
            this.familyName = _data["FamilyName"];
            this.isBusinessCard = _data["IsBusinessCard"];
            this.isCVCRequired = _data["IsCVCRequired"];
            this.creditCardType = _data["CreditCardType"];
            this.creationTimeStamp = _data["CreationTimeStamp"] ? moment(_data["CreationTimeStamp"].toString()) : <any>undefined;
            this.modificationTimeStamp = _data["ModificationTimeStamp"] ? moment(_data["ModificationTimeStamp"].toString()) : <any>undefined;
            this.isThreeDS = _data["IsThreeDS"];
            this.threeDS_HTML = _data["ThreeDS_HTML"];
            this.kPayTxnID = _data["KPayTxnID"];
            if (_data["AdditionalProperties"]) {
                this.additionalProperties = {} as any;
                for (let key in _data["AdditionalProperties"]) {
                    if (_data["AdditionalProperties"].hasOwnProperty(key))
                        (<any>this.additionalProperties)![key] = _data["AdditionalProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): CardDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CardDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alias"] = this.alias;
        data["CardID"] = this.cardID;
        data["CardHolder"] = this.cardHolder;
        data["PAN"] = this.pAN;
        data["BankName"] = this.bankName;
        data["FamilyName"] = this.familyName;
        data["IsBusinessCard"] = this.isBusinessCard;
        data["IsCVCRequired"] = this.isCVCRequired;
        data["CreditCardType"] = this.creditCardType;
        data["CreationTimeStamp"] = this.creationTimeStamp ? this.creationTimeStamp.toISOString() : <any>undefined;
        data["ModificationTimeStamp"] = this.modificationTimeStamp ? this.modificationTimeStamp.toISOString() : <any>undefined;
        data["IsThreeDS"] = this.isThreeDS;
        data["ThreeDS_HTML"] = this.threeDS_HTML;
        data["KPayTxnID"] = this.kPayTxnID;
        if (this.additionalProperties) {
            data["AdditionalProperties"] = {};
            for (let key in this.additionalProperties) {
                if (this.additionalProperties.hasOwnProperty(key))
                    (<any>data["AdditionalProperties"])[key] = this.additionalProperties[key];
            }
        }
        return data;
    }
}

export interface ICardDTO {
    alias?: string | undefined;
    cardID?: string | undefined;
    cardHolder?: string | undefined;
    pAN?: string | undefined;
    bankName?: string | undefined;
    familyName?: string | undefined;
    isBusinessCard?: boolean | undefined;
    isCVCRequired?: boolean | undefined;
    creditCardType?: CreditCardTypeEnum;
    creationTimeStamp?: moment.Moment | undefined;
    modificationTimeStamp?: moment.Moment | undefined;
    isThreeDS?: boolean | undefined;
    threeDS_HTML?: string | undefined;
    kPayTxnID?: string | undefined;
    additionalProperties?: { [key: string]: any; } | undefined;
}

export class Category implements ICategory {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    name?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isPublished?: boolean;
    mediaId?: number | undefined;
    media?: Media;
    parentId?: number | undefined;
    parent?: Category;
    yatirimimId?: number | undefined;
    readonly children?: Category[] | undefined;
    readonly productCategories?: ProductCategory[] | undefined;

    constructor(data?: ICategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.createdOn = _data["CreatedOn"] ? moment(_data["CreatedOn"].toString()) : <any>undefined;
            this.createdById = _data["CreatedById"];
            this.createdBy = _data["CreatedBy"] ? User.fromJS(_data["CreatedBy"]) : <any>undefined;
            this.updatedOn = _data["UpdatedOn"] ? moment(_data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedById = _data["UpdatedById"];
            this.updatedBy = _data["UpdatedBy"] ? User.fromJS(_data["UpdatedBy"]) : <any>undefined;
            this.deletedOn = _data["DeletedOn"] ? moment(_data["DeletedOn"].toString()) : <any>undefined;
            this.deletedById = _data["DeletedById"];
            this.deletedBy = _data["DeletedBy"] ? User.fromJS(_data["DeletedBy"]) : <any>undefined;
            this.isDeleted = _data["IsDeleted"];
            this.name = _data["Name"];
            this.description = _data["Description"];
            this.displayOrder = _data["DisplayOrder"];
            this.isPublished = _data["IsPublished"];
            this.mediaId = _data["MediaId"];
            this.media = _data["Media"] ? Media.fromJS(_data["Media"]) : <any>undefined;
            this.parentId = _data["ParentId"];
            this.parent = _data["Parent"] ? Category.fromJS(_data["Parent"]) : <any>undefined;
            this.yatirimimId = _data["YatirimimId"];
            if (Array.isArray(_data["Children"])) {
                (<any>this).children = [] as any;
                for (let item of _data["Children"])
                    (<any>this).children!.push(Category.fromJS(item));
            }
            if (Array.isArray(_data["ProductCategories"])) {
                (<any>this).productCategories = [] as any;
                for (let item of _data["ProductCategories"])
                    (<any>this).productCategories!.push(ProductCategory.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Category {
        data = typeof data === 'object' ? data : {};
        let result = new Category();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedById"] = this.createdById;
        data["CreatedBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["DeletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        data["DeletedById"] = this.deletedById;
        data["DeletedBy"] = this.deletedBy ? this.deletedBy.toJSON() : <any>undefined;
        data["IsDeleted"] = this.isDeleted;
        data["Name"] = this.name;
        data["Description"] = this.description;
        data["DisplayOrder"] = this.displayOrder;
        data["IsPublished"] = this.isPublished;
        data["MediaId"] = this.mediaId;
        data["Media"] = this.media ? this.media.toJSON() : <any>undefined;
        data["ParentId"] = this.parentId;
        data["Parent"] = this.parent ? this.parent.toJSON() : <any>undefined;
        data["YatirimimId"] = this.yatirimimId;
        if (Array.isArray(this.children)) {
            data["Children"] = [];
            for (let item of this.children)
                data["Children"].push(item.toJSON());
        }
        if (Array.isArray(this.productCategories)) {
            data["ProductCategories"] = [];
            for (let item of this.productCategories)
                data["ProductCategories"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICategory {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    name?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isPublished?: boolean;
    mediaId?: number | undefined;
    media?: Media;
    parentId?: number | undefined;
    parent?: Category;
    yatirimimId?: number | undefined;
    children?: Category[] | undefined;
    productCategories?: ProductCategory[] | undefined;
}

export class CCPaymentRequestLineDTO implements ICCPaymentRequestLineDTO {
    productName!: string;
    quantity?: number;
    unitName!: string;
    lineTotalTRY?: number;
    productCode?: string | undefined;
    promotionCode?: string | undefined;
    unitPriceTRY?: number | undefined;
    vATRate?: number | undefined;
    vATAmountTRY?: number | undefined;
    additionalProperties?: { [key: string]: any; } | undefined;

    constructor(data?: ICCPaymentRequestLineDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productName = _data["ProductName"];
            this.quantity = _data["Quantity"];
            this.unitName = _data["UnitName"];
            this.lineTotalTRY = _data["LineTotalTRY"];
            this.productCode = _data["ProductCode"];
            this.promotionCode = _data["PromotionCode"];
            this.unitPriceTRY = _data["UnitPriceTRY"];
            this.vATRate = _data["VATRate"];
            this.vATAmountTRY = _data["VATAmountTRY"];
            if (_data["AdditionalProperties"]) {
                this.additionalProperties = {} as any;
                for (let key in _data["AdditionalProperties"]) {
                    if (_data["AdditionalProperties"].hasOwnProperty(key))
                        (<any>this.additionalProperties)![key] = _data["AdditionalProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): CCPaymentRequestLineDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CCPaymentRequestLineDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ProductName"] = this.productName;
        data["Quantity"] = this.quantity;
        data["UnitName"] = this.unitName;
        data["LineTotalTRY"] = this.lineTotalTRY;
        data["ProductCode"] = this.productCode;
        data["PromotionCode"] = this.promotionCode;
        data["UnitPriceTRY"] = this.unitPriceTRY;
        data["VATRate"] = this.vATRate;
        data["VATAmountTRY"] = this.vATAmountTRY;
        if (this.additionalProperties) {
            data["AdditionalProperties"] = {};
            for (let key in this.additionalProperties) {
                if (this.additionalProperties.hasOwnProperty(key))
                    (<any>data["AdditionalProperties"])[key] = this.additionalProperties[key];
            }
        }
        return data;
    }
}

export interface ICCPaymentRequestLineDTO {
    productName: string;
    quantity?: number;
    unitName: string;
    lineTotalTRY?: number;
    productCode?: string | undefined;
    promotionCode?: string | undefined;
    unitPriceTRY?: number | undefined;
    vATRate?: number | undefined;
    vATAmountTRY?: number | undefined;
    additionalProperties?: { [key: string]: any; } | undefined;
}

export class ChannelType implements IChannelType {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;

    constructor(data?: IChannelType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.createdOn = _data["CreatedOn"] ? moment(_data["CreatedOn"].toString()) : <any>undefined;
            this.createdById = _data["CreatedById"];
            this.createdBy = _data["CreatedBy"] ? User.fromJS(_data["CreatedBy"]) : <any>undefined;
            this.updatedOn = _data["UpdatedOn"] ? moment(_data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedById = _data["UpdatedById"];
            this.updatedBy = _data["UpdatedBy"] ? User.fromJS(_data["UpdatedBy"]) : <any>undefined;
            this.deletedOn = _data["DeletedOn"] ? moment(_data["DeletedOn"].toString()) : <any>undefined;
            this.deletedById = _data["DeletedById"];
            this.deletedBy = _data["DeletedBy"] ? User.fromJS(_data["DeletedBy"]) : <any>undefined;
            this.isDeleted = _data["IsDeleted"];
            this.code = _data["Code"];
            this.description = _data["Description"];
            this.displayOrder = _data["DisplayOrder"];
            this.isActive = _data["IsActive"];
        }
    }

    static fromJS(data: any): ChannelType {
        data = typeof data === 'object' ? data : {};
        let result = new ChannelType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedById"] = this.createdById;
        data["CreatedBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["DeletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        data["DeletedById"] = this.deletedById;
        data["DeletedBy"] = this.deletedBy ? this.deletedBy.toJSON() : <any>undefined;
        data["IsDeleted"] = this.isDeleted;
        data["Code"] = this.code;
        data["Description"] = this.description;
        data["DisplayOrder"] = this.displayOrder;
        data["IsActive"] = this.isActive;
        return data;
    }
}

export interface IChannelType {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;
}

export class ChannelTypeModel implements IChannelTypeModel {
    id?: number;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;

    constructor(data?: IChannelTypeModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.code = _data["Code"];
            this.description = _data["Description"];
            this.displayOrder = _data["DisplayOrder"];
            this.isActive = _data["IsActive"];
        }
    }

    static fromJS(data: any): ChannelTypeModel {
        data = typeof data === 'object' ? data : {};
        let result = new ChannelTypeModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Code"] = this.code;
        data["Description"] = this.description;
        data["DisplayOrder"] = this.displayOrder;
        data["IsActive"] = this.isActive;
        return data;
    }
}

export interface IChannelTypeModel {
    id?: number;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;
}

export class Chf implements IChf {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IChf) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): Chf {
        data = typeof data === 'object' ? data : {};
        let result = new Chf();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IChf {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class CommissionModel implements ICommissionModel {
    id?: number;
    name?: string | undefined;
    symbolId?: number;
    symbol?: SymbolModel;
    commissionTypeId?: number;
    commissionType?: CommissionTypeModel;
    commissionRate?: number;
    commissionValue?: number;

    constructor(data?: ICommissionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.name = _data["Name"];
            this.symbolId = _data["SymbolId"];
            this.symbol = _data["Symbol"] ? SymbolModel.fromJS(_data["Symbol"]) : <any>undefined;
            this.commissionTypeId = _data["CommissionTypeId"];
            this.commissionType = _data["CommissionType"] ? CommissionTypeModel.fromJS(_data["CommissionType"]) : <any>undefined;
            this.commissionRate = _data["CommissionRate"];
            this.commissionValue = _data["CommissionValue"];
        }
    }

    static fromJS(data: any): CommissionModel {
        data = typeof data === 'object' ? data : {};
        let result = new CommissionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Name"] = this.name;
        data["SymbolId"] = this.symbolId;
        data["Symbol"] = this.symbol ? this.symbol.toJSON() : <any>undefined;
        data["CommissionTypeId"] = this.commissionTypeId;
        data["CommissionType"] = this.commissionType ? this.commissionType.toJSON() : <any>undefined;
        data["CommissionRate"] = this.commissionRate;
        data["CommissionValue"] = this.commissionValue;
        return data;
    }
}

export interface ICommissionModel {
    id?: number;
    name?: string | undefined;
    symbolId?: number;
    symbol?: SymbolModel;
    commissionTypeId?: number;
    commissionType?: CommissionTypeModel;
    commissionRate?: number;
    commissionValue?: number;
}

export class CommissionTypeModel implements ICommissionTypeModel {
    id?: number;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;

    constructor(data?: ICommissionTypeModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.code = _data["Code"];
            this.description = _data["Description"];
            this.displayOrder = _data["DisplayOrder"];
            this.isActive = _data["IsActive"];
        }
    }

    static fromJS(data: any): CommissionTypeModel {
        data = typeof data === 'object' ? data : {};
        let result = new CommissionTypeModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Code"] = this.code;
        data["Description"] = this.description;
        data["DisplayOrder"] = this.displayOrder;
        data["IsActive"] = this.isActive;
        return data;
    }
}

export interface ICommissionTypeModel {
    id?: number;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;
}

export class CompleDigitalOrderModel implements ICompleDigitalOrderModel {
    orderId?: number;
    paymentTypeId?: number;
    sourceAssetId?: number;
    targetAssetId?: number;

    constructor(data?: ICompleDigitalOrderModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.orderId = _data["OrderId"];
            this.paymentTypeId = _data["PaymentTypeId"];
            this.sourceAssetId = _data["SourceAssetId"];
            this.targetAssetId = _data["TargetAssetId"];
        }
    }

    static fromJS(data: any): CompleDigitalOrderModel {
        data = typeof data === 'object' ? data : {};
        let result = new CompleDigitalOrderModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["OrderId"] = this.orderId;
        data["PaymentTypeId"] = this.paymentTypeId;
        data["SourceAssetId"] = this.sourceAssetId;
        data["TargetAssetId"] = this.targetAssetId;
        return data;
    }
}

export interface ICompleDigitalOrderModel {
    orderId?: number;
    paymentTypeId?: number;
    sourceAssetId?: number;
    targetAssetId?: number;
}

export class ComplePhysicalOrderModel implements IComplePhysicalOrderModel {
    orderId?: number;
    paymnetTypeId?: number;
    sourceAssetId?: number;

    constructor(data?: IComplePhysicalOrderModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.orderId = _data["OrderId"];
            this.paymnetTypeId = _data["PaymnetTypeId"];
            this.sourceAssetId = _data["SourceAssetId"];
        }
    }

    static fromJS(data: any): ComplePhysicalOrderModel {
        data = typeof data === 'object' ? data : {};
        let result = new ComplePhysicalOrderModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["OrderId"] = this.orderId;
        data["PaymnetTypeId"] = this.paymnetTypeId;
        data["SourceAssetId"] = this.sourceAssetId;
        return data;
    }
}

export interface IComplePhysicalOrderModel {
    orderId?: number;
    paymnetTypeId?: number;
    sourceAssetId?: number;
}

export class ConstructorInfo implements IConstructorInfo {
    readonly name?: string | undefined;
    declaringType?: Type;
    reflectedType?: Type;
    module?: Module;
    readonly customAttributes?: CustomAttributeData[] | undefined;
    readonly isCollectible?: boolean;
    readonly metadataToken?: number;
    attributes?: MethodAttributes;
    methodImplementationFlags?: MethodImplAttributes;
    callingConvention?: CallingConventions;
    readonly isAbstract?: boolean;
    readonly isConstructor?: boolean;
    readonly isFinal?: boolean;
    readonly isHideBySig?: boolean;
    readonly isSpecialName?: boolean;
    readonly isStatic?: boolean;
    readonly isVirtual?: boolean;
    readonly isAssembly?: boolean;
    readonly isFamily?: boolean;
    readonly isFamilyAndAssembly?: boolean;
    readonly isFamilyOrAssembly?: boolean;
    readonly isPrivate?: boolean;
    readonly isPublic?: boolean;
    readonly isConstructedGenericMethod?: boolean;
    readonly isGenericMethod?: boolean;
    readonly isGenericMethodDefinition?: boolean;
    readonly containsGenericParameters?: boolean;
    methodHandle?: RuntimeMethodHandle;
    readonly isSecurityCritical?: boolean;
    readonly isSecuritySafeCritical?: boolean;
    readonly isSecurityTransparent?: boolean;
    memberType?: MemberTypes;

    constructor(data?: IConstructorInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).name = _data["Name"];
            this.declaringType = _data["DeclaringType"] ? Type.fromJS(_data["DeclaringType"]) : <any>undefined;
            this.reflectedType = _data["ReflectedType"] ? Type.fromJS(_data["ReflectedType"]) : <any>undefined;
            this.module = _data["Module"] ? Module.fromJS(_data["Module"]) : <any>undefined;
            if (Array.isArray(_data["CustomAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["CustomAttributes"])
                    (<any>this).customAttributes!.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).isCollectible = _data["IsCollectible"];
            (<any>this).metadataToken = _data["MetadataToken"];
            this.attributes = _data["Attributes"];
            this.methodImplementationFlags = _data["MethodImplementationFlags"];
            this.callingConvention = _data["CallingConvention"];
            (<any>this).isAbstract = _data["IsAbstract"];
            (<any>this).isConstructor = _data["IsConstructor"];
            (<any>this).isFinal = _data["IsFinal"];
            (<any>this).isHideBySig = _data["IsHideBySig"];
            (<any>this).isSpecialName = _data["IsSpecialName"];
            (<any>this).isStatic = _data["IsStatic"];
            (<any>this).isVirtual = _data["IsVirtual"];
            (<any>this).isAssembly = _data["IsAssembly"];
            (<any>this).isFamily = _data["IsFamily"];
            (<any>this).isFamilyAndAssembly = _data["IsFamilyAndAssembly"];
            (<any>this).isFamilyOrAssembly = _data["IsFamilyOrAssembly"];
            (<any>this).isPrivate = _data["IsPrivate"];
            (<any>this).isPublic = _data["IsPublic"];
            (<any>this).isConstructedGenericMethod = _data["IsConstructedGenericMethod"];
            (<any>this).isGenericMethod = _data["IsGenericMethod"];
            (<any>this).isGenericMethodDefinition = _data["IsGenericMethodDefinition"];
            (<any>this).containsGenericParameters = _data["ContainsGenericParameters"];
            this.methodHandle = _data["MethodHandle"] ? RuntimeMethodHandle.fromJS(_data["MethodHandle"]) : <any>undefined;
            (<any>this).isSecurityCritical = _data["IsSecurityCritical"];
            (<any>this).isSecuritySafeCritical = _data["IsSecuritySafeCritical"];
            (<any>this).isSecurityTransparent = _data["IsSecurityTransparent"];
            this.memberType = _data["MemberType"];
        }
    }

    static fromJS(data: any): ConstructorInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ConstructorInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Name"] = this.name;
        data["DeclaringType"] = this.declaringType ? this.declaringType.toJSON() : <any>undefined;
        data["ReflectedType"] = this.reflectedType ? this.reflectedType.toJSON() : <any>undefined;
        data["Module"] = this.module ? this.module.toJSON() : <any>undefined;
        if (Array.isArray(this.customAttributes)) {
            data["CustomAttributes"] = [];
            for (let item of this.customAttributes)
                data["CustomAttributes"].push(item.toJSON());
        }
        data["IsCollectible"] = this.isCollectible;
        data["MetadataToken"] = this.metadataToken;
        data["Attributes"] = this.attributes;
        data["MethodImplementationFlags"] = this.methodImplementationFlags;
        data["CallingConvention"] = this.callingConvention;
        data["IsAbstract"] = this.isAbstract;
        data["IsConstructor"] = this.isConstructor;
        data["IsFinal"] = this.isFinal;
        data["IsHideBySig"] = this.isHideBySig;
        data["IsSpecialName"] = this.isSpecialName;
        data["IsStatic"] = this.isStatic;
        data["IsVirtual"] = this.isVirtual;
        data["IsAssembly"] = this.isAssembly;
        data["IsFamily"] = this.isFamily;
        data["IsFamilyAndAssembly"] = this.isFamilyAndAssembly;
        data["IsFamilyOrAssembly"] = this.isFamilyOrAssembly;
        data["IsPrivate"] = this.isPrivate;
        data["IsPublic"] = this.isPublic;
        data["IsConstructedGenericMethod"] = this.isConstructedGenericMethod;
        data["IsGenericMethod"] = this.isGenericMethod;
        data["IsGenericMethodDefinition"] = this.isGenericMethodDefinition;
        data["ContainsGenericParameters"] = this.containsGenericParameters;
        data["MethodHandle"] = this.methodHandle ? this.methodHandle.toJSON() : <any>undefined;
        data["IsSecurityCritical"] = this.isSecurityCritical;
        data["IsSecuritySafeCritical"] = this.isSecuritySafeCritical;
        data["IsSecurityTransparent"] = this.isSecurityTransparent;
        data["MemberType"] = this.memberType;
        return data;
    }
}

export interface IConstructorInfo {
    name?: string | undefined;
    declaringType?: Type;
    reflectedType?: Type;
    module?: Module;
    customAttributes?: CustomAttributeData[] | undefined;
    isCollectible?: boolean;
    metadataToken?: number;
    attributes?: MethodAttributes;
    methodImplementationFlags?: MethodImplAttributes;
    callingConvention?: CallingConventions;
    isAbstract?: boolean;
    isConstructor?: boolean;
    isFinal?: boolean;
    isHideBySig?: boolean;
    isSpecialName?: boolean;
    isStatic?: boolean;
    isVirtual?: boolean;
    isAssembly?: boolean;
    isFamily?: boolean;
    isFamilyAndAssembly?: boolean;
    isFamilyOrAssembly?: boolean;
    isPrivate?: boolean;
    isPublic?: boolean;
    isConstructedGenericMethod?: boolean;
    isGenericMethod?: boolean;
    isGenericMethodDefinition?: boolean;
    containsGenericParameters?: boolean;
    methodHandle?: RuntimeMethodHandle;
    isSecurityCritical?: boolean;
    isSecuritySafeCritical?: boolean;
    isSecurityTransparent?: boolean;
    memberType?: MemberTypes;
}

export class ContactType implements IContactType {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;

    constructor(data?: IContactType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.createdOn = _data["CreatedOn"] ? moment(_data["CreatedOn"].toString()) : <any>undefined;
            this.createdById = _data["CreatedById"];
            this.createdBy = _data["CreatedBy"] ? User.fromJS(_data["CreatedBy"]) : <any>undefined;
            this.updatedOn = _data["UpdatedOn"] ? moment(_data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedById = _data["UpdatedById"];
            this.updatedBy = _data["UpdatedBy"] ? User.fromJS(_data["UpdatedBy"]) : <any>undefined;
            this.deletedOn = _data["DeletedOn"] ? moment(_data["DeletedOn"].toString()) : <any>undefined;
            this.deletedById = _data["DeletedById"];
            this.deletedBy = _data["DeletedBy"] ? User.fromJS(_data["DeletedBy"]) : <any>undefined;
            this.isDeleted = _data["IsDeleted"];
            this.code = _data["Code"];
            this.description = _data["Description"];
            this.displayOrder = _data["DisplayOrder"];
            this.isActive = _data["IsActive"];
        }
    }

    static fromJS(data: any): ContactType {
        data = typeof data === 'object' ? data : {};
        let result = new ContactType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedById"] = this.createdById;
        data["CreatedBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["DeletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        data["DeletedById"] = this.deletedById;
        data["DeletedBy"] = this.deletedBy ? this.deletedBy.toJSON() : <any>undefined;
        data["IsDeleted"] = this.isDeleted;
        data["Code"] = this.code;
        data["Description"] = this.description;
        data["DisplayOrder"] = this.displayOrder;
        data["IsActive"] = this.isActive;
        return data;
    }
}

export interface IContactType {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;
}

export class ContactTypeModel implements IContactTypeModel {
    id?: number;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;

    constructor(data?: IContactTypeModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.code = _data["Code"];
            this.description = _data["Description"];
            this.displayOrder = _data["DisplayOrder"];
            this.isActive = _data["IsActive"];
        }
    }

    static fromJS(data: any): ContactTypeModel {
        data = typeof data === 'object' ? data : {};
        let result = new ContactTypeModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Code"] = this.code;
        data["Description"] = this.description;
        data["DisplayOrder"] = this.displayOrder;
        data["IsActive"] = this.isActive;
        return data;
    }
}

export interface IContactTypeModel {
    id?: number;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;
}

export class Corporate implements ICorporate {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    name!: string;
    categoryId?: number;
    category?: CorporateCategory;
    phoneNumber?: string | undefined;
    email?: string | undefined;
    logoId?: number | undefined;
    logo?: Media;
    taxNo?: string | undefined;
    taxOffice?: string | undefined;
    description?: string | undefined;
    isActive?: boolean;
    customer?: Customer;

    constructor(data?: ICorporate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.isActive = true;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.createdOn = _data["CreatedOn"] ? moment(_data["CreatedOn"].toString()) : <any>undefined;
            this.createdById = _data["CreatedById"];
            this.createdBy = _data["CreatedBy"] ? User.fromJS(_data["CreatedBy"]) : <any>undefined;
            this.updatedOn = _data["UpdatedOn"] ? moment(_data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedById = _data["UpdatedById"];
            this.updatedBy = _data["UpdatedBy"] ? User.fromJS(_data["UpdatedBy"]) : <any>undefined;
            this.deletedOn = _data["DeletedOn"] ? moment(_data["DeletedOn"].toString()) : <any>undefined;
            this.deletedById = _data["DeletedById"];
            this.deletedBy = _data["DeletedBy"] ? User.fromJS(_data["DeletedBy"]) : <any>undefined;
            this.isDeleted = _data["IsDeleted"];
            this.name = _data["Name"];
            this.categoryId = _data["CategoryId"];
            this.category = _data["Category"] ? CorporateCategory.fromJS(_data["Category"]) : <any>undefined;
            this.phoneNumber = _data["PhoneNumber"];
            this.email = _data["Email"];
            this.logoId = _data["LogoId"];
            this.logo = _data["Logo"] ? Media.fromJS(_data["Logo"]) : <any>undefined;
            this.taxNo = _data["TaxNo"];
            this.taxOffice = _data["TaxOffice"];
            this.description = _data["Description"];
            this.isActive = _data["IsActive"] !== undefined ? _data["IsActive"] : true;
            this.customer = _data["Customer"] ? Customer.fromJS(_data["Customer"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Corporate {
        data = typeof data === 'object' ? data : {};
        let result = new Corporate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedById"] = this.createdById;
        data["CreatedBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["DeletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        data["DeletedById"] = this.deletedById;
        data["DeletedBy"] = this.deletedBy ? this.deletedBy.toJSON() : <any>undefined;
        data["IsDeleted"] = this.isDeleted;
        data["Name"] = this.name;
        data["CategoryId"] = this.categoryId;
        data["Category"] = this.category ? this.category.toJSON() : <any>undefined;
        data["PhoneNumber"] = this.phoneNumber;
        data["Email"] = this.email;
        data["LogoId"] = this.logoId;
        data["Logo"] = this.logo ? this.logo.toJSON() : <any>undefined;
        data["TaxNo"] = this.taxNo;
        data["TaxOffice"] = this.taxOffice;
        data["Description"] = this.description;
        data["IsActive"] = this.isActive;
        data["Customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICorporate {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    name: string;
    categoryId?: number;
    category?: CorporateCategory;
    phoneNumber?: string | undefined;
    email?: string | undefined;
    logoId?: number | undefined;
    logo?: Media;
    taxNo?: string | undefined;
    taxOffice?: string | undefined;
    description?: string | undefined;
    isActive?: boolean;
    customer?: Customer;
}

export class CorporateCategory implements ICorporateCategory {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;

    constructor(data?: ICorporateCategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.createdOn = _data["CreatedOn"] ? moment(_data["CreatedOn"].toString()) : <any>undefined;
            this.createdById = _data["CreatedById"];
            this.createdBy = _data["CreatedBy"] ? User.fromJS(_data["CreatedBy"]) : <any>undefined;
            this.updatedOn = _data["UpdatedOn"] ? moment(_data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedById = _data["UpdatedById"];
            this.updatedBy = _data["UpdatedBy"] ? User.fromJS(_data["UpdatedBy"]) : <any>undefined;
            this.deletedOn = _data["DeletedOn"] ? moment(_data["DeletedOn"].toString()) : <any>undefined;
            this.deletedById = _data["DeletedById"];
            this.deletedBy = _data["DeletedBy"] ? User.fromJS(_data["DeletedBy"]) : <any>undefined;
            this.isDeleted = _data["IsDeleted"];
            this.code = _data["Code"];
            this.description = _data["Description"];
            this.displayOrder = _data["DisplayOrder"];
            this.isActive = _data["IsActive"];
        }
    }

    static fromJS(data: any): CorporateCategory {
        data = typeof data === 'object' ? data : {};
        let result = new CorporateCategory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedById"] = this.createdById;
        data["CreatedBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["DeletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        data["DeletedById"] = this.deletedById;
        data["DeletedBy"] = this.deletedBy ? this.deletedBy.toJSON() : <any>undefined;
        data["IsDeleted"] = this.isDeleted;
        data["Code"] = this.code;
        data["Description"] = this.description;
        data["DisplayOrder"] = this.displayOrder;
        data["IsActive"] = this.isActive;
        return data;
    }
}

export interface ICorporateCategory {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;
}

export class CorporateCategoryModel implements ICorporateCategoryModel {
    id?: number;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;

    constructor(data?: ICorporateCategoryModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.code = _data["Code"];
            this.description = _data["Description"];
            this.displayOrder = _data["DisplayOrder"];
            this.isActive = _data["IsActive"];
        }
    }

    static fromJS(data: any): CorporateCategoryModel {
        data = typeof data === 'object' ? data : {};
        let result = new CorporateCategoryModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Code"] = this.code;
        data["Description"] = this.description;
        data["DisplayOrder"] = this.displayOrder;
        data["IsActive"] = this.isActive;
        return data;
    }
}

export interface ICorporateCategoryModel {
    id?: number;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;
}

export class CorporateModel implements ICorporateModel {
    id?: number;
    name?: string | undefined;
    categoryId?: number;
    category?: CorporateCategoryModel;
    customer?: CustomerModel;

    constructor(data?: ICorporateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.name = _data["Name"];
            this.categoryId = _data["CategoryId"];
            this.category = _data["Category"] ? CorporateCategoryModel.fromJS(_data["Category"]) : <any>undefined;
            this.customer = _data["Customer"] ? CustomerModel.fromJS(_data["Customer"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CorporateModel {
        data = typeof data === 'object' ? data : {};
        let result = new CorporateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Name"] = this.name;
        data["CategoryId"] = this.categoryId;
        data["Category"] = this.category ? this.category.toJSON() : <any>undefined;
        data["Customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICorporateModel {
    id?: number;
    name?: string | undefined;
    categoryId?: number;
    category?: CorporateCategoryModel;
    customer?: CustomerModel;
}

export class Country implements ICountry {
    id?: string | undefined;
    code!: string;
    name!: string;
    nationality?: string | undefined;

    constructor(data?: ICountry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.code = _data["Code"];
            this.name = _data["Name"];
            this.nationality = _data["Nationality"];
        }
    }

    static fromJS(data: any): Country {
        data = typeof data === 'object' ? data : {};
        let result = new Country();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Code"] = this.code;
        data["Name"] = this.name;
        data["Nationality"] = this.nationality;
        return data;
    }
}

export interface ICountry {
    id?: string | undefined;
    code: string;
    name: string;
    nationality?: string | undefined;
}

export class CountryModel implements ICountryModel {
    id?: number;
    code!: string;
    name!: string;
    nationality?: string | undefined;

    constructor(data?: ICountryModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.code = _data["Code"];
            this.name = _data["Name"];
            this.nationality = _data["Nationality"];
        }
    }

    static fromJS(data: any): CountryModel {
        data = typeof data === 'object' ? data : {};
        let result = new CountryModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Code"] = this.code;
        data["Name"] = this.name;
        data["Nationality"] = this.nationality;
        return data;
    }
}

export interface ICountryModel {
    id?: number;
    code: string;
    name: string;
    nationality?: string | undefined;
}

export class Coupon implements ICoupon {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    customerId?: number;
    customer?: Customer;
    code?: string | undefined;
    createDate?: moment.Moment;
    expireDate?: moment.Moment;

    constructor(data?: ICoupon) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.createdOn = _data["CreatedOn"] ? moment(_data["CreatedOn"].toString()) : <any>undefined;
            this.createdById = _data["CreatedById"];
            this.createdBy = _data["CreatedBy"] ? User.fromJS(_data["CreatedBy"]) : <any>undefined;
            this.updatedOn = _data["UpdatedOn"] ? moment(_data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedById = _data["UpdatedById"];
            this.updatedBy = _data["UpdatedBy"] ? User.fromJS(_data["UpdatedBy"]) : <any>undefined;
            this.deletedOn = _data["DeletedOn"] ? moment(_data["DeletedOn"].toString()) : <any>undefined;
            this.deletedById = _data["DeletedById"];
            this.deletedBy = _data["DeletedBy"] ? User.fromJS(_data["DeletedBy"]) : <any>undefined;
            this.isDeleted = _data["IsDeleted"];
            this.customerId = _data["CustomerId"];
            this.customer = _data["Customer"] ? Customer.fromJS(_data["Customer"]) : <any>undefined;
            this.code = _data["Code"];
            this.createDate = _data["CreateDate"] ? moment(_data["CreateDate"].toString()) : <any>undefined;
            this.expireDate = _data["ExpireDate"] ? moment(_data["ExpireDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Coupon {
        data = typeof data === 'object' ? data : {};
        let result = new Coupon();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedById"] = this.createdById;
        data["CreatedBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["DeletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        data["DeletedById"] = this.deletedById;
        data["DeletedBy"] = this.deletedBy ? this.deletedBy.toJSON() : <any>undefined;
        data["IsDeleted"] = this.isDeleted;
        data["CustomerId"] = this.customerId;
        data["Customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        data["Code"] = this.code;
        data["CreateDate"] = this.createDate ? this.createDate.toISOString() : <any>undefined;
        data["ExpireDate"] = this.expireDate ? this.expireDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface ICoupon {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    customerId?: number;
    customer?: Customer;
    code?: string | undefined;
    createDate?: moment.Moment;
    expireDate?: moment.Moment;
}

export class CreditCardMemberPaymentRequestModel implements ICreditCardMemberPaymentRequestModel {
    checkoutCode!: string;
    transactionAmountTRY?: number;
    merchantTransactionID!: string;
    creditCardInstallments?: number;
    useThreeDS?: boolean | undefined;
    creditCardCVC?: string | undefined;
    sellerMemberID?: string | undefined;
    paymentRequestKPayTxnID?: string | undefined;
    customerID?: string | undefined;
    vATAmountTRY?: number | undefined;
    usedPointsTRY?: number | undefined;
    campaignInfo?: string | undefined;
    merchantReceiptNo?: string | undefined;
    paymentNote?: string | undefined;
    paymentRequestLines?: CCPaymentRequestLineDTO[] | undefined;
    additionalProperties?: { [key: string]: any; } | undefined;
    storedCardId?: string | undefined;

    constructor(data?: ICreditCardMemberPaymentRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.checkoutCode = _data["CheckoutCode"];
            this.transactionAmountTRY = _data["TransactionAmountTRY"];
            this.merchantTransactionID = _data["MerchantTransactionID"];
            this.creditCardInstallments = _data["CreditCardInstallments"];
            this.useThreeDS = _data["UseThreeDS"];
            this.creditCardCVC = _data["CreditCardCVC"];
            this.sellerMemberID = _data["SellerMemberID"];
            this.paymentRequestKPayTxnID = _data["PaymentRequestKPayTxnID"];
            this.customerID = _data["CustomerID"];
            this.vATAmountTRY = _data["VATAmountTRY"];
            this.usedPointsTRY = _data["UsedPointsTRY"];
            this.campaignInfo = _data["CampaignInfo"];
            this.merchantReceiptNo = _data["MerchantReceiptNo"];
            this.paymentNote = _data["PaymentNote"];
            if (Array.isArray(_data["PaymentRequestLines"])) {
                this.paymentRequestLines = [] as any;
                for (let item of _data["PaymentRequestLines"])
                    this.paymentRequestLines!.push(CCPaymentRequestLineDTO.fromJS(item));
            }
            if (_data["AdditionalProperties"]) {
                this.additionalProperties = {} as any;
                for (let key in _data["AdditionalProperties"]) {
                    if (_data["AdditionalProperties"].hasOwnProperty(key))
                        (<any>this.additionalProperties)![key] = _data["AdditionalProperties"][key];
                }
            }
            this.storedCardId = _data["StoredCardId"];
        }
    }

    static fromJS(data: any): CreditCardMemberPaymentRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new CreditCardMemberPaymentRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["CheckoutCode"] = this.checkoutCode;
        data["TransactionAmountTRY"] = this.transactionAmountTRY;
        data["MerchantTransactionID"] = this.merchantTransactionID;
        data["CreditCardInstallments"] = this.creditCardInstallments;
        data["UseThreeDS"] = this.useThreeDS;
        data["CreditCardCVC"] = this.creditCardCVC;
        data["SellerMemberID"] = this.sellerMemberID;
        data["PaymentRequestKPayTxnID"] = this.paymentRequestKPayTxnID;
        data["CustomerID"] = this.customerID;
        data["VATAmountTRY"] = this.vATAmountTRY;
        data["UsedPointsTRY"] = this.usedPointsTRY;
        data["CampaignInfo"] = this.campaignInfo;
        data["MerchantReceiptNo"] = this.merchantReceiptNo;
        data["PaymentNote"] = this.paymentNote;
        if (Array.isArray(this.paymentRequestLines)) {
            data["PaymentRequestLines"] = [];
            for (let item of this.paymentRequestLines)
                data["PaymentRequestLines"].push(item.toJSON());
        }
        if (this.additionalProperties) {
            data["AdditionalProperties"] = {};
            for (let key in this.additionalProperties) {
                if (this.additionalProperties.hasOwnProperty(key))
                    (<any>data["AdditionalProperties"])[key] = this.additionalProperties[key];
            }
        }
        data["StoredCardId"] = this.storedCardId;
        return data;
    }
}

export interface ICreditCardMemberPaymentRequestModel {
    checkoutCode: string;
    transactionAmountTRY?: number;
    merchantTransactionID: string;
    creditCardInstallments?: number;
    useThreeDS?: boolean | undefined;
    creditCardCVC?: string | undefined;
    sellerMemberID?: string | undefined;
    paymentRequestKPayTxnID?: string | undefined;
    customerID?: string | undefined;
    vATAmountTRY?: number | undefined;
    usedPointsTRY?: number | undefined;
    campaignInfo?: string | undefined;
    merchantReceiptNo?: string | undefined;
    paymentNote?: string | undefined;
    paymentRequestLines?: CCPaymentRequestLineDTO[] | undefined;
    additionalProperties?: { [key: string]: any; } | undefined;
    storedCardId?: string | undefined;
}

export class CreditCardPaymentRequestModel implements ICreditCardPaymentRequestModel {
    memberID!: string;
    checkoutCode!: string;
    transactionAmountTRY?: number;
    merchantTransactionID!: string;
    creditCardHolder!: string;
    creditCardPAN!: string;
    creditCardExpiryMonth!: string;
    creditCardExpiryYear!: string;
    creditCardCVC!: string;
    creditCardInstallments?: number;
    useThreeDS?: boolean | undefined;
    sellerMemberID?: string | undefined;
    paymentRequestKPayTxnID?: string | undefined;
    vATAmountTRY?: number | undefined;
    usedPointsTRY?: number | undefined;
    campaignInfo?: string | undefined;
    merchantReceiptNo?: string | undefined;
    customerID?: string | undefined;
    paymentNote?: string | undefined;
    paymentRequestLines?: CCPaymentRequestLineDTO[] | undefined;
    additionalProperties?: { [key: string]: any; } | undefined;

    constructor(data?: ICreditCardPaymentRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberID = _data["MemberID"];
            this.checkoutCode = _data["CheckoutCode"];
            this.transactionAmountTRY = _data["TransactionAmountTRY"];
            this.merchantTransactionID = _data["MerchantTransactionID"];
            this.creditCardHolder = _data["CreditCardHolder"];
            this.creditCardPAN = _data["CreditCardPAN"];
            this.creditCardExpiryMonth = _data["CreditCardExpiryMonth"];
            this.creditCardExpiryYear = _data["CreditCardExpiryYear"];
            this.creditCardCVC = _data["CreditCardCVC"];
            this.creditCardInstallments = _data["CreditCardInstallments"];
            this.useThreeDS = _data["UseThreeDS"];
            this.sellerMemberID = _data["SellerMemberID"];
            this.paymentRequestKPayTxnID = _data["PaymentRequestKPayTxnID"];
            this.vATAmountTRY = _data["VATAmountTRY"];
            this.usedPointsTRY = _data["UsedPointsTRY"];
            this.campaignInfo = _data["CampaignInfo"];
            this.merchantReceiptNo = _data["MerchantReceiptNo"];
            this.customerID = _data["CustomerID"];
            this.paymentNote = _data["PaymentNote"];
            if (Array.isArray(_data["PaymentRequestLines"])) {
                this.paymentRequestLines = [] as any;
                for (let item of _data["PaymentRequestLines"])
                    this.paymentRequestLines!.push(CCPaymentRequestLineDTO.fromJS(item));
            }
            if (_data["AdditionalProperties"]) {
                this.additionalProperties = {} as any;
                for (let key in _data["AdditionalProperties"]) {
                    if (_data["AdditionalProperties"].hasOwnProperty(key))
                        (<any>this.additionalProperties)![key] = _data["AdditionalProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): CreditCardPaymentRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new CreditCardPaymentRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["MemberID"] = this.memberID;
        data["CheckoutCode"] = this.checkoutCode;
        data["TransactionAmountTRY"] = this.transactionAmountTRY;
        data["MerchantTransactionID"] = this.merchantTransactionID;
        data["CreditCardHolder"] = this.creditCardHolder;
        data["CreditCardPAN"] = this.creditCardPAN;
        data["CreditCardExpiryMonth"] = this.creditCardExpiryMonth;
        data["CreditCardExpiryYear"] = this.creditCardExpiryYear;
        data["CreditCardCVC"] = this.creditCardCVC;
        data["CreditCardInstallments"] = this.creditCardInstallments;
        data["UseThreeDS"] = this.useThreeDS;
        data["SellerMemberID"] = this.sellerMemberID;
        data["PaymentRequestKPayTxnID"] = this.paymentRequestKPayTxnID;
        data["VATAmountTRY"] = this.vATAmountTRY;
        data["UsedPointsTRY"] = this.usedPointsTRY;
        data["CampaignInfo"] = this.campaignInfo;
        data["MerchantReceiptNo"] = this.merchantReceiptNo;
        data["CustomerID"] = this.customerID;
        data["PaymentNote"] = this.paymentNote;
        if (Array.isArray(this.paymentRequestLines)) {
            data["PaymentRequestLines"] = [];
            for (let item of this.paymentRequestLines)
                data["PaymentRequestLines"].push(item.toJSON());
        }
        if (this.additionalProperties) {
            data["AdditionalProperties"] = {};
            for (let key in this.additionalProperties) {
                if (this.additionalProperties.hasOwnProperty(key))
                    (<any>data["AdditionalProperties"])[key] = this.additionalProperties[key];
            }
        }
        return data;
    }
}

export interface ICreditCardPaymentRequestModel {
    memberID: string;
    checkoutCode: string;
    transactionAmountTRY?: number;
    merchantTransactionID: string;
    creditCardHolder: string;
    creditCardPAN: string;
    creditCardExpiryMonth: string;
    creditCardExpiryYear: string;
    creditCardCVC: string;
    creditCardInstallments?: number;
    useThreeDS?: boolean | undefined;
    sellerMemberID?: string | undefined;
    paymentRequestKPayTxnID?: string | undefined;
    vATAmountTRY?: number | undefined;
    usedPointsTRY?: number | undefined;
    campaignInfo?: string | undefined;
    merchantReceiptNo?: string | undefined;
    customerID?: string | undefined;
    paymentNote?: string | undefined;
    paymentRequestLines?: CCPaymentRequestLineDTO[] | undefined;
    additionalProperties?: { [key: string]: any; } | undefined;
}

export class CreditCardPaymentSummaryModel implements ICreditCardPaymentSummaryModel {
    kPayTxnID?: string | undefined;
    paymentType?: PaymentTypeEnum;
    paymentStatus?: PaymentStatusEnum;
    requestTimeStamp?: moment.Moment | undefined;
    paymentTimeStamp?: moment.Moment | undefined;
    transactionAmountTRY?: number | undefined;
    paymentAmountTRY?: number | undefined;
    discountAmountTRY?: number | undefined;
    campaignInfo?: string | undefined;
    institutionName?: string | undefined;
    branchName?: string | undefined;
    hasError?: boolean | undefined;
    errorDescription?: string | undefined;
    isThreeDS?: boolean | undefined;
    threeDS_HTML?: string | undefined;
    paymentResultDescription?: string | undefined;
    additionalProperties?: { [key: string]: any; } | undefined;

    constructor(data?: ICreditCardPaymentSummaryModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.kPayTxnID = _data["KPayTxnID"];
            this.paymentType = _data["PaymentType"];
            this.paymentStatus = _data["PaymentStatus"];
            this.requestTimeStamp = _data["RequestTimeStamp"] ? moment(_data["RequestTimeStamp"].toString()) : <any>undefined;
            this.paymentTimeStamp = _data["PaymentTimeStamp"] ? moment(_data["PaymentTimeStamp"].toString()) : <any>undefined;
            this.transactionAmountTRY = _data["TransactionAmountTRY"];
            this.paymentAmountTRY = _data["PaymentAmountTRY"];
            this.discountAmountTRY = _data["DiscountAmountTRY"];
            this.campaignInfo = _data["CampaignInfo"];
            this.institutionName = _data["InstitutionName"];
            this.branchName = _data["BranchName"];
            this.hasError = _data["HasError"];
            this.errorDescription = _data["ErrorDescription"];
            this.isThreeDS = _data["IsThreeDS"];
            this.threeDS_HTML = _data["ThreeDS_HTML"];
            this.paymentResultDescription = _data["PaymentResultDescription"];
            if (_data["AdditionalProperties"]) {
                this.additionalProperties = {} as any;
                for (let key in _data["AdditionalProperties"]) {
                    if (_data["AdditionalProperties"].hasOwnProperty(key))
                        (<any>this.additionalProperties)![key] = _data["AdditionalProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): CreditCardPaymentSummaryModel {
        data = typeof data === 'object' ? data : {};
        let result = new CreditCardPaymentSummaryModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["KPayTxnID"] = this.kPayTxnID;
        data["PaymentType"] = this.paymentType;
        data["PaymentStatus"] = this.paymentStatus;
        data["RequestTimeStamp"] = this.requestTimeStamp ? this.requestTimeStamp.toISOString() : <any>undefined;
        data["PaymentTimeStamp"] = this.paymentTimeStamp ? this.paymentTimeStamp.toISOString() : <any>undefined;
        data["TransactionAmountTRY"] = this.transactionAmountTRY;
        data["PaymentAmountTRY"] = this.paymentAmountTRY;
        data["DiscountAmountTRY"] = this.discountAmountTRY;
        data["CampaignInfo"] = this.campaignInfo;
        data["InstitutionName"] = this.institutionName;
        data["BranchName"] = this.branchName;
        data["HasError"] = this.hasError;
        data["ErrorDescription"] = this.errorDescription;
        data["IsThreeDS"] = this.isThreeDS;
        data["ThreeDS_HTML"] = this.threeDS_HTML;
        data["PaymentResultDescription"] = this.paymentResultDescription;
        if (this.additionalProperties) {
            data["AdditionalProperties"] = {};
            for (let key in this.additionalProperties) {
                if (this.additionalProperties.hasOwnProperty(key))
                    (<any>data["AdditionalProperties"])[key] = this.additionalProperties[key];
            }
        }
        return data;
    }
}

export interface ICreditCardPaymentSummaryModel {
    kPayTxnID?: string | undefined;
    paymentType?: PaymentTypeEnum;
    paymentStatus?: PaymentStatusEnum;
    requestTimeStamp?: moment.Moment | undefined;
    paymentTimeStamp?: moment.Moment | undefined;
    transactionAmountTRY?: number | undefined;
    paymentAmountTRY?: number | undefined;
    discountAmountTRY?: number | undefined;
    campaignInfo?: string | undefined;
    institutionName?: string | undefined;
    branchName?: string | undefined;
    hasError?: boolean | undefined;
    errorDescription?: string | undefined;
    isThreeDS?: boolean | undefined;
    threeDS_HTML?: string | undefined;
    paymentResultDescription?: string | undefined;
    additionalProperties?: { [key: string]: any; } | undefined;
}

export enum CreditCardTypeEnum {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
}

export class CustomAttributeData implements ICustomAttributeData {
    attributeType?: Type;
    constructor_?: ConstructorInfo;
    readonly constructorArguments?: CustomAttributeTypedArgument[] | undefined;
    readonly namedArguments?: CustomAttributeNamedArgument[] | undefined;

    constructor(data?: ICustomAttributeData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.attributeType = _data["AttributeType"] ? Type.fromJS(_data["AttributeType"]) : <any>undefined;
            this.constructor_ = _data["Constructor"] ? ConstructorInfo.fromJS(_data["Constructor"]) : <any>undefined;
            if (Array.isArray(_data["ConstructorArguments"])) {
                (<any>this).constructorArguments = [] as any;
                for (let item of _data["ConstructorArguments"])
                    (<any>this).constructorArguments!.push(CustomAttributeTypedArgument.fromJS(item));
            }
            if (Array.isArray(_data["NamedArguments"])) {
                (<any>this).namedArguments = [] as any;
                for (let item of _data["NamedArguments"])
                    (<any>this).namedArguments!.push(CustomAttributeNamedArgument.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CustomAttributeData {
        data = typeof data === 'object' ? data : {};
        let result = new CustomAttributeData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["AttributeType"] = this.attributeType ? this.attributeType.toJSON() : <any>undefined;
        data["Constructor"] = this.constructor_ ? this.constructor_.toJSON() : <any>undefined;
        if (Array.isArray(this.constructorArguments)) {
            data["ConstructorArguments"] = [];
            for (let item of this.constructorArguments)
                data["ConstructorArguments"].push(item.toJSON());
        }
        if (Array.isArray(this.namedArguments)) {
            data["NamedArguments"] = [];
            for (let item of this.namedArguments)
                data["NamedArguments"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICustomAttributeData {
    attributeType?: Type;
    constructor_?: ConstructorInfo;
    constructorArguments?: CustomAttributeTypedArgument[] | undefined;
    namedArguments?: CustomAttributeNamedArgument[] | undefined;
}

export class CustomAttributeNamedArgument implements ICustomAttributeNamedArgument {
    memberInfo?: MemberInfo;
    typedValue?: CustomAttributeTypedArgument;
    readonly memberName?: string | undefined;
    readonly isField?: boolean;

    constructor(data?: ICustomAttributeNamedArgument) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberInfo = _data["MemberInfo"] ? MemberInfo.fromJS(_data["MemberInfo"]) : <any>undefined;
            this.typedValue = _data["TypedValue"] ? CustomAttributeTypedArgument.fromJS(_data["TypedValue"]) : <any>undefined;
            (<any>this).memberName = _data["MemberName"];
            (<any>this).isField = _data["IsField"];
        }
    }

    static fromJS(data: any): CustomAttributeNamedArgument {
        data = typeof data === 'object' ? data : {};
        let result = new CustomAttributeNamedArgument();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["MemberInfo"] = this.memberInfo ? this.memberInfo.toJSON() : <any>undefined;
        data["TypedValue"] = this.typedValue ? this.typedValue.toJSON() : <any>undefined;
        data["MemberName"] = this.memberName;
        data["IsField"] = this.isField;
        return data;
    }
}

export interface ICustomAttributeNamedArgument {
    memberInfo?: MemberInfo;
    typedValue?: CustomAttributeTypedArgument;
    memberName?: string | undefined;
    isField?: boolean;
}

export class CustomAttributeTypedArgument implements ICustomAttributeTypedArgument {
    argumentType?: Type;
    readonly value?: any | undefined;

    constructor(data?: ICustomAttributeTypedArgument) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.argumentType = _data["ArgumentType"] ? Type.fromJS(_data["ArgumentType"]) : <any>undefined;
            (<any>this).value = _data["Value"];
        }
    }

    static fromJS(data: any): CustomAttributeTypedArgument {
        data = typeof data === 'object' ? data : {};
        let result = new CustomAttributeTypedArgument();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ArgumentType"] = this.argumentType ? this.argumentType.toJSON() : <any>undefined;
        data["Value"] = this.value;
        return data;
    }
}

export interface ICustomAttributeTypedArgument {
    argumentType?: Type;
    value?: any | undefined;
}

export class Customer implements ICustomer {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    customerType?: CustomerType;
    retail?: Retail;
    corporate?: Corporate;
    store?: Store;
    channelTypeId?: number | undefined;
    channelType?: ChannelType;
    groupId?: number | undefined;
    group?: Group;
    users?: User[] | undefined;
    assets?: Asset[] | undefined;
    bonuses?: Bonus[] | undefined;
    coupons?: Coupon[] | undefined;
    transactions?: Transaction[] | undefined;
    customerAddresses?: CustomerAddress[] | undefined;
    customerBankAccounts?: CustomerBankAccount[] | undefined;
    customerContacts?: CustomerContact[] | undefined;
    customerDocuments?: CustomerDocument[] | undefined;

    constructor(data?: ICustomer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.createdOn = _data["CreatedOn"] ? moment(_data["CreatedOn"].toString()) : <any>undefined;
            this.createdById = _data["CreatedById"];
            this.createdBy = _data["CreatedBy"] ? User.fromJS(_data["CreatedBy"]) : <any>undefined;
            this.updatedOn = _data["UpdatedOn"] ? moment(_data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedById = _data["UpdatedById"];
            this.updatedBy = _data["UpdatedBy"] ? User.fromJS(_data["UpdatedBy"]) : <any>undefined;
            this.deletedOn = _data["DeletedOn"] ? moment(_data["DeletedOn"].toString()) : <any>undefined;
            this.deletedById = _data["DeletedById"];
            this.deletedBy = _data["DeletedBy"] ? User.fromJS(_data["DeletedBy"]) : <any>undefined;
            this.isDeleted = _data["IsDeleted"];
            this.customerType = _data["CustomerType"];
            this.retail = _data["Retail"] ? Retail.fromJS(_data["Retail"]) : <any>undefined;
            this.corporate = _data["Corporate"] ? Corporate.fromJS(_data["Corporate"]) : <any>undefined;
            this.store = _data["Store"] ? Store.fromJS(_data["Store"]) : <any>undefined;
            this.channelTypeId = _data["ChannelTypeId"];
            this.channelType = _data["ChannelType"] ? ChannelType.fromJS(_data["ChannelType"]) : <any>undefined;
            this.groupId = _data["GroupId"];
            this.group = _data["Group"] ? Group.fromJS(_data["Group"]) : <any>undefined;
            if (Array.isArray(_data["Users"])) {
                this.users = [] as any;
                for (let item of _data["Users"])
                    this.users!.push(User.fromJS(item));
            }
            if (Array.isArray(_data["Assets"])) {
                this.assets = [] as any;
                for (let item of _data["Assets"])
                    this.assets!.push(Asset.fromJS(item));
            }
            if (Array.isArray(_data["Bonuses"])) {
                this.bonuses = [] as any;
                for (let item of _data["Bonuses"])
                    this.bonuses!.push(Bonus.fromJS(item));
            }
            if (Array.isArray(_data["Coupons"])) {
                this.coupons = [] as any;
                for (let item of _data["Coupons"])
                    this.coupons!.push(Coupon.fromJS(item));
            }
            if (Array.isArray(_data["Transactions"])) {
                this.transactions = [] as any;
                for (let item of _data["Transactions"])
                    this.transactions!.push(Transaction.fromJS(item));
            }
            if (Array.isArray(_data["CustomerAddresses"])) {
                this.customerAddresses = [] as any;
                for (let item of _data["CustomerAddresses"])
                    this.customerAddresses!.push(CustomerAddress.fromJS(item));
            }
            if (Array.isArray(_data["CustomerBankAccounts"])) {
                this.customerBankAccounts = [] as any;
                for (let item of _data["CustomerBankAccounts"])
                    this.customerBankAccounts!.push(CustomerBankAccount.fromJS(item));
            }
            if (Array.isArray(_data["CustomerContacts"])) {
                this.customerContacts = [] as any;
                for (let item of _data["CustomerContacts"])
                    this.customerContacts!.push(CustomerContact.fromJS(item));
            }
            if (Array.isArray(_data["CustomerDocuments"])) {
                this.customerDocuments = [] as any;
                for (let item of _data["CustomerDocuments"])
                    this.customerDocuments!.push(CustomerDocument.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Customer {
        data = typeof data === 'object' ? data : {};
        let result = new Customer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedById"] = this.createdById;
        data["CreatedBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["DeletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        data["DeletedById"] = this.deletedById;
        data["DeletedBy"] = this.deletedBy ? this.deletedBy.toJSON() : <any>undefined;
        data["IsDeleted"] = this.isDeleted;
        data["CustomerType"] = this.customerType;
        data["Retail"] = this.retail ? this.retail.toJSON() : <any>undefined;
        data["Corporate"] = this.corporate ? this.corporate.toJSON() : <any>undefined;
        data["Store"] = this.store ? this.store.toJSON() : <any>undefined;
        data["ChannelTypeId"] = this.channelTypeId;
        data["ChannelType"] = this.channelType ? this.channelType.toJSON() : <any>undefined;
        data["GroupId"] = this.groupId;
        data["Group"] = this.group ? this.group.toJSON() : <any>undefined;
        if (Array.isArray(this.users)) {
            data["Users"] = [];
            for (let item of this.users)
                data["Users"].push(item.toJSON());
        }
        if (Array.isArray(this.assets)) {
            data["Assets"] = [];
            for (let item of this.assets)
                data["Assets"].push(item.toJSON());
        }
        if (Array.isArray(this.bonuses)) {
            data["Bonuses"] = [];
            for (let item of this.bonuses)
                data["Bonuses"].push(item.toJSON());
        }
        if (Array.isArray(this.coupons)) {
            data["Coupons"] = [];
            for (let item of this.coupons)
                data["Coupons"].push(item.toJSON());
        }
        if (Array.isArray(this.transactions)) {
            data["Transactions"] = [];
            for (let item of this.transactions)
                data["Transactions"].push(item.toJSON());
        }
        if (Array.isArray(this.customerAddresses)) {
            data["CustomerAddresses"] = [];
            for (let item of this.customerAddresses)
                data["CustomerAddresses"].push(item.toJSON());
        }
        if (Array.isArray(this.customerBankAccounts)) {
            data["CustomerBankAccounts"] = [];
            for (let item of this.customerBankAccounts)
                data["CustomerBankAccounts"].push(item.toJSON());
        }
        if (Array.isArray(this.customerContacts)) {
            data["CustomerContacts"] = [];
            for (let item of this.customerContacts)
                data["CustomerContacts"].push(item.toJSON());
        }
        if (Array.isArray(this.customerDocuments)) {
            data["CustomerDocuments"] = [];
            for (let item of this.customerDocuments)
                data["CustomerDocuments"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICustomer {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    customerType?: CustomerType;
    retail?: Retail;
    corporate?: Corporate;
    store?: Store;
    channelTypeId?: number | undefined;
    channelType?: ChannelType;
    groupId?: number | undefined;
    group?: Group;
    users?: User[] | undefined;
    assets?: Asset[] | undefined;
    bonuses?: Bonus[] | undefined;
    coupons?: Coupon[] | undefined;
    transactions?: Transaction[] | undefined;
    customerAddresses?: CustomerAddress[] | undefined;
    customerBankAccounts?: CustomerBankAccount[] | undefined;
    customerContacts?: CustomerContact[] | undefined;
    customerDocuments?: CustomerDocument[] | undefined;
}

export class CustomerAddress implements ICustomerAddress {
    id?: number;
    customerId?: number;
    customer?: Customer;
    addressId?: number;
    address?: Address;
    lastUsedOn?: moment.Moment | undefined;
    isPrimary?: boolean;

    constructor(data?: ICustomerAddress) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.customerId = _data["CustomerId"];
            this.customer = _data["Customer"] ? Customer.fromJS(_data["Customer"]) : <any>undefined;
            this.addressId = _data["AddressId"];
            this.address = _data["Address"] ? Address.fromJS(_data["Address"]) : <any>undefined;
            this.lastUsedOn = _data["LastUsedOn"] ? moment(_data["LastUsedOn"].toString()) : <any>undefined;
            this.isPrimary = _data["IsPrimary"];
        }
    }

    static fromJS(data: any): CustomerAddress {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerAddress();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CustomerId"] = this.customerId;
        data["Customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        data["AddressId"] = this.addressId;
        data["Address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["LastUsedOn"] = this.lastUsedOn ? this.lastUsedOn.toISOString() : <any>undefined;
        data["IsPrimary"] = this.isPrimary;
        return data;
    }
}

export interface ICustomerAddress {
    id?: number;
    customerId?: number;
    customer?: Customer;
    addressId?: number;
    address?: Address;
    lastUsedOn?: moment.Moment | undefined;
    isPrimary?: boolean;
}

export class CustomerBankAccount implements ICustomerBankAccount {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    customerId?: number;
    customer?: Customer;
    symbolId?: number;
    symbol?: Symbol;
    bankId?: number;
    bank?: Bank;
    name?: string | undefined;
    accountNo?: string | undefined;

    constructor(data?: ICustomerBankAccount) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.createdOn = _data["CreatedOn"] ? moment(_data["CreatedOn"].toString()) : <any>undefined;
            this.createdById = _data["CreatedById"];
            this.createdBy = _data["CreatedBy"] ? User.fromJS(_data["CreatedBy"]) : <any>undefined;
            this.updatedOn = _data["UpdatedOn"] ? moment(_data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedById = _data["UpdatedById"];
            this.updatedBy = _data["UpdatedBy"] ? User.fromJS(_data["UpdatedBy"]) : <any>undefined;
            this.deletedOn = _data["DeletedOn"] ? moment(_data["DeletedOn"].toString()) : <any>undefined;
            this.deletedById = _data["DeletedById"];
            this.deletedBy = _data["DeletedBy"] ? User.fromJS(_data["DeletedBy"]) : <any>undefined;
            this.isDeleted = _data["IsDeleted"];
            this.customerId = _data["CustomerId"];
            this.customer = _data["Customer"] ? Customer.fromJS(_data["Customer"]) : <any>undefined;
            this.symbolId = _data["SymbolId"];
            this.symbol = _data["Symbol"] ? Symbol.fromJS(_data["Symbol"]) : <any>undefined;
            this.bankId = _data["BankId"];
            this.bank = _data["Bank"] ? Bank.fromJS(_data["Bank"]) : <any>undefined;
            this.name = _data["Name"];
            this.accountNo = _data["AccountNo"];
        }
    }

    static fromJS(data: any): CustomerBankAccount {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerBankAccount();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedById"] = this.createdById;
        data["CreatedBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["DeletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        data["DeletedById"] = this.deletedById;
        data["DeletedBy"] = this.deletedBy ? this.deletedBy.toJSON() : <any>undefined;
        data["IsDeleted"] = this.isDeleted;
        data["CustomerId"] = this.customerId;
        data["Customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        data["SymbolId"] = this.symbolId;
        data["Symbol"] = this.symbol ? this.symbol.toJSON() : <any>undefined;
        data["BankId"] = this.bankId;
        data["Bank"] = this.bank ? this.bank.toJSON() : <any>undefined;
        data["Name"] = this.name;
        data["AccountNo"] = this.accountNo;
        return data;
    }
}

export interface ICustomerBankAccount {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    customerId?: number;
    customer?: Customer;
    symbolId?: number;
    symbol?: Symbol;
    bankId?: number;
    bank?: Bank;
    name?: string | undefined;
    accountNo?: string | undefined;
}

export class CustomerBankAccountModel implements ICustomerBankAccountModel {
    customerId?: number;
    customer?: CustomerModel;
    symbolId?: number;
    symbol?: SymbolModel;
    bankId?: number;
    bank?: BankModel;
    name?: string | undefined;
    accountNo?: string | undefined;

    constructor(data?: ICustomerBankAccountModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.customerId = _data["CustomerId"];
            this.customer = _data["Customer"] ? CustomerModel.fromJS(_data["Customer"]) : <any>undefined;
            this.symbolId = _data["SymbolId"];
            this.symbol = _data["Symbol"] ? SymbolModel.fromJS(_data["Symbol"]) : <any>undefined;
            this.bankId = _data["BankId"];
            this.bank = _data["Bank"] ? BankModel.fromJS(_data["Bank"]) : <any>undefined;
            this.name = _data["Name"];
            this.accountNo = _data["AccountNo"];
        }
    }

    static fromJS(data: any): CustomerBankAccountModel {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerBankAccountModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["CustomerId"] = this.customerId;
        data["Customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        data["SymbolId"] = this.symbolId;
        data["Symbol"] = this.symbol ? this.symbol.toJSON() : <any>undefined;
        data["BankId"] = this.bankId;
        data["Bank"] = this.bank ? this.bank.toJSON() : <any>undefined;
        data["Name"] = this.name;
        data["AccountNo"] = this.accountNo;
        return data;
    }
}

export interface ICustomerBankAccountModel {
    customerId?: number;
    customer?: CustomerModel;
    symbolId?: number;
    symbol?: SymbolModel;
    bankId?: number;
    bank?: BankModel;
    name?: string | undefined;
    accountNo?: string | undefined;
}

export class CustomerContact implements ICustomerContact {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    customerId?: number;
    customer?: Customer;
    contactTypeId?: number;
    contactType?: ContactType;
    contactValue?: string | undefined;
    isPrimary?: boolean;

    constructor(data?: ICustomerContact) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.createdOn = _data["CreatedOn"] ? moment(_data["CreatedOn"].toString()) : <any>undefined;
            this.createdById = _data["CreatedById"];
            this.createdBy = _data["CreatedBy"] ? User.fromJS(_data["CreatedBy"]) : <any>undefined;
            this.updatedOn = _data["UpdatedOn"] ? moment(_data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedById = _data["UpdatedById"];
            this.updatedBy = _data["UpdatedBy"] ? User.fromJS(_data["UpdatedBy"]) : <any>undefined;
            this.deletedOn = _data["DeletedOn"] ? moment(_data["DeletedOn"].toString()) : <any>undefined;
            this.deletedById = _data["DeletedById"];
            this.deletedBy = _data["DeletedBy"] ? User.fromJS(_data["DeletedBy"]) : <any>undefined;
            this.isDeleted = _data["IsDeleted"];
            this.customerId = _data["CustomerId"];
            this.customer = _data["Customer"] ? Customer.fromJS(_data["Customer"]) : <any>undefined;
            this.contactTypeId = _data["ContactTypeId"];
            this.contactType = _data["ContactType"] ? ContactType.fromJS(_data["ContactType"]) : <any>undefined;
            this.contactValue = _data["ContactValue"];
            this.isPrimary = _data["IsPrimary"];
        }
    }

    static fromJS(data: any): CustomerContact {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerContact();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedById"] = this.createdById;
        data["CreatedBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["DeletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        data["DeletedById"] = this.deletedById;
        data["DeletedBy"] = this.deletedBy ? this.deletedBy.toJSON() : <any>undefined;
        data["IsDeleted"] = this.isDeleted;
        data["CustomerId"] = this.customerId;
        data["Customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        data["ContactTypeId"] = this.contactTypeId;
        data["ContactType"] = this.contactType ? this.contactType.toJSON() : <any>undefined;
        data["ContactValue"] = this.contactValue;
        data["IsPrimary"] = this.isPrimary;
        return data;
    }
}

export interface ICustomerContact {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    customerId?: number;
    customer?: Customer;
    contactTypeId?: number;
    contactType?: ContactType;
    contactValue?: string | undefined;
    isPrimary?: boolean;
}

export class CustomerDocument implements ICustomerDocument {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    customerId?: number;
    customer?: Customer;
    documentTypeId?: number;
    documentType?: DocumentType;
    medias?: CustomerDocumentMedia[] | undefined;
    countryId?: string | undefined;
    country?: Country;
    documentNo?: string | undefined;
    serialNo?: string | undefined;
    dateOfIssue?: moment.Moment;
    dateOfExpiry?: moment.Moment;
    isVerified?: boolean;
    verifiedOn?: moment.Moment;

    constructor(data?: ICustomerDocument) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.createdOn = _data["CreatedOn"] ? moment(_data["CreatedOn"].toString()) : <any>undefined;
            this.createdById = _data["CreatedById"];
            this.createdBy = _data["CreatedBy"] ? User.fromJS(_data["CreatedBy"]) : <any>undefined;
            this.updatedOn = _data["UpdatedOn"] ? moment(_data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedById = _data["UpdatedById"];
            this.updatedBy = _data["UpdatedBy"] ? User.fromJS(_data["UpdatedBy"]) : <any>undefined;
            this.deletedOn = _data["DeletedOn"] ? moment(_data["DeletedOn"].toString()) : <any>undefined;
            this.deletedById = _data["DeletedById"];
            this.deletedBy = _data["DeletedBy"] ? User.fromJS(_data["DeletedBy"]) : <any>undefined;
            this.isDeleted = _data["IsDeleted"];
            this.customerId = _data["CustomerId"];
            this.customer = _data["Customer"] ? Customer.fromJS(_data["Customer"]) : <any>undefined;
            this.documentTypeId = _data["DocumentTypeId"];
            this.documentType = _data["DocumentType"] ? DocumentType.fromJS(_data["DocumentType"]) : <any>undefined;
            if (Array.isArray(_data["Medias"])) {
                this.medias = [] as any;
                for (let item of _data["Medias"])
                    this.medias!.push(CustomerDocumentMedia.fromJS(item));
            }
            this.countryId = _data["CountryId"];
            this.country = _data["Country"] ? Country.fromJS(_data["Country"]) : <any>undefined;
            this.documentNo = _data["DocumentNo"];
            this.serialNo = _data["SerialNo"];
            this.dateOfIssue = _data["DateOfIssue"] ? moment(_data["DateOfIssue"].toString()) : <any>undefined;
            this.dateOfExpiry = _data["DateOfExpiry"] ? moment(_data["DateOfExpiry"].toString()) : <any>undefined;
            this.isVerified = _data["IsVerified"];
            this.verifiedOn = _data["VerifiedOn"] ? moment(_data["VerifiedOn"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CustomerDocument {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerDocument();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedById"] = this.createdById;
        data["CreatedBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["DeletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        data["DeletedById"] = this.deletedById;
        data["DeletedBy"] = this.deletedBy ? this.deletedBy.toJSON() : <any>undefined;
        data["IsDeleted"] = this.isDeleted;
        data["CustomerId"] = this.customerId;
        data["Customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        data["DocumentTypeId"] = this.documentTypeId;
        data["DocumentType"] = this.documentType ? this.documentType.toJSON() : <any>undefined;
        if (Array.isArray(this.medias)) {
            data["Medias"] = [];
            for (let item of this.medias)
                data["Medias"].push(item.toJSON());
        }
        data["CountryId"] = this.countryId;
        data["Country"] = this.country ? this.country.toJSON() : <any>undefined;
        data["DocumentNo"] = this.documentNo;
        data["SerialNo"] = this.serialNo;
        data["DateOfIssue"] = this.dateOfIssue ? this.dateOfIssue.toISOString() : <any>undefined;
        data["DateOfExpiry"] = this.dateOfExpiry ? this.dateOfExpiry.toISOString() : <any>undefined;
        data["IsVerified"] = this.isVerified;
        data["VerifiedOn"] = this.verifiedOn ? this.verifiedOn.toISOString() : <any>undefined;
        return data;
    }
}

export interface ICustomerDocument {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    customerId?: number;
    customer?: Customer;
    documentTypeId?: number;
    documentType?: DocumentType;
    medias?: CustomerDocumentMedia[] | undefined;
    countryId?: string | undefined;
    country?: Country;
    documentNo?: string | undefined;
    serialNo?: string | undefined;
    dateOfIssue?: moment.Moment;
    dateOfExpiry?: moment.Moment;
    isVerified?: boolean;
    verifiedOn?: moment.Moment;
}

export class CustomerDocumentMedia implements ICustomerDocumentMedia {
    id?: number;
    customerDocumentId?: number;
    customerDocument?: CustomerDocument;
    mediaId?: number;
    media?: Media;
    scanTypeId?: number;
    scanType?: ScanType;

    constructor(data?: ICustomerDocumentMedia) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.customerDocumentId = _data["CustomerDocumentId"];
            this.customerDocument = _data["CustomerDocument"] ? CustomerDocument.fromJS(_data["CustomerDocument"]) : <any>undefined;
            this.mediaId = _data["MediaId"];
            this.media = _data["Media"] ? Media.fromJS(_data["Media"]) : <any>undefined;
            this.scanTypeId = _data["ScanTypeId"];
            this.scanType = _data["ScanType"] ? ScanType.fromJS(_data["ScanType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CustomerDocumentMedia {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerDocumentMedia();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CustomerDocumentId"] = this.customerDocumentId;
        data["CustomerDocument"] = this.customerDocument ? this.customerDocument.toJSON() : <any>undefined;
        data["MediaId"] = this.mediaId;
        data["Media"] = this.media ? this.media.toJSON() : <any>undefined;
        data["ScanTypeId"] = this.scanTypeId;
        data["ScanType"] = this.scanType ? this.scanType.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICustomerDocumentMedia {
    id?: number;
    customerDocumentId?: number;
    customerDocument?: CustomerDocument;
    mediaId?: number;
    media?: Media;
    scanTypeId?: number;
    scanType?: ScanType;
}

export class CustomerModel implements ICustomerModel {
    customerType?: CustomerType;
    channelTypeId?: number | undefined;

    constructor(data?: ICustomerModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.customerType = _data["CustomerType"];
            this.channelTypeId = _data["ChannelTypeId"];
        }
    }

    static fromJS(data: any): CustomerModel {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["CustomerType"] = this.customerType;
        data["ChannelTypeId"] = this.channelTypeId;
        return data;
    }
}

export interface ICustomerModel {
    customerType?: CustomerType;
    channelTypeId?: number | undefined;
}

export enum CustomerType {
    _1 = 1,
    _2 = 2,
}

export class Cyp implements ICyp {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: ICyp) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): Cyp {
        data = typeof data === 'object' ? data : {};
        let result = new Cyp();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface ICyp {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class Data implements IData {
    day?: Day;

    constructor(data?: IData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.day = _data["Day"] ? Day.fromJS(_data["Day"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Data {
        data = typeof data === 'object' ? data : {};
        let result = new Data();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Day"] = this.day ? this.day.toJSON() : <any>undefined;
        return data;
    }
}

export interface IData {
    day?: Day;
}

export class Datum implements IDatum {
    time?: string | undefined;
    country?: string | undefined;
    indicator?: string | undefined;
    per?: string | undefined;
    priority?: string | undefined;
    actual?: string | undefined;
    consensus?: string | undefined;
    previous?: string | undefined;
    id?: string | undefined;

    constructor(data?: IDatum) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.time = _data["Time"];
            this.country = _data["Country"];
            this.indicator = _data["Indicator"];
            this.per = _data["Per"];
            this.priority = _data["Priority"];
            this.actual = _data["Actual"];
            this.consensus = _data["Consensus"];
            this.previous = _data["Previous"];
            this.id = _data["Id"];
        }
    }

    static fromJS(data: any): Datum {
        data = typeof data === 'object' ? data : {};
        let result = new Datum();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Time"] = this.time;
        data["Country"] = this.country;
        data["Indicator"] = this.indicator;
        data["Per"] = this.per;
        data["Priority"] = this.priority;
        data["Actual"] = this.actual;
        data["Consensus"] = this.consensus;
        data["Previous"] = this.previous;
        data["Id"] = this.id;
        return data;
    }
}

export interface IDatum {
    time?: string | undefined;
    country?: string | undefined;
    indicator?: string | undefined;
    per?: string | undefined;
    priority?: string | undefined;
    actual?: string | undefined;
    consensus?: string | undefined;
    previous?: string | undefined;
    id?: string | undefined;
}

export class Day implements IDay {
    datum?: Datum[] | undefined;
    date?: string | undefined;

    constructor(data?: IDay) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["Datum"])) {
                this.datum = [] as any;
                for (let item of _data["Datum"])
                    this.datum!.push(Datum.fromJS(item));
            }
            this.date = _data["Date"];
        }
    }

    static fromJS(data: any): Day {
        data = typeof data === 'object' ? data : {};
        let result = new Day();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.datum)) {
            data["Datum"] = [];
            for (let item of this.datum)
                data["Datum"].push(item.toJSON());
        }
        data["Date"] = this.date;
        return data;
    }
}

export interface IDay {
    datum?: Datum[] | undefined;
    date?: string | undefined;
}

export class DebentureModel implements IDebentureModel {
    data?: DebentureModelData[] | undefined;

    constructor(data?: IDebentureModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["Data"])) {
                this.data = [] as any;
                for (let item of _data["Data"])
                    this.data!.push(DebentureModelData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DebentureModel {
        data = typeof data === 'object' ? data : {};
        let result = new DebentureModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["Data"] = [];
            for (let item of this.data)
                data["Data"].push(item.toJSON());
        }
        return data;
    }
}

export interface IDebentureModel {
    data?: DebentureModelData[] | undefined;
}

export class DebentureModelData implements IDebentureModelData {
    sembol?: string | undefined;
    aciklama?: string | undefined;
    alis?: string | undefined;
    satis?: string | undefined;
    gunlukyuzde?: string | undefined;
    dunkukapanis?: string | undefined;
    piydeg?: string | undefined;
    fark?: string | undefined;
    tarih?: string | undefined;
    son?: string | undefined;
    simge?: string | undefined;
    vobSayi?: string | undefined;
    hacimtl?: string | undefined;
    hacimlot?: string | undefined;
    acilis?: string | undefined;
    dusuk?: string | undefined;
    yuksek?: string | undefined;
    tip?: string | undefined;
    sembolId?: string | undefined;
    yilYuksek?: string | undefined;
    yilDusuk?: string | undefined;
    sermaye?: string | undefined;

    constructor(data?: IDebentureModelData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sembol = _data["Sembol"];
            this.aciklama = _data["Aciklama"];
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
            this.dunkukapanis = _data["Dunkukapanis"];
            this.piydeg = _data["Piydeg"];
            this.fark = _data["Fark"];
            this.tarih = _data["Tarih"];
            this.son = _data["Son"];
            this.simge = _data["Simge"];
            this.vobSayi = _data["VobSayi"];
            this.hacimtl = _data["Hacimtl"];
            this.hacimlot = _data["Hacimlot"];
            this.acilis = _data["Acilis"];
            this.dusuk = _data["Dusuk"];
            this.yuksek = _data["Yuksek"];
            this.tip = _data["Tip"];
            this.sembolId = _data["SembolId"];
            this.yilYuksek = _data["YilYuksek"];
            this.yilDusuk = _data["YilDusuk"];
            this.sermaye = _data["Sermaye"];
        }
    }

    static fromJS(data: any): DebentureModelData {
        data = typeof data === 'object' ? data : {};
        let result = new DebentureModelData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Sembol"] = this.sembol;
        data["Aciklama"] = this.aciklama;
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        data["Dunkukapanis"] = this.dunkukapanis;
        data["Piydeg"] = this.piydeg;
        data["Fark"] = this.fark;
        data["Tarih"] = this.tarih;
        data["Son"] = this.son;
        data["Simge"] = this.simge;
        data["VobSayi"] = this.vobSayi;
        data["Hacimtl"] = this.hacimtl;
        data["Hacimlot"] = this.hacimlot;
        data["Acilis"] = this.acilis;
        data["Dusuk"] = this.dusuk;
        data["Yuksek"] = this.yuksek;
        data["Tip"] = this.tip;
        data["SembolId"] = this.sembolId;
        data["YilYuksek"] = this.yilYuksek;
        data["YilDusuk"] = this.yilDusuk;
        data["Sermaye"] = this.sermaye;
        return data;
    }
}

export interface IDebentureModelData {
    sembol?: string | undefined;
    aciklama?: string | undefined;
    alis?: string | undefined;
    satis?: string | undefined;
    gunlukyuzde?: string | undefined;
    dunkukapanis?: string | undefined;
    piydeg?: string | undefined;
    fark?: string | undefined;
    tarih?: string | undefined;
    son?: string | undefined;
    simge?: string | undefined;
    vobSayi?: string | undefined;
    hacimtl?: string | undefined;
    hacimlot?: string | undefined;
    acilis?: string | undefined;
    dusuk?: string | undefined;
    yuksek?: string | undefined;
    tip?: string | undefined;
    sembolId?: string | undefined;
    yilYuksek?: string | undefined;
    yilDusuk?: string | undefined;
    sermaye?: string | undefined;
}

export class DemandType implements IDemandType {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;

    constructor(data?: IDemandType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.createdOn = _data["CreatedOn"] ? moment(_data["CreatedOn"].toString()) : <any>undefined;
            this.createdById = _data["CreatedById"];
            this.createdBy = _data["CreatedBy"] ? User.fromJS(_data["CreatedBy"]) : <any>undefined;
            this.updatedOn = _data["UpdatedOn"] ? moment(_data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedById = _data["UpdatedById"];
            this.updatedBy = _data["UpdatedBy"] ? User.fromJS(_data["UpdatedBy"]) : <any>undefined;
            this.deletedOn = _data["DeletedOn"] ? moment(_data["DeletedOn"].toString()) : <any>undefined;
            this.deletedById = _data["DeletedById"];
            this.deletedBy = _data["DeletedBy"] ? User.fromJS(_data["DeletedBy"]) : <any>undefined;
            this.isDeleted = _data["IsDeleted"];
            this.code = _data["Code"];
            this.description = _data["Description"];
            this.displayOrder = _data["DisplayOrder"];
            this.isActive = _data["IsActive"];
        }
    }

    static fromJS(data: any): DemandType {
        data = typeof data === 'object' ? data : {};
        let result = new DemandType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedById"] = this.createdById;
        data["CreatedBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["DeletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        data["DeletedById"] = this.deletedById;
        data["DeletedBy"] = this.deletedBy ? this.deletedBy.toJSON() : <any>undefined;
        data["IsDeleted"] = this.isDeleted;
        data["Code"] = this.code;
        data["Description"] = this.description;
        data["DisplayOrder"] = this.displayOrder;
        data["IsActive"] = this.isActive;
        return data;
    }
}

export interface IDemandType {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;
}

export class DemandTypeModel implements IDemandTypeModel {
    id?: number;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;

    constructor(data?: IDemandTypeModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.code = _data["Code"];
            this.description = _data["Description"];
            this.displayOrder = _data["DisplayOrder"];
            this.isActive = _data["IsActive"];
        }
    }

    static fromJS(data: any): DemandTypeModel {
        data = typeof data === 'object' ? data : {};
        let result = new DemandTypeModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Code"] = this.code;
        data["Description"] = this.description;
        data["DisplayOrder"] = this.displayOrder;
        data["IsActive"] = this.isActive;
        return data;
    }
}

export interface IDemandTypeModel {
    id?: number;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;
}

export class District implements IDistrict {
    id?: number;
    provinceId?: number;
    province?: Province;
    name!: string;
    type?: string | undefined;
    location?: string | undefined;

    constructor(data?: IDistrict) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.provinceId = _data["ProvinceId"];
            this.province = _data["Province"] ? Province.fromJS(_data["Province"]) : <any>undefined;
            this.name = _data["Name"];
            this.type = _data["Type"];
            this.location = _data["Location"];
        }
    }

    static fromJS(data: any): District {
        data = typeof data === 'object' ? data : {};
        let result = new District();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["ProvinceId"] = this.provinceId;
        data["Province"] = this.province ? this.province.toJSON() : <any>undefined;
        data["Name"] = this.name;
        data["Type"] = this.type;
        data["Location"] = this.location;
        return data;
    }
}

export interface IDistrict {
    id?: number;
    provinceId?: number;
    province?: Province;
    name: string;
    type?: string | undefined;
    location?: string | undefined;
}

export class Dkk implements IDkk {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IDkk) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): Dkk {
        data = typeof data === 'object' ? data : {};
        let result = new Dkk();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IDkk {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class DocumentType implements IDocumentType {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;

    constructor(data?: IDocumentType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.createdOn = _data["CreatedOn"] ? moment(_data["CreatedOn"].toString()) : <any>undefined;
            this.createdById = _data["CreatedById"];
            this.createdBy = _data["CreatedBy"] ? User.fromJS(_data["CreatedBy"]) : <any>undefined;
            this.updatedOn = _data["UpdatedOn"] ? moment(_data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedById = _data["UpdatedById"];
            this.updatedBy = _data["UpdatedBy"] ? User.fromJS(_data["UpdatedBy"]) : <any>undefined;
            this.deletedOn = _data["DeletedOn"] ? moment(_data["DeletedOn"].toString()) : <any>undefined;
            this.deletedById = _data["DeletedById"];
            this.deletedBy = _data["DeletedBy"] ? User.fromJS(_data["DeletedBy"]) : <any>undefined;
            this.isDeleted = _data["IsDeleted"];
            this.code = _data["Code"];
            this.description = _data["Description"];
            this.displayOrder = _data["DisplayOrder"];
            this.isActive = _data["IsActive"];
        }
    }

    static fromJS(data: any): DocumentType {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedById"] = this.createdById;
        data["CreatedBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["DeletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        data["DeletedById"] = this.deletedById;
        data["DeletedBy"] = this.deletedBy ? this.deletedBy.toJSON() : <any>undefined;
        data["IsDeleted"] = this.isDeleted;
        data["Code"] = this.code;
        data["Description"] = this.description;
        data["DisplayOrder"] = this.displayOrder;
        data["IsActive"] = this.isActive;
        return data;
    }
}

export interface IDocumentType {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;
}

export class DocumentTypeModel implements IDocumentTypeModel {
    id?: number;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;

    constructor(data?: IDocumentTypeModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.code = _data["Code"];
            this.description = _data["Description"];
            this.displayOrder = _data["DisplayOrder"];
            this.isActive = _data["IsActive"];
        }
    }

    static fromJS(data: any): DocumentTypeModel {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentTypeModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Code"] = this.code;
        data["Description"] = this.description;
        data["DisplayOrder"] = this.displayOrder;
        data["IsActive"] = this.isActive;
        return data;
    }
}

export interface IDocumentTypeModel {
    id?: number;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;
}

export class ErrorDto implements IErrorDto {
    code?: number;
    key?: string | undefined;
    message?: string | undefined;

    constructor(data?: IErrorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["Code"];
            this.key = _data["Key"];
            this.message = _data["Message"];
        }
    }

    static fromJS(data: any): ErrorDto {
        data = typeof data === 'object' ? data : {};
        let result = new ErrorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Code"] = this.code;
        data["Key"] = this.key;
        data["Message"] = this.message;
        return data;
    }
}

export interface IErrorDto {
    code?: number;
    key?: string | undefined;
    message?: string | undefined;
}

export class Euro implements IEuro {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IEuro) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): Euro {
        data = typeof data === 'object' ? data : {};
        let result = new Euro();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IEuro {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class Eurtry implements IEurtry {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IEurtry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): Eurtry {
        data = typeof data === 'object' ? data : {};
        let result = new Eurtry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IEurtry {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export enum EventAttributes {
    _0 = 0,
    _512 = 512,
    _1024 = 1024,
}

export class EventInfo implements IEventInfo {
    readonly name?: string | undefined;
    declaringType?: Type;
    reflectedType?: Type;
    module?: Module;
    readonly customAttributes?: CustomAttributeData[] | undefined;
    readonly isCollectible?: boolean;
    readonly metadataToken?: number;
    memberType?: MemberTypes;
    attributes?: EventAttributes;
    readonly isSpecialName?: boolean;
    addMethod?: MethodInfo;
    removeMethod?: MethodInfo;
    raiseMethod?: MethodInfo;
    readonly isMulticast?: boolean;
    eventHandlerType?: Type;

    constructor(data?: IEventInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).name = _data["Name"];
            this.declaringType = _data["DeclaringType"] ? Type.fromJS(_data["DeclaringType"]) : <any>undefined;
            this.reflectedType = _data["ReflectedType"] ? Type.fromJS(_data["ReflectedType"]) : <any>undefined;
            this.module = _data["Module"] ? Module.fromJS(_data["Module"]) : <any>undefined;
            if (Array.isArray(_data["CustomAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["CustomAttributes"])
                    (<any>this).customAttributes!.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).isCollectible = _data["IsCollectible"];
            (<any>this).metadataToken = _data["MetadataToken"];
            this.memberType = _data["MemberType"];
            this.attributes = _data["Attributes"];
            (<any>this).isSpecialName = _data["IsSpecialName"];
            this.addMethod = _data["AddMethod"] ? MethodInfo.fromJS(_data["AddMethod"]) : <any>undefined;
            this.removeMethod = _data["RemoveMethod"] ? MethodInfo.fromJS(_data["RemoveMethod"]) : <any>undefined;
            this.raiseMethod = _data["RaiseMethod"] ? MethodInfo.fromJS(_data["RaiseMethod"]) : <any>undefined;
            (<any>this).isMulticast = _data["IsMulticast"];
            this.eventHandlerType = _data["EventHandlerType"] ? Type.fromJS(_data["EventHandlerType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): EventInfo {
        data = typeof data === 'object' ? data : {};
        let result = new EventInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Name"] = this.name;
        data["DeclaringType"] = this.declaringType ? this.declaringType.toJSON() : <any>undefined;
        data["ReflectedType"] = this.reflectedType ? this.reflectedType.toJSON() : <any>undefined;
        data["Module"] = this.module ? this.module.toJSON() : <any>undefined;
        if (Array.isArray(this.customAttributes)) {
            data["CustomAttributes"] = [];
            for (let item of this.customAttributes)
                data["CustomAttributes"].push(item.toJSON());
        }
        data["IsCollectible"] = this.isCollectible;
        data["MetadataToken"] = this.metadataToken;
        data["MemberType"] = this.memberType;
        data["Attributes"] = this.attributes;
        data["IsSpecialName"] = this.isSpecialName;
        data["AddMethod"] = this.addMethod ? this.addMethod.toJSON() : <any>undefined;
        data["RemoveMethod"] = this.removeMethod ? this.removeMethod.toJSON() : <any>undefined;
        data["RaiseMethod"] = this.raiseMethod ? this.raiseMethod.toJSON() : <any>undefined;
        data["IsMulticast"] = this.isMulticast;
        data["EventHandlerType"] = this.eventHandlerType ? this.eventHandlerType.toJSON() : <any>undefined;
        return data;
    }
}

export interface IEventInfo {
    name?: string | undefined;
    declaringType?: Type;
    reflectedType?: Type;
    module?: Module;
    customAttributes?: CustomAttributeData[] | undefined;
    isCollectible?: boolean;
    metadataToken?: number;
    memberType?: MemberTypes;
    attributes?: EventAttributes;
    isSpecialName?: boolean;
    addMethod?: MethodInfo;
    removeMethod?: MethodInfo;
    raiseMethod?: MethodInfo;
    isMulticast?: boolean;
    eventHandlerType?: Type;
}

export class Exception implements IException {
    targetSite?: MethodBase;
    readonly stackTrace?: string | undefined;
    readonly message?: string | undefined;
    readonly data?: { [key: string]: any; } | undefined;
    innerException?: Exception;
    helpLink?: string | undefined;
    source?: string | undefined;
    hResult?: number;

    constructor(data?: IException) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.targetSite = _data["TargetSite"] ? MethodBase.fromJS(_data["TargetSite"]) : <any>undefined;
            (<any>this).stackTrace = _data["StackTrace"];
            (<any>this).message = _data["Message"];
            if (_data["Data"]) {
                (<any>this).data = {} as any;
                for (let key in _data["Data"]) {
                    if (_data["Data"].hasOwnProperty(key))
                        (<any>(<any>this).data)![key] = _data["Data"][key];
                }
            }
            this.innerException = _data["InnerException"] ? Exception.fromJS(_data["InnerException"]) : <any>undefined;
            this.helpLink = _data["HelpLink"];
            this.source = _data["Source"];
            this.hResult = _data["HResult"];
        }
    }

    static fromJS(data: any): Exception {
        data = typeof data === 'object' ? data : {};
        let result = new Exception();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["TargetSite"] = this.targetSite ? this.targetSite.toJSON() : <any>undefined;
        data["StackTrace"] = this.stackTrace;
        data["Message"] = this.message;
        if (this.data) {
            data["Data"] = {};
            for (let key in this.data) {
                if (this.data.hasOwnProperty(key))
                    (<any>data["Data"])[key] = this.data[key];
            }
        }
        data["InnerException"] = this.innerException ? this.innerException.toJSON() : <any>undefined;
        data["HelpLink"] = this.helpLink;
        data["Source"] = this.source;
        data["HResult"] = this.hResult;
        return data;
    }
}

export interface IException {
    targetSite?: MethodBase;
    stackTrace?: string | undefined;
    message?: string | undefined;
    data?: { [key: string]: any; } | undefined;
    innerException?: Exception;
    helpLink?: string | undefined;
    source?: string | undefined;
    hResult?: number;
}

export enum FieldAttributes {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _16 = 16,
    _32 = 32,
    _64 = 64,
    _128 = 128,
    _256 = 256,
    _512 = 512,
    _1024 = 1024,
    _4096 = 4096,
    _8192 = 8192,
    _32768 = 32768,
    _38144 = 38144,
}

export class FieldInfo implements IFieldInfo {
    readonly name?: string | undefined;
    declaringType?: Type;
    reflectedType?: Type;
    module?: Module;
    readonly customAttributes?: CustomAttributeData[] | undefined;
    readonly isCollectible?: boolean;
    readonly metadataToken?: number;
    memberType?: MemberTypes;
    attributes?: FieldAttributes;
    fieldType?: Type;
    readonly isInitOnly?: boolean;
    readonly isLiteral?: boolean;
    readonly isNotSerialized?: boolean;
    readonly isPinvokeImpl?: boolean;
    readonly isSpecialName?: boolean;
    readonly isStatic?: boolean;
    readonly isAssembly?: boolean;
    readonly isFamily?: boolean;
    readonly isFamilyAndAssembly?: boolean;
    readonly isFamilyOrAssembly?: boolean;
    readonly isPrivate?: boolean;
    readonly isPublic?: boolean;
    readonly isSecurityCritical?: boolean;
    readonly isSecuritySafeCritical?: boolean;
    readonly isSecurityTransparent?: boolean;
    fieldHandle?: RuntimeFieldHandle;

    constructor(data?: IFieldInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).name = _data["Name"];
            this.declaringType = _data["DeclaringType"] ? Type.fromJS(_data["DeclaringType"]) : <any>undefined;
            this.reflectedType = _data["ReflectedType"] ? Type.fromJS(_data["ReflectedType"]) : <any>undefined;
            this.module = _data["Module"] ? Module.fromJS(_data["Module"]) : <any>undefined;
            if (Array.isArray(_data["CustomAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["CustomAttributes"])
                    (<any>this).customAttributes!.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).isCollectible = _data["IsCollectible"];
            (<any>this).metadataToken = _data["MetadataToken"];
            this.memberType = _data["MemberType"];
            this.attributes = _data["Attributes"];
            this.fieldType = _data["FieldType"] ? Type.fromJS(_data["FieldType"]) : <any>undefined;
            (<any>this).isInitOnly = _data["IsInitOnly"];
            (<any>this).isLiteral = _data["IsLiteral"];
            (<any>this).isNotSerialized = _data["IsNotSerialized"];
            (<any>this).isPinvokeImpl = _data["IsPinvokeImpl"];
            (<any>this).isSpecialName = _data["IsSpecialName"];
            (<any>this).isStatic = _data["IsStatic"];
            (<any>this).isAssembly = _data["IsAssembly"];
            (<any>this).isFamily = _data["IsFamily"];
            (<any>this).isFamilyAndAssembly = _data["IsFamilyAndAssembly"];
            (<any>this).isFamilyOrAssembly = _data["IsFamilyOrAssembly"];
            (<any>this).isPrivate = _data["IsPrivate"];
            (<any>this).isPublic = _data["IsPublic"];
            (<any>this).isSecurityCritical = _data["IsSecurityCritical"];
            (<any>this).isSecuritySafeCritical = _data["IsSecuritySafeCritical"];
            (<any>this).isSecurityTransparent = _data["IsSecurityTransparent"];
            this.fieldHandle = _data["FieldHandle"] ? RuntimeFieldHandle.fromJS(_data["FieldHandle"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FieldInfo {
        data = typeof data === 'object' ? data : {};
        let result = new FieldInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Name"] = this.name;
        data["DeclaringType"] = this.declaringType ? this.declaringType.toJSON() : <any>undefined;
        data["ReflectedType"] = this.reflectedType ? this.reflectedType.toJSON() : <any>undefined;
        data["Module"] = this.module ? this.module.toJSON() : <any>undefined;
        if (Array.isArray(this.customAttributes)) {
            data["CustomAttributes"] = [];
            for (let item of this.customAttributes)
                data["CustomAttributes"].push(item.toJSON());
        }
        data["IsCollectible"] = this.isCollectible;
        data["MetadataToken"] = this.metadataToken;
        data["MemberType"] = this.memberType;
        data["Attributes"] = this.attributes;
        data["FieldType"] = this.fieldType ? this.fieldType.toJSON() : <any>undefined;
        data["IsInitOnly"] = this.isInitOnly;
        data["IsLiteral"] = this.isLiteral;
        data["IsNotSerialized"] = this.isNotSerialized;
        data["IsPinvokeImpl"] = this.isPinvokeImpl;
        data["IsSpecialName"] = this.isSpecialName;
        data["IsStatic"] = this.isStatic;
        data["IsAssembly"] = this.isAssembly;
        data["IsFamily"] = this.isFamily;
        data["IsFamilyAndAssembly"] = this.isFamilyAndAssembly;
        data["IsFamilyOrAssembly"] = this.isFamilyOrAssembly;
        data["IsPrivate"] = this.isPrivate;
        data["IsPublic"] = this.isPublic;
        data["IsSecurityCritical"] = this.isSecurityCritical;
        data["IsSecuritySafeCritical"] = this.isSecuritySafeCritical;
        data["IsSecurityTransparent"] = this.isSecurityTransparent;
        data["FieldHandle"] = this.fieldHandle ? this.fieldHandle.toJSON() : <any>undefined;
        return data;
    }
}

export interface IFieldInfo {
    name?: string | undefined;
    declaringType?: Type;
    reflectedType?: Type;
    module?: Module;
    customAttributes?: CustomAttributeData[] | undefined;
    isCollectible?: boolean;
    metadataToken?: number;
    memberType?: MemberTypes;
    attributes?: FieldAttributes;
    fieldType?: Type;
    isInitOnly?: boolean;
    isLiteral?: boolean;
    isNotSerialized?: boolean;
    isPinvokeImpl?: boolean;
    isSpecialName?: boolean;
    isStatic?: boolean;
    isAssembly?: boolean;
    isFamily?: boolean;
    isFamilyAndAssembly?: boolean;
    isFamilyOrAssembly?: boolean;
    isPrivate?: boolean;
    isPublic?: boolean;
    isSecurityCritical?: boolean;
    isSecuritySafeCritical?: boolean;
    isSecurityTransparent?: boolean;
    fieldHandle?: RuntimeFieldHandle;
}

export class ForgotModel implements IForgotModel {
    email?: string | undefined;
    phoneNumber?: string | undefined;

    constructor(data?: IForgotModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["Email"];
            this.phoneNumber = _data["PhoneNumber"];
        }
    }

    static fromJS(data: any): ForgotModel {
        data = typeof data === 'object' ? data : {};
        let result = new ForgotModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Email"] = this.email;
        data["PhoneNumber"] = this.phoneNumber;
        return data;
    }
}

export interface IForgotModel {
    email?: string | undefined;
    phoneNumber?: string | undefined;
}

export class Gbp implements IGbp {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IGbp) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): Gbp {
        data = typeof data === 'object' ? data : {};
        let result = new Gbp();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IGbp {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class Gender implements IGender {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;

    constructor(data?: IGender) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.createdOn = _data["CreatedOn"] ? moment(_data["CreatedOn"].toString()) : <any>undefined;
            this.createdById = _data["CreatedById"];
            this.createdBy = _data["CreatedBy"] ? User.fromJS(_data["CreatedBy"]) : <any>undefined;
            this.updatedOn = _data["UpdatedOn"] ? moment(_data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedById = _data["UpdatedById"];
            this.updatedBy = _data["UpdatedBy"] ? User.fromJS(_data["UpdatedBy"]) : <any>undefined;
            this.deletedOn = _data["DeletedOn"] ? moment(_data["DeletedOn"].toString()) : <any>undefined;
            this.deletedById = _data["DeletedById"];
            this.deletedBy = _data["DeletedBy"] ? User.fromJS(_data["DeletedBy"]) : <any>undefined;
            this.isDeleted = _data["IsDeleted"];
            this.code = _data["Code"];
            this.description = _data["Description"];
            this.displayOrder = _data["DisplayOrder"];
            this.isActive = _data["IsActive"];
        }
    }

    static fromJS(data: any): Gender {
        data = typeof data === 'object' ? data : {};
        let result = new Gender();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedById"] = this.createdById;
        data["CreatedBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["DeletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        data["DeletedById"] = this.deletedById;
        data["DeletedBy"] = this.deletedBy ? this.deletedBy.toJSON() : <any>undefined;
        data["IsDeleted"] = this.isDeleted;
        data["Code"] = this.code;
        data["Description"] = this.description;
        data["DisplayOrder"] = this.displayOrder;
        data["IsActive"] = this.isActive;
        return data;
    }
}

export interface IGender {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;
}

export class GenderModel implements IGenderModel {
    id?: number;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;

    constructor(data?: IGenderModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.code = _data["Code"];
            this.description = _data["Description"];
            this.displayOrder = _data["DisplayOrder"];
            this.isActive = _data["IsActive"];
        }
    }

    static fromJS(data: any): GenderModel {
        data = typeof data === 'object' ? data : {};
        let result = new GenderModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Code"] = this.code;
        data["Description"] = this.description;
        data["DisplayOrder"] = this.displayOrder;
        data["IsActive"] = this.isActive;
        return data;
    }
}

export interface IGenderModel {
    id?: number;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;
}

export enum GenericParameterAttributes {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _8 = 8,
    _16 = 16,
    _28 = 28,
}

export class GraphicData implements IGraphicData {
    symbol?: string | undefined;
    date?: string | undefined;
    openString?: string | undefined;
    closeString?: string | undefined;
    highString?: string | undefined;
    lowString?: string | undefined;
    volumeString?: string | undefined;
    weightAverageString?: string | undefined;
    changeString?: string | undefined;
    readonly open?: number;
    readonly close?: number;
    readonly high?: number;
    readonly low?: number;
    readonly volume?: number;
    readonly weightAverage?: number;
    readonly change?: number;

    constructor(data?: IGraphicData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.symbol = _data["Symbol"];
            this.date = _data["Date"];
            this.openString = _data["OpenString"];
            this.closeString = _data["CloseString"];
            this.highString = _data["HighString"];
            this.lowString = _data["LowString"];
            this.volumeString = _data["VolumeString"];
            this.weightAverageString = _data["WeightAverageString"];
            this.changeString = _data["ChangeString"];
            (<any>this).open = _data["Open"];
            (<any>this).close = _data["Close"];
            (<any>this).high = _data["High"];
            (<any>this).low = _data["Low"];
            (<any>this).volume = _data["Volume"];
            (<any>this).weightAverage = _data["WeightAverage"];
            (<any>this).change = _data["Change"];
        }
    }

    static fromJS(data: any): GraphicData {
        data = typeof data === 'object' ? data : {};
        let result = new GraphicData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Symbol"] = this.symbol;
        data["Date"] = this.date;
        data["OpenString"] = this.openString;
        data["CloseString"] = this.closeString;
        data["HighString"] = this.highString;
        data["LowString"] = this.lowString;
        data["VolumeString"] = this.volumeString;
        data["WeightAverageString"] = this.weightAverageString;
        data["ChangeString"] = this.changeString;
        data["Open"] = this.open;
        data["Close"] = this.close;
        data["High"] = this.high;
        data["Low"] = this.low;
        data["Volume"] = this.volume;
        data["WeightAverage"] = this.weightAverage;
        data["Change"] = this.change;
        return data;
    }
}

export interface IGraphicData {
    symbol?: string | undefined;
    date?: string | undefined;
    openString?: string | undefined;
    closeString?: string | undefined;
    highString?: string | undefined;
    lowString?: string | undefined;
    volumeString?: string | undefined;
    weightAverageString?: string | undefined;
    changeString?: string | undefined;
    open?: number;
    close?: number;
    high?: number;
    low?: number;
    volume?: number;
    weightAverage?: number;
    change?: number;
}

export class GraphicDataModel implements IGraphicDataModel {
    data?: GraphicData[] | undefined;

    constructor(data?: IGraphicDataModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["Data"])) {
                this.data = [] as any;
                for (let item of _data["Data"])
                    this.data!.push(GraphicData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GraphicDataModel {
        data = typeof data === 'object' ? data : {};
        let result = new GraphicDataModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["Data"] = [];
            for (let item of this.data)
                data["Data"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGraphicDataModel {
    data?: GraphicData[] | undefined;
}

export class Group implements IGroup {
    id?: number;
    name!: string;
    description?: string | undefined;
    isDeleted?: boolean;

    constructor(data?: IGroup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.name = _data["Name"];
            this.description = _data["Description"];
            this.isDeleted = _data["IsDeleted"];
        }
    }

    static fromJS(data: any): Group {
        data = typeof data === 'object' ? data : {};
        let result = new Group();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Name"] = this.name;
        data["Description"] = this.description;
        data["IsDeleted"] = this.isDeleted;
        return data;
    }
}

export interface IGroup {
    id?: number;
    name: string;
    description?: string | undefined;
    isDeleted?: boolean;
}

export class GroupModel implements IGroupModel {
    id?: number;
    name?: string | undefined;
    description?: string | undefined;

    constructor(data?: IGroupModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.name = _data["Name"];
            this.description = _data["Description"];
        }
    }

    static fromJS(data: any): GroupModel {
        data = typeof data === 'object' ? data : {};
        let result = new GroupModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Name"] = this.name;
        data["Description"] = this.description;
        return data;
    }
}

export interface IGroupModel {
    id?: number;
    name?: string | undefined;
    description?: string | undefined;
}

export class Gumus implements IGumus {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IGumus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): Gumus {
        data = typeof data === 'object' ? data : {};
        let result = new Gumus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IGumus {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class Gumuseur implements IGumuseur {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IGumuseur) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): Gumuseur {
        data = typeof data === 'object' ? data : {};
        let result = new Gumuseur();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IGumuseur {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class Gumusfix implements IGumusfix {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IGumusfix) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): Gumusfix {
        data = typeof data === 'object' ? data : {};
        let result = new Gumusfix();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IGumusfix {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class Gumusserbest implements IGumusserbest {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IGumusserbest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): Gumusserbest {
        data = typeof data === 'object' ? data : {};
        let result = new Gumusserbest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IGumusserbest {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class Gumususd implements IGumususd {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IGumususd) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): Gumususd {
        data = typeof data === 'object' ? data : {};
        let result = new Gumususd();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IGumususd {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class ICustomAttributeProvider implements IICustomAttributeProvider {

    constructor(data?: IICustomAttributeProvider) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): ICustomAttributeProvider {
        data = typeof data === 'object' ? data : {};
        let result = new ICustomAttributeProvider();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IICustomAttributeProvider {
}

export class Iko01 implements IIko01 {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IIko01) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): Iko01 {
        data = typeof data === 'object' ? data : {};
        let result = new Iko01();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IIko01 {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class Iko02 implements IIko02 {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IIko02) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): Iko02 {
        data = typeof data === 'object' ? data : {};
        let result = new Iko02();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IIko02 {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class Iko03 implements IIko03 {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IIko03) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): Iko03 {
        data = typeof data === 'object' ? data : {};
        let result = new Iko03();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IIko03 {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class Iko04 implements IIko04 {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IIko04) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): Iko04 {
        data = typeof data === 'object' ? data : {};
        let result = new Iko04();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IIko04 {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class Iko05 implements IIko05 {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IIko05) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): Iko05 {
        data = typeof data === 'object' ? data : {};
        let result = new Iko05();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IIko05 {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class Iko06 implements IIko06 {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IIko06) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): Iko06 {
        data = typeof data === 'object' ? data : {};
        let result = new Iko06();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IIko06 {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class Iko07 implements IIko07 {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IIko07) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): Iko07 {
        data = typeof data === 'object' ? data : {};
        let result = new Iko07();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IIko07 {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class Iko08 implements IIko08 {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IIko08) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): Iko08 {
        data = typeof data === 'object' ? data : {};
        let result = new Iko08();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IIko08 {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class Iko09 implements IIko09 {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IIko09) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): Iko09 {
        data = typeof data === 'object' ? data : {};
        let result = new Iko09();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IIko09 {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class Iko10 implements IIko10 {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IIko10) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): Iko10 {
        data = typeof data === 'object' ? data : {};
        let result = new Iko10();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IIko10 {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class Iko11 implements IIko11 {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IIko11) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): Iko11 {
        data = typeof data === 'object' ? data : {};
        let result = new Iko11();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IIko11 {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class Iko12 implements IIko12 {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IIko12) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): Iko12 {
        data = typeof data === 'object' ? data : {};
        let result = new Iko12();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IIko12 {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class IntPtr implements IIntPtr {

    constructor(data?: IIntPtr) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): IntPtr {
        data = typeof data === 'object' ? data : {};
        let result = new IntPtr();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IIntPtr {
}

export class InvoiceStatusModel implements IInvoiceStatusModel {
    id?: number;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;

    constructor(data?: IInvoiceStatusModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.code = _data["Code"];
            this.description = _data["Description"];
            this.displayOrder = _data["DisplayOrder"];
            this.isActive = _data["IsActive"];
        }
    }

    static fromJS(data: any): InvoiceStatusModel {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceStatusModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Code"] = this.code;
        data["Description"] = this.description;
        data["DisplayOrder"] = this.displayOrder;
        data["IsActive"] = this.isActive;
        return data;
    }
}

export interface IInvoiceStatusModel {
    id?: number;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;
}

export class Jpy implements IJpy {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IJpy) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): Jpy {
        data = typeof data === 'object' ? data : {};
        let result = new Jpy();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IJpy {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class KnowledgeBaseCategoryModel implements IKnowledgeBaseCategoryModel {
    id?: number;
    name?: string | undefined;
    mediaId?: number | undefined;
    media?: MediaModel;

    constructor(data?: IKnowledgeBaseCategoryModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.name = _data["Name"];
            this.mediaId = _data["MediaId"];
            this.media = _data["Media"] ? MediaModel.fromJS(_data["Media"]) : <any>undefined;
        }
    }

    static fromJS(data: any): KnowledgeBaseCategoryModel {
        data = typeof data === 'object' ? data : {};
        let result = new KnowledgeBaseCategoryModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Name"] = this.name;
        data["MediaId"] = this.mediaId;
        data["Media"] = this.media ? this.media.toJSON() : <any>undefined;
        return data;
    }
}

export interface IKnowledgeBaseCategoryModel {
    id?: number;
    name?: string | undefined;
    mediaId?: number | undefined;
    media?: MediaModel;
}

export class KnowledgeBaseModel implements IKnowledgeBaseModel {
    title!: string;
    subTitle?: string | undefined;
    slug?: string | undefined;
    metaKeywords?: string | undefined;
    metaDescription?: string | undefined;
    body?: string | undefined;
    mediaId?: number | undefined;
    media?: MediaModel;
    isPublished?: boolean;
    publishedOn?: moment.Moment | undefined;
    publishedTill?: moment.Moment | undefined;
    categoryId?: number | undefined;
    category?: KnowledgeBaseCategoryModel;

    constructor(data?: IKnowledgeBaseModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["Title"];
            this.subTitle = _data["SubTitle"];
            this.slug = _data["Slug"];
            this.metaKeywords = _data["MetaKeywords"];
            this.metaDescription = _data["MetaDescription"];
            this.body = _data["Body"];
            this.mediaId = _data["MediaId"];
            this.media = _data["Media"] ? MediaModel.fromJS(_data["Media"]) : <any>undefined;
            this.isPublished = _data["IsPublished"];
            this.publishedOn = _data["PublishedOn"] ? moment(_data["PublishedOn"].toString()) : <any>undefined;
            this.publishedTill = _data["PublishedTill"] ? moment(_data["PublishedTill"].toString()) : <any>undefined;
            this.categoryId = _data["CategoryId"];
            this.category = _data["Category"] ? KnowledgeBaseCategoryModel.fromJS(_data["Category"]) : <any>undefined;
        }
    }

    static fromJS(data: any): KnowledgeBaseModel {
        data = typeof data === 'object' ? data : {};
        let result = new KnowledgeBaseModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Title"] = this.title;
        data["SubTitle"] = this.subTitle;
        data["Slug"] = this.slug;
        data["MetaKeywords"] = this.metaKeywords;
        data["MetaDescription"] = this.metaDescription;
        data["Body"] = this.body;
        data["MediaId"] = this.mediaId;
        data["Media"] = this.media ? this.media.toJSON() : <any>undefined;
        data["IsPublished"] = this.isPublished;
        data["PublishedOn"] = this.publishedOn ? this.publishedOn.toISOString() : <any>undefined;
        data["PublishedTill"] = this.publishedTill ? this.publishedTill.toISOString() : <any>undefined;
        data["CategoryId"] = this.categoryId;
        data["Category"] = this.category ? this.category.toJSON() : <any>undefined;
        return data;
    }
}

export interface IKnowledgeBaseModel {
    title: string;
    subTitle?: string | undefined;
    slug?: string | undefined;
    metaKeywords?: string | undefined;
    metaDescription?: string | undefined;
    body?: string | undefined;
    mediaId?: number | undefined;
    media?: MediaModel;
    isPublished?: boolean;
    publishedOn?: moment.Moment | undefined;
    publishedTill?: moment.Moment | undefined;
    categoryId?: number | undefined;
    category?: KnowledgeBaseCategoryModel;
}

export enum LayoutKind {
    _0 = 0,
    _2 = 2,
    _3 = 3,
}

export class LoginModel implements ILoginModel {
    phoneNumber?: string | undefined;
    password?: string | undefined;

    constructor(data?: ILoginModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.phoneNumber = _data["PhoneNumber"];
            this.password = _data["Password"];
        }
    }

    static fromJS(data: any): LoginModel {
        data = typeof data === 'object' ? data : {};
        let result = new LoginModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["PhoneNumber"] = this.phoneNumber;
        data["Password"] = this.password;
        return data;
    }
}

export interface ILoginModel {
    phoneNumber?: string | undefined;
    password?: string | undefined;
}

export class MarketModel implements IMarketModel {
    altin?: Altin;
    altingr?: Altingr;
    altinkgtl?: Altinkgtl;
    altinkgusd?: Altinkgusd;
    ons?: Ons;
    gumusserbest?: Gumusserbest;
    gumususd?: Gumususd;
    gumuseur?: Gumuseur;
    gumus?: Gumus;
    altinusd?: Altinusd;
    altincum?: Altincum;
    altingldt?: Altingldt;
    altingldy?: Altingldy;
    altingldc?: Altingldc;
    altinres?: Altinres;
    altinresk?: Altinresk;
    usd?: Usd;
    euro?: Euro;
    eurtry?: Eurtry;
    gbp?: Gbp;
    jpy?: Jpy;
    cad?: Cad;
    aud?: Aud;
    nok?: Nok;
    dkk?: Dkk;
    sek?: Sek;
    sar?: Sar;
    chf?: Chf;
    platin?: Platin;
    paladyum?: Paladyum;
    cyp?: Cyp;
    gumusfix?: Gumusfix;
    altinfixUsdAm?: AltinfixUsdAm;
    altinfixUsdPm?: AltinfixUsdPm;
    altinfixEurAm?: AltinfixEurAm;
    altinfixEurPm?: AltinfixEurPm;
    altinfixGbpAm?: AltinfixGbpAm;
    altinfixGbpPm?: AltinfixGbpPm;
    platinfixAm?: PlatinfixAm;
    platinfixPm?: PlatinfixPm;
    paladyumfixAm?: PaladyumfixAm;
    paladyumfixPm?: PaladyumfixPm;
    rodyumfix?: Rodyumfix;
    iko01?: Iko01;
    iko02?: Iko02;
    iko03?: Iko03;
    iko04?: Iko04;
    iko05?: Iko05;
    iko06?: Iko06;
    iko07?: Iko07;
    iko08?: Iko08;
    iko09?: Iko09;
    iko10?: Iko10;
    iko11?: Iko11;
    iko12?: Iko12;

    constructor(data?: IMarketModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.altin = _data["Altin"] ? Altin.fromJS(_data["Altin"]) : <any>undefined;
            this.altingr = _data["Altingr"] ? Altingr.fromJS(_data["Altingr"]) : <any>undefined;
            this.altinkgtl = _data["Altinkgtl"] ? Altinkgtl.fromJS(_data["Altinkgtl"]) : <any>undefined;
            this.altinkgusd = _data["Altinkgusd"] ? Altinkgusd.fromJS(_data["Altinkgusd"]) : <any>undefined;
            this.ons = _data["Ons"] ? Ons.fromJS(_data["Ons"]) : <any>undefined;
            this.gumusserbest = _data["Gumusserbest"] ? Gumusserbest.fromJS(_data["Gumusserbest"]) : <any>undefined;
            this.gumususd = _data["Gumususd"] ? Gumususd.fromJS(_data["Gumususd"]) : <any>undefined;
            this.gumuseur = _data["Gumuseur"] ? Gumuseur.fromJS(_data["Gumuseur"]) : <any>undefined;
            this.gumus = _data["Gumus"] ? Gumus.fromJS(_data["Gumus"]) : <any>undefined;
            this.altinusd = _data["Altinusd"] ? Altinusd.fromJS(_data["Altinusd"]) : <any>undefined;
            this.altincum = _data["Altincum"] ? Altincum.fromJS(_data["Altincum"]) : <any>undefined;
            this.altingldt = _data["Altingldt"] ? Altingldt.fromJS(_data["Altingldt"]) : <any>undefined;
            this.altingldy = _data["Altingldy"] ? Altingldy.fromJS(_data["Altingldy"]) : <any>undefined;
            this.altingldc = _data["Altingldc"] ? Altingldc.fromJS(_data["Altingldc"]) : <any>undefined;
            this.altinres = _data["Altinres"] ? Altinres.fromJS(_data["Altinres"]) : <any>undefined;
            this.altinresk = _data["Altinresk"] ? Altinresk.fromJS(_data["Altinresk"]) : <any>undefined;
            this.usd = _data["Usd"] ? Usd.fromJS(_data["Usd"]) : <any>undefined;
            this.euro = _data["Euro"] ? Euro.fromJS(_data["Euro"]) : <any>undefined;
            this.eurtry = _data["Eurtry"] ? Eurtry.fromJS(_data["Eurtry"]) : <any>undefined;
            this.gbp = _data["Gbp"] ? Gbp.fromJS(_data["Gbp"]) : <any>undefined;
            this.jpy = _data["Jpy"] ? Jpy.fromJS(_data["Jpy"]) : <any>undefined;
            this.cad = _data["Cad"] ? Cad.fromJS(_data["Cad"]) : <any>undefined;
            this.aud = _data["Aud"] ? Aud.fromJS(_data["Aud"]) : <any>undefined;
            this.nok = _data["Nok"] ? Nok.fromJS(_data["Nok"]) : <any>undefined;
            this.dkk = _data["Dkk"] ? Dkk.fromJS(_data["Dkk"]) : <any>undefined;
            this.sek = _data["Sek"] ? Sek.fromJS(_data["Sek"]) : <any>undefined;
            this.sar = _data["Sar"] ? Sar.fromJS(_data["Sar"]) : <any>undefined;
            this.chf = _data["Chf"] ? Chf.fromJS(_data["Chf"]) : <any>undefined;
            this.platin = _data["Platin"] ? Platin.fromJS(_data["Platin"]) : <any>undefined;
            this.paladyum = _data["Paladyum"] ? Paladyum.fromJS(_data["Paladyum"]) : <any>undefined;
            this.cyp = _data["Cyp"] ? Cyp.fromJS(_data["Cyp"]) : <any>undefined;
            this.gumusfix = _data["Gumusfix"] ? Gumusfix.fromJS(_data["Gumusfix"]) : <any>undefined;
            this.altinfixUsdAm = _data["AltinfixUsdAm"] ? AltinfixUsdAm.fromJS(_data["AltinfixUsdAm"]) : <any>undefined;
            this.altinfixUsdPm = _data["AltinfixUsdPm"] ? AltinfixUsdPm.fromJS(_data["AltinfixUsdPm"]) : <any>undefined;
            this.altinfixEurAm = _data["AltinfixEurAm"] ? AltinfixEurAm.fromJS(_data["AltinfixEurAm"]) : <any>undefined;
            this.altinfixEurPm = _data["AltinfixEurPm"] ? AltinfixEurPm.fromJS(_data["AltinfixEurPm"]) : <any>undefined;
            this.altinfixGbpAm = _data["AltinfixGbpAm"] ? AltinfixGbpAm.fromJS(_data["AltinfixGbpAm"]) : <any>undefined;
            this.altinfixGbpPm = _data["AltinfixGbpPm"] ? AltinfixGbpPm.fromJS(_data["AltinfixGbpPm"]) : <any>undefined;
            this.platinfixAm = _data["PlatinfixAm"] ? PlatinfixAm.fromJS(_data["PlatinfixAm"]) : <any>undefined;
            this.platinfixPm = _data["PlatinfixPm"] ? PlatinfixPm.fromJS(_data["PlatinfixPm"]) : <any>undefined;
            this.paladyumfixAm = _data["PaladyumfixAm"] ? PaladyumfixAm.fromJS(_data["PaladyumfixAm"]) : <any>undefined;
            this.paladyumfixPm = _data["PaladyumfixPm"] ? PaladyumfixPm.fromJS(_data["PaladyumfixPm"]) : <any>undefined;
            this.rodyumfix = _data["Rodyumfix"] ? Rodyumfix.fromJS(_data["Rodyumfix"]) : <any>undefined;
            this.iko01 = _data["Iko01"] ? Iko01.fromJS(_data["Iko01"]) : <any>undefined;
            this.iko02 = _data["Iko02"] ? Iko02.fromJS(_data["Iko02"]) : <any>undefined;
            this.iko03 = _data["Iko03"] ? Iko03.fromJS(_data["Iko03"]) : <any>undefined;
            this.iko04 = _data["Iko04"] ? Iko04.fromJS(_data["Iko04"]) : <any>undefined;
            this.iko05 = _data["Iko05"] ? Iko05.fromJS(_data["Iko05"]) : <any>undefined;
            this.iko06 = _data["Iko06"] ? Iko06.fromJS(_data["Iko06"]) : <any>undefined;
            this.iko07 = _data["Iko07"] ? Iko07.fromJS(_data["Iko07"]) : <any>undefined;
            this.iko08 = _data["Iko08"] ? Iko08.fromJS(_data["Iko08"]) : <any>undefined;
            this.iko09 = _data["Iko09"] ? Iko09.fromJS(_data["Iko09"]) : <any>undefined;
            this.iko10 = _data["Iko10"] ? Iko10.fromJS(_data["Iko10"]) : <any>undefined;
            this.iko11 = _data["Iko11"] ? Iko11.fromJS(_data["Iko11"]) : <any>undefined;
            this.iko12 = _data["Iko12"] ? Iko12.fromJS(_data["Iko12"]) : <any>undefined;
        }
    }

    static fromJS(data: any): MarketModel {
        data = typeof data === 'object' ? data : {};
        let result = new MarketModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Altin"] = this.altin ? this.altin.toJSON() : <any>undefined;
        data["Altingr"] = this.altingr ? this.altingr.toJSON() : <any>undefined;
        data["Altinkgtl"] = this.altinkgtl ? this.altinkgtl.toJSON() : <any>undefined;
        data["Altinkgusd"] = this.altinkgusd ? this.altinkgusd.toJSON() : <any>undefined;
        data["Ons"] = this.ons ? this.ons.toJSON() : <any>undefined;
        data["Gumusserbest"] = this.gumusserbest ? this.gumusserbest.toJSON() : <any>undefined;
        data["Gumususd"] = this.gumususd ? this.gumususd.toJSON() : <any>undefined;
        data["Gumuseur"] = this.gumuseur ? this.gumuseur.toJSON() : <any>undefined;
        data["Gumus"] = this.gumus ? this.gumus.toJSON() : <any>undefined;
        data["Altinusd"] = this.altinusd ? this.altinusd.toJSON() : <any>undefined;
        data["Altincum"] = this.altincum ? this.altincum.toJSON() : <any>undefined;
        data["Altingldt"] = this.altingldt ? this.altingldt.toJSON() : <any>undefined;
        data["Altingldy"] = this.altingldy ? this.altingldy.toJSON() : <any>undefined;
        data["Altingldc"] = this.altingldc ? this.altingldc.toJSON() : <any>undefined;
        data["Altinres"] = this.altinres ? this.altinres.toJSON() : <any>undefined;
        data["Altinresk"] = this.altinresk ? this.altinresk.toJSON() : <any>undefined;
        data["Usd"] = this.usd ? this.usd.toJSON() : <any>undefined;
        data["Euro"] = this.euro ? this.euro.toJSON() : <any>undefined;
        data["Eurtry"] = this.eurtry ? this.eurtry.toJSON() : <any>undefined;
        data["Gbp"] = this.gbp ? this.gbp.toJSON() : <any>undefined;
        data["Jpy"] = this.jpy ? this.jpy.toJSON() : <any>undefined;
        data["Cad"] = this.cad ? this.cad.toJSON() : <any>undefined;
        data["Aud"] = this.aud ? this.aud.toJSON() : <any>undefined;
        data["Nok"] = this.nok ? this.nok.toJSON() : <any>undefined;
        data["Dkk"] = this.dkk ? this.dkk.toJSON() : <any>undefined;
        data["Sek"] = this.sek ? this.sek.toJSON() : <any>undefined;
        data["Sar"] = this.sar ? this.sar.toJSON() : <any>undefined;
        data["Chf"] = this.chf ? this.chf.toJSON() : <any>undefined;
        data["Platin"] = this.platin ? this.platin.toJSON() : <any>undefined;
        data["Paladyum"] = this.paladyum ? this.paladyum.toJSON() : <any>undefined;
        data["Cyp"] = this.cyp ? this.cyp.toJSON() : <any>undefined;
        data["Gumusfix"] = this.gumusfix ? this.gumusfix.toJSON() : <any>undefined;
        data["AltinfixUsdAm"] = this.altinfixUsdAm ? this.altinfixUsdAm.toJSON() : <any>undefined;
        data["AltinfixUsdPm"] = this.altinfixUsdPm ? this.altinfixUsdPm.toJSON() : <any>undefined;
        data["AltinfixEurAm"] = this.altinfixEurAm ? this.altinfixEurAm.toJSON() : <any>undefined;
        data["AltinfixEurPm"] = this.altinfixEurPm ? this.altinfixEurPm.toJSON() : <any>undefined;
        data["AltinfixGbpAm"] = this.altinfixGbpAm ? this.altinfixGbpAm.toJSON() : <any>undefined;
        data["AltinfixGbpPm"] = this.altinfixGbpPm ? this.altinfixGbpPm.toJSON() : <any>undefined;
        data["PlatinfixAm"] = this.platinfixAm ? this.platinfixAm.toJSON() : <any>undefined;
        data["PlatinfixPm"] = this.platinfixPm ? this.platinfixPm.toJSON() : <any>undefined;
        data["PaladyumfixAm"] = this.paladyumfixAm ? this.paladyumfixAm.toJSON() : <any>undefined;
        data["PaladyumfixPm"] = this.paladyumfixPm ? this.paladyumfixPm.toJSON() : <any>undefined;
        data["Rodyumfix"] = this.rodyumfix ? this.rodyumfix.toJSON() : <any>undefined;
        data["Iko01"] = this.iko01 ? this.iko01.toJSON() : <any>undefined;
        data["Iko02"] = this.iko02 ? this.iko02.toJSON() : <any>undefined;
        data["Iko03"] = this.iko03 ? this.iko03.toJSON() : <any>undefined;
        data["Iko04"] = this.iko04 ? this.iko04.toJSON() : <any>undefined;
        data["Iko05"] = this.iko05 ? this.iko05.toJSON() : <any>undefined;
        data["Iko06"] = this.iko06 ? this.iko06.toJSON() : <any>undefined;
        data["Iko07"] = this.iko07 ? this.iko07.toJSON() : <any>undefined;
        data["Iko08"] = this.iko08 ? this.iko08.toJSON() : <any>undefined;
        data["Iko09"] = this.iko09 ? this.iko09.toJSON() : <any>undefined;
        data["Iko10"] = this.iko10 ? this.iko10.toJSON() : <any>undefined;
        data["Iko11"] = this.iko11 ? this.iko11.toJSON() : <any>undefined;
        data["Iko12"] = this.iko12 ? this.iko12.toJSON() : <any>undefined;
        return data;
    }
}

export interface IMarketModel {
    altin?: Altin;
    altingr?: Altingr;
    altinkgtl?: Altinkgtl;
    altinkgusd?: Altinkgusd;
    ons?: Ons;
    gumusserbest?: Gumusserbest;
    gumususd?: Gumususd;
    gumuseur?: Gumuseur;
    gumus?: Gumus;
    altinusd?: Altinusd;
    altincum?: Altincum;
    altingldt?: Altingldt;
    altingldy?: Altingldy;
    altingldc?: Altingldc;
    altinres?: Altinres;
    altinresk?: Altinresk;
    usd?: Usd;
    euro?: Euro;
    eurtry?: Eurtry;
    gbp?: Gbp;
    jpy?: Jpy;
    cad?: Cad;
    aud?: Aud;
    nok?: Nok;
    dkk?: Dkk;
    sek?: Sek;
    sar?: Sar;
    chf?: Chf;
    platin?: Platin;
    paladyum?: Paladyum;
    cyp?: Cyp;
    gumusfix?: Gumusfix;
    altinfixUsdAm?: AltinfixUsdAm;
    altinfixUsdPm?: AltinfixUsdPm;
    altinfixEurAm?: AltinfixEurAm;
    altinfixEurPm?: AltinfixEurPm;
    altinfixGbpAm?: AltinfixGbpAm;
    altinfixGbpPm?: AltinfixGbpPm;
    platinfixAm?: PlatinfixAm;
    platinfixPm?: PlatinfixPm;
    paladyumfixAm?: PaladyumfixAm;
    paladyumfixPm?: PaladyumfixPm;
    rodyumfix?: Rodyumfix;
    iko01?: Iko01;
    iko02?: Iko02;
    iko03?: Iko03;
    iko04?: Iko04;
    iko05?: Iko05;
    iko06?: Iko06;
    iko07?: Iko07;
    iko08?: Iko08;
    iko09?: Iko09;
    iko10?: Iko10;
    iko11?: Iko11;
    iko12?: Iko12;
}

export class MatriksEconomyNewsModel implements IMatriksEconomyNewsModel {
    data?: Data;
    error?: MatriksError;

    constructor(data?: IMatriksEconomyNewsModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["Data"] ? Data.fromJS(_data["Data"]) : <any>undefined;
            this.error = _data["Error"] ? MatriksError.fromJS(_data["Error"]) : <any>undefined;
        }
    }

    static fromJS(data: any): MatriksEconomyNewsModel {
        data = typeof data === 'object' ? data : {};
        let result = new MatriksEconomyNewsModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["Error"] = this.error ? this.error.toJSON() : <any>undefined;
        return data;
    }
}

export interface IMatriksEconomyNewsModel {
    data?: Data;
    error?: MatriksError;
}

export class MatriksError implements IMatriksError {
    flag?: string | undefined;
    type?: string | undefined;
    msg?: string | undefined;

    constructor(data?: IMatriksError) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.flag = _data["Flag"];
            this.type = _data["Type"];
            this.msg = _data["Msg"];
        }
    }

    static fromJS(data: any): MatriksError {
        data = typeof data === 'object' ? data : {};
        let result = new MatriksError();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Flag"] = this.flag;
        data["Type"] = this.type;
        data["Msg"] = this.msg;
        return data;
    }
}

export interface IMatriksError {
    flag?: string | undefined;
    type?: string | undefined;
    msg?: string | undefined;
}

export enum MatriksGraphType {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _8 = 8,
}

export class MatriksNewsModel implements IMatriksNewsModel {
    data?: MatriksNewsModelData[] | undefined;

    constructor(data?: IMatriksNewsModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["Data"])) {
                this.data = [] as any;
                for (let item of _data["Data"])
                    this.data!.push(MatriksNewsModelData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MatriksNewsModel {
        data = typeof data === 'object' ? data : {};
        let result = new MatriksNewsModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["Data"] = [];
            for (let item of this.data)
                data["Data"].push(item.toJSON());
        }
        return data;
    }
}

export interface IMatriksNewsModel {
    data?: MatriksNewsModelData[] | undefined;
}

export class MatriksNewsModelData implements IMatriksNewsModelData {
    id?: string | undefined;
    kaynak?: string | undefined;
    tip?: string | undefined;
    haberno?: string | undefined;
    baslik?: string | undefined;
    icerik?: string | undefined;
    tarih?: string | undefined;
    c?: string | undefined;

    constructor(data?: IMatriksNewsModelData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.kaynak = _data["Kaynak"];
            this.tip = _data["Tip"];
            this.haberno = _data["Haberno"];
            this.baslik = _data["Baslik"];
            this.icerik = _data["Icerik"];
            this.tarih = _data["Tarih"];
            this.c = _data["C"];
        }
    }

    static fromJS(data: any): MatriksNewsModelData {
        data = typeof data === 'object' ? data : {};
        let result = new MatriksNewsModelData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Kaynak"] = this.kaynak;
        data["Tip"] = this.tip;
        data["Haberno"] = this.haberno;
        data["Baslik"] = this.baslik;
        data["Icerik"] = this.icerik;
        data["Tarih"] = this.tarih;
        data["C"] = this.c;
        return data;
    }
}

export interface IMatriksNewsModelData {
    id?: string | undefined;
    kaynak?: string | undefined;
    tip?: string | undefined;
    haberno?: string | undefined;
    baslik?: string | undefined;
    icerik?: string | undefined;
    tarih?: string | undefined;
    c?: string | undefined;
}

export class Media implements IMedia {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    caption?: string | undefined;
    fileSize?: number;
    fileName?: string | undefined;
    mediaTypeId?: number;
    mediaType?: MediaType;

    constructor(data?: IMedia) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.createdOn = _data["CreatedOn"] ? moment(_data["CreatedOn"].toString()) : <any>undefined;
            this.createdById = _data["CreatedById"];
            this.createdBy = _data["CreatedBy"] ? User.fromJS(_data["CreatedBy"]) : <any>undefined;
            this.updatedOn = _data["UpdatedOn"] ? moment(_data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedById = _data["UpdatedById"];
            this.updatedBy = _data["UpdatedBy"] ? User.fromJS(_data["UpdatedBy"]) : <any>undefined;
            this.deletedOn = _data["DeletedOn"] ? moment(_data["DeletedOn"].toString()) : <any>undefined;
            this.deletedById = _data["DeletedById"];
            this.deletedBy = _data["DeletedBy"] ? User.fromJS(_data["DeletedBy"]) : <any>undefined;
            this.isDeleted = _data["IsDeleted"];
            this.caption = _data["Caption"];
            this.fileSize = _data["FileSize"];
            this.fileName = _data["FileName"];
            this.mediaTypeId = _data["MediaTypeId"];
            this.mediaType = _data["MediaType"] ? MediaType.fromJS(_data["MediaType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Media {
        data = typeof data === 'object' ? data : {};
        let result = new Media();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedById"] = this.createdById;
        data["CreatedBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["DeletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        data["DeletedById"] = this.deletedById;
        data["DeletedBy"] = this.deletedBy ? this.deletedBy.toJSON() : <any>undefined;
        data["IsDeleted"] = this.isDeleted;
        data["Caption"] = this.caption;
        data["FileSize"] = this.fileSize;
        data["FileName"] = this.fileName;
        data["MediaTypeId"] = this.mediaTypeId;
        data["MediaType"] = this.mediaType ? this.mediaType.toJSON() : <any>undefined;
        return data;
    }
}

export interface IMedia {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    caption?: string | undefined;
    fileSize?: number;
    fileName?: string | undefined;
    mediaTypeId?: number;
    mediaType?: MediaType;
}

export class MediaModel implements IMediaModel {
    url?: string | undefined;
    thumbnailUrl?: string | undefined;

    constructor(data?: IMediaModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.url = _data["Url"];
            this.thumbnailUrl = _data["ThumbnailUrl"];
        }
    }

    static fromJS(data: any): MediaModel {
        data = typeof data === 'object' ? data : {};
        let result = new MediaModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Url"] = this.url;
        data["ThumbnailUrl"] = this.thumbnailUrl;
        return data;
    }
}

export interface IMediaModel {
    url?: string | undefined;
    thumbnailUrl?: string | undefined;
}

export class MediaType implements IMediaType {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;

    constructor(data?: IMediaType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.createdOn = _data["CreatedOn"] ? moment(_data["CreatedOn"].toString()) : <any>undefined;
            this.createdById = _data["CreatedById"];
            this.createdBy = _data["CreatedBy"] ? User.fromJS(_data["CreatedBy"]) : <any>undefined;
            this.updatedOn = _data["UpdatedOn"] ? moment(_data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedById = _data["UpdatedById"];
            this.updatedBy = _data["UpdatedBy"] ? User.fromJS(_data["UpdatedBy"]) : <any>undefined;
            this.deletedOn = _data["DeletedOn"] ? moment(_data["DeletedOn"].toString()) : <any>undefined;
            this.deletedById = _data["DeletedById"];
            this.deletedBy = _data["DeletedBy"] ? User.fromJS(_data["DeletedBy"]) : <any>undefined;
            this.isDeleted = _data["IsDeleted"];
            this.code = _data["Code"];
            this.description = _data["Description"];
            this.displayOrder = _data["DisplayOrder"];
            this.isActive = _data["IsActive"];
        }
    }

    static fromJS(data: any): MediaType {
        data = typeof data === 'object' ? data : {};
        let result = new MediaType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedById"] = this.createdById;
        data["CreatedBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["DeletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        data["DeletedById"] = this.deletedById;
        data["DeletedBy"] = this.deletedBy ? this.deletedBy.toJSON() : <any>undefined;
        data["IsDeleted"] = this.isDeleted;
        data["Code"] = this.code;
        data["Description"] = this.description;
        data["DisplayOrder"] = this.displayOrder;
        data["IsActive"] = this.isActive;
        return data;
    }
}

export interface IMediaType {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;
}

export class MediaTypeModel implements IMediaTypeModel {
    id?: number;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;

    constructor(data?: IMediaTypeModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.code = _data["Code"];
            this.description = _data["Description"];
            this.displayOrder = _data["DisplayOrder"];
            this.isActive = _data["IsActive"];
        }
    }

    static fromJS(data: any): MediaTypeModel {
        data = typeof data === 'object' ? data : {};
        let result = new MediaTypeModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Code"] = this.code;
        data["Description"] = this.description;
        data["DisplayOrder"] = this.displayOrder;
        data["IsActive"] = this.isActive;
        return data;
    }
}

export interface IMediaTypeModel {
    id?: number;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;
}

export class MemberInfo implements IMemberInfo {
    memberType?: MemberTypes;
    declaringType?: Type;
    reflectedType?: Type;
    readonly name?: string | undefined;
    module?: Module;
    readonly customAttributes?: CustomAttributeData[] | undefined;
    readonly isCollectible?: boolean;
    readonly metadataToken?: number;

    constructor(data?: IMemberInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberType = _data["MemberType"];
            this.declaringType = _data["DeclaringType"] ? Type.fromJS(_data["DeclaringType"]) : <any>undefined;
            this.reflectedType = _data["ReflectedType"] ? Type.fromJS(_data["ReflectedType"]) : <any>undefined;
            (<any>this).name = _data["Name"];
            this.module = _data["Module"] ? Module.fromJS(_data["Module"]) : <any>undefined;
            if (Array.isArray(_data["CustomAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["CustomAttributes"])
                    (<any>this).customAttributes!.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).isCollectible = _data["IsCollectible"];
            (<any>this).metadataToken = _data["MetadataToken"];
        }
    }

    static fromJS(data: any): MemberInfo {
        data = typeof data === 'object' ? data : {};
        let result = new MemberInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["MemberType"] = this.memberType;
        data["DeclaringType"] = this.declaringType ? this.declaringType.toJSON() : <any>undefined;
        data["ReflectedType"] = this.reflectedType ? this.reflectedType.toJSON() : <any>undefined;
        data["Name"] = this.name;
        data["Module"] = this.module ? this.module.toJSON() : <any>undefined;
        if (Array.isArray(this.customAttributes)) {
            data["CustomAttributes"] = [];
            for (let item of this.customAttributes)
                data["CustomAttributes"].push(item.toJSON());
        }
        data["IsCollectible"] = this.isCollectible;
        data["MetadataToken"] = this.metadataToken;
        return data;
    }
}

export interface IMemberInfo {
    memberType?: MemberTypes;
    declaringType?: Type;
    reflectedType?: Type;
    name?: string | undefined;
    module?: Module;
    customAttributes?: CustomAttributeData[] | undefined;
    isCollectible?: boolean;
    metadataToken?: number;
}

export enum MemberTypes {
    _1 = 1,
    _2 = 2,
    _4 = 4,
    _8 = 8,
    _16 = 16,
    _32 = 32,
    _64 = 64,
    _128 = 128,
    _191 = 191,
}

export enum MethodAttributes {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _8 = 8,
    _16 = 16,
    _32 = 32,
    _64 = 64,
    _128 = 128,
    _256 = 256,
    _512 = 512,
    _1024 = 1024,
    _2048 = 2048,
    _4096 = 4096,
    _8192 = 8192,
    _16384 = 16384,
    _32768 = 32768,
    _53248 = 53248,
}

export class MethodBase implements IMethodBase {
    memberType?: MemberTypes;
    readonly name?: string | undefined;
    declaringType?: Type;
    reflectedType?: Type;
    module?: Module;
    readonly customAttributes?: CustomAttributeData[] | undefined;
    readonly isCollectible?: boolean;
    readonly metadataToken?: number;
    attributes?: MethodAttributes;
    methodImplementationFlags?: MethodImplAttributes;
    callingConvention?: CallingConventions;
    readonly isAbstract?: boolean;
    readonly isConstructor?: boolean;
    readonly isFinal?: boolean;
    readonly isHideBySig?: boolean;
    readonly isSpecialName?: boolean;
    readonly isStatic?: boolean;
    readonly isVirtual?: boolean;
    readonly isAssembly?: boolean;
    readonly isFamily?: boolean;
    readonly isFamilyAndAssembly?: boolean;
    readonly isFamilyOrAssembly?: boolean;
    readonly isPrivate?: boolean;
    readonly isPublic?: boolean;
    readonly isConstructedGenericMethod?: boolean;
    readonly isGenericMethod?: boolean;
    readonly isGenericMethodDefinition?: boolean;
    readonly containsGenericParameters?: boolean;
    methodHandle?: RuntimeMethodHandle;
    readonly isSecurityCritical?: boolean;
    readonly isSecuritySafeCritical?: boolean;
    readonly isSecurityTransparent?: boolean;

    constructor(data?: IMethodBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberType = _data["MemberType"];
            (<any>this).name = _data["Name"];
            this.declaringType = _data["DeclaringType"] ? Type.fromJS(_data["DeclaringType"]) : <any>undefined;
            this.reflectedType = _data["ReflectedType"] ? Type.fromJS(_data["ReflectedType"]) : <any>undefined;
            this.module = _data["Module"] ? Module.fromJS(_data["Module"]) : <any>undefined;
            if (Array.isArray(_data["CustomAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["CustomAttributes"])
                    (<any>this).customAttributes!.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).isCollectible = _data["IsCollectible"];
            (<any>this).metadataToken = _data["MetadataToken"];
            this.attributes = _data["Attributes"];
            this.methodImplementationFlags = _data["MethodImplementationFlags"];
            this.callingConvention = _data["CallingConvention"];
            (<any>this).isAbstract = _data["IsAbstract"];
            (<any>this).isConstructor = _data["IsConstructor"];
            (<any>this).isFinal = _data["IsFinal"];
            (<any>this).isHideBySig = _data["IsHideBySig"];
            (<any>this).isSpecialName = _data["IsSpecialName"];
            (<any>this).isStatic = _data["IsStatic"];
            (<any>this).isVirtual = _data["IsVirtual"];
            (<any>this).isAssembly = _data["IsAssembly"];
            (<any>this).isFamily = _data["IsFamily"];
            (<any>this).isFamilyAndAssembly = _data["IsFamilyAndAssembly"];
            (<any>this).isFamilyOrAssembly = _data["IsFamilyOrAssembly"];
            (<any>this).isPrivate = _data["IsPrivate"];
            (<any>this).isPublic = _data["IsPublic"];
            (<any>this).isConstructedGenericMethod = _data["IsConstructedGenericMethod"];
            (<any>this).isGenericMethod = _data["IsGenericMethod"];
            (<any>this).isGenericMethodDefinition = _data["IsGenericMethodDefinition"];
            (<any>this).containsGenericParameters = _data["ContainsGenericParameters"];
            this.methodHandle = _data["MethodHandle"] ? RuntimeMethodHandle.fromJS(_data["MethodHandle"]) : <any>undefined;
            (<any>this).isSecurityCritical = _data["IsSecurityCritical"];
            (<any>this).isSecuritySafeCritical = _data["IsSecuritySafeCritical"];
            (<any>this).isSecurityTransparent = _data["IsSecurityTransparent"];
        }
    }

    static fromJS(data: any): MethodBase {
        data = typeof data === 'object' ? data : {};
        let result = new MethodBase();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["MemberType"] = this.memberType;
        data["Name"] = this.name;
        data["DeclaringType"] = this.declaringType ? this.declaringType.toJSON() : <any>undefined;
        data["ReflectedType"] = this.reflectedType ? this.reflectedType.toJSON() : <any>undefined;
        data["Module"] = this.module ? this.module.toJSON() : <any>undefined;
        if (Array.isArray(this.customAttributes)) {
            data["CustomAttributes"] = [];
            for (let item of this.customAttributes)
                data["CustomAttributes"].push(item.toJSON());
        }
        data["IsCollectible"] = this.isCollectible;
        data["MetadataToken"] = this.metadataToken;
        data["Attributes"] = this.attributes;
        data["MethodImplementationFlags"] = this.methodImplementationFlags;
        data["CallingConvention"] = this.callingConvention;
        data["IsAbstract"] = this.isAbstract;
        data["IsConstructor"] = this.isConstructor;
        data["IsFinal"] = this.isFinal;
        data["IsHideBySig"] = this.isHideBySig;
        data["IsSpecialName"] = this.isSpecialName;
        data["IsStatic"] = this.isStatic;
        data["IsVirtual"] = this.isVirtual;
        data["IsAssembly"] = this.isAssembly;
        data["IsFamily"] = this.isFamily;
        data["IsFamilyAndAssembly"] = this.isFamilyAndAssembly;
        data["IsFamilyOrAssembly"] = this.isFamilyOrAssembly;
        data["IsPrivate"] = this.isPrivate;
        data["IsPublic"] = this.isPublic;
        data["IsConstructedGenericMethod"] = this.isConstructedGenericMethod;
        data["IsGenericMethod"] = this.isGenericMethod;
        data["IsGenericMethodDefinition"] = this.isGenericMethodDefinition;
        data["ContainsGenericParameters"] = this.containsGenericParameters;
        data["MethodHandle"] = this.methodHandle ? this.methodHandle.toJSON() : <any>undefined;
        data["IsSecurityCritical"] = this.isSecurityCritical;
        data["IsSecuritySafeCritical"] = this.isSecuritySafeCritical;
        data["IsSecurityTransparent"] = this.isSecurityTransparent;
        return data;
    }
}

export interface IMethodBase {
    memberType?: MemberTypes;
    name?: string | undefined;
    declaringType?: Type;
    reflectedType?: Type;
    module?: Module;
    customAttributes?: CustomAttributeData[] | undefined;
    isCollectible?: boolean;
    metadataToken?: number;
    attributes?: MethodAttributes;
    methodImplementationFlags?: MethodImplAttributes;
    callingConvention?: CallingConventions;
    isAbstract?: boolean;
    isConstructor?: boolean;
    isFinal?: boolean;
    isHideBySig?: boolean;
    isSpecialName?: boolean;
    isStatic?: boolean;
    isVirtual?: boolean;
    isAssembly?: boolean;
    isFamily?: boolean;
    isFamilyAndAssembly?: boolean;
    isFamilyOrAssembly?: boolean;
    isPrivate?: boolean;
    isPublic?: boolean;
    isConstructedGenericMethod?: boolean;
    isGenericMethod?: boolean;
    isGenericMethodDefinition?: boolean;
    containsGenericParameters?: boolean;
    methodHandle?: RuntimeMethodHandle;
    isSecurityCritical?: boolean;
    isSecuritySafeCritical?: boolean;
    isSecurityTransparent?: boolean;
}

export enum MethodImplAttributes {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _8 = 8,
    _16 = 16,
    _32 = 32,
    _64 = 64,
    _128 = 128,
    _256 = 256,
    _512 = 512,
    _4096 = 4096,
    _65535 = 65535,
}

export class MethodInfo implements IMethodInfo {
    readonly name?: string | undefined;
    declaringType?: Type;
    reflectedType?: Type;
    module?: Module;
    readonly customAttributes?: CustomAttributeData[] | undefined;
    readonly isCollectible?: boolean;
    readonly metadataToken?: number;
    attributes?: MethodAttributes;
    methodImplementationFlags?: MethodImplAttributes;
    callingConvention?: CallingConventions;
    readonly isAbstract?: boolean;
    readonly isConstructor?: boolean;
    readonly isFinal?: boolean;
    readonly isHideBySig?: boolean;
    readonly isSpecialName?: boolean;
    readonly isStatic?: boolean;
    readonly isVirtual?: boolean;
    readonly isAssembly?: boolean;
    readonly isFamily?: boolean;
    readonly isFamilyAndAssembly?: boolean;
    readonly isFamilyOrAssembly?: boolean;
    readonly isPrivate?: boolean;
    readonly isPublic?: boolean;
    readonly isConstructedGenericMethod?: boolean;
    readonly isGenericMethod?: boolean;
    readonly isGenericMethodDefinition?: boolean;
    readonly containsGenericParameters?: boolean;
    methodHandle?: RuntimeMethodHandle;
    readonly isSecurityCritical?: boolean;
    readonly isSecuritySafeCritical?: boolean;
    readonly isSecurityTransparent?: boolean;
    memberType?: MemberTypes;
    returnParameter?: ParameterInfo;
    returnType?: Type;
    returnTypeCustomAttributes?: ICustomAttributeProvider;

    constructor(data?: IMethodInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).name = _data["Name"];
            this.declaringType = _data["DeclaringType"] ? Type.fromJS(_data["DeclaringType"]) : <any>undefined;
            this.reflectedType = _data["ReflectedType"] ? Type.fromJS(_data["ReflectedType"]) : <any>undefined;
            this.module = _data["Module"] ? Module.fromJS(_data["Module"]) : <any>undefined;
            if (Array.isArray(_data["CustomAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["CustomAttributes"])
                    (<any>this).customAttributes!.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).isCollectible = _data["IsCollectible"];
            (<any>this).metadataToken = _data["MetadataToken"];
            this.attributes = _data["Attributes"];
            this.methodImplementationFlags = _data["MethodImplementationFlags"];
            this.callingConvention = _data["CallingConvention"];
            (<any>this).isAbstract = _data["IsAbstract"];
            (<any>this).isConstructor = _data["IsConstructor"];
            (<any>this).isFinal = _data["IsFinal"];
            (<any>this).isHideBySig = _data["IsHideBySig"];
            (<any>this).isSpecialName = _data["IsSpecialName"];
            (<any>this).isStatic = _data["IsStatic"];
            (<any>this).isVirtual = _data["IsVirtual"];
            (<any>this).isAssembly = _data["IsAssembly"];
            (<any>this).isFamily = _data["IsFamily"];
            (<any>this).isFamilyAndAssembly = _data["IsFamilyAndAssembly"];
            (<any>this).isFamilyOrAssembly = _data["IsFamilyOrAssembly"];
            (<any>this).isPrivate = _data["IsPrivate"];
            (<any>this).isPublic = _data["IsPublic"];
            (<any>this).isConstructedGenericMethod = _data["IsConstructedGenericMethod"];
            (<any>this).isGenericMethod = _data["IsGenericMethod"];
            (<any>this).isGenericMethodDefinition = _data["IsGenericMethodDefinition"];
            (<any>this).containsGenericParameters = _data["ContainsGenericParameters"];
            this.methodHandle = _data["MethodHandle"] ? RuntimeMethodHandle.fromJS(_data["MethodHandle"]) : <any>undefined;
            (<any>this).isSecurityCritical = _data["IsSecurityCritical"];
            (<any>this).isSecuritySafeCritical = _data["IsSecuritySafeCritical"];
            (<any>this).isSecurityTransparent = _data["IsSecurityTransparent"];
            this.memberType = _data["MemberType"];
            this.returnParameter = _data["ReturnParameter"] ? ParameterInfo.fromJS(_data["ReturnParameter"]) : <any>undefined;
            this.returnType = _data["ReturnType"] ? Type.fromJS(_data["ReturnType"]) : <any>undefined;
            this.returnTypeCustomAttributes = _data["ReturnTypeCustomAttributes"] ? ICustomAttributeProvider.fromJS(_data["ReturnTypeCustomAttributes"]) : <any>undefined;
        }
    }

    static fromJS(data: any): MethodInfo {
        data = typeof data === 'object' ? data : {};
        let result = new MethodInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Name"] = this.name;
        data["DeclaringType"] = this.declaringType ? this.declaringType.toJSON() : <any>undefined;
        data["ReflectedType"] = this.reflectedType ? this.reflectedType.toJSON() : <any>undefined;
        data["Module"] = this.module ? this.module.toJSON() : <any>undefined;
        if (Array.isArray(this.customAttributes)) {
            data["CustomAttributes"] = [];
            for (let item of this.customAttributes)
                data["CustomAttributes"].push(item.toJSON());
        }
        data["IsCollectible"] = this.isCollectible;
        data["MetadataToken"] = this.metadataToken;
        data["Attributes"] = this.attributes;
        data["MethodImplementationFlags"] = this.methodImplementationFlags;
        data["CallingConvention"] = this.callingConvention;
        data["IsAbstract"] = this.isAbstract;
        data["IsConstructor"] = this.isConstructor;
        data["IsFinal"] = this.isFinal;
        data["IsHideBySig"] = this.isHideBySig;
        data["IsSpecialName"] = this.isSpecialName;
        data["IsStatic"] = this.isStatic;
        data["IsVirtual"] = this.isVirtual;
        data["IsAssembly"] = this.isAssembly;
        data["IsFamily"] = this.isFamily;
        data["IsFamilyAndAssembly"] = this.isFamilyAndAssembly;
        data["IsFamilyOrAssembly"] = this.isFamilyOrAssembly;
        data["IsPrivate"] = this.isPrivate;
        data["IsPublic"] = this.isPublic;
        data["IsConstructedGenericMethod"] = this.isConstructedGenericMethod;
        data["IsGenericMethod"] = this.isGenericMethod;
        data["IsGenericMethodDefinition"] = this.isGenericMethodDefinition;
        data["ContainsGenericParameters"] = this.containsGenericParameters;
        data["MethodHandle"] = this.methodHandle ? this.methodHandle.toJSON() : <any>undefined;
        data["IsSecurityCritical"] = this.isSecurityCritical;
        data["IsSecuritySafeCritical"] = this.isSecuritySafeCritical;
        data["IsSecurityTransparent"] = this.isSecurityTransparent;
        data["MemberType"] = this.memberType;
        data["ReturnParameter"] = this.returnParameter ? this.returnParameter.toJSON() : <any>undefined;
        data["ReturnType"] = this.returnType ? this.returnType.toJSON() : <any>undefined;
        data["ReturnTypeCustomAttributes"] = this.returnTypeCustomAttributes ? this.returnTypeCustomAttributes.toJSON() : <any>undefined;
        return data;
    }
}

export interface IMethodInfo {
    name?: string | undefined;
    declaringType?: Type;
    reflectedType?: Type;
    module?: Module;
    customAttributes?: CustomAttributeData[] | undefined;
    isCollectible?: boolean;
    metadataToken?: number;
    attributes?: MethodAttributes;
    methodImplementationFlags?: MethodImplAttributes;
    callingConvention?: CallingConventions;
    isAbstract?: boolean;
    isConstructor?: boolean;
    isFinal?: boolean;
    isHideBySig?: boolean;
    isSpecialName?: boolean;
    isStatic?: boolean;
    isVirtual?: boolean;
    isAssembly?: boolean;
    isFamily?: boolean;
    isFamilyAndAssembly?: boolean;
    isFamilyOrAssembly?: boolean;
    isPrivate?: boolean;
    isPublic?: boolean;
    isConstructedGenericMethod?: boolean;
    isGenericMethod?: boolean;
    isGenericMethodDefinition?: boolean;
    containsGenericParameters?: boolean;
    methodHandle?: RuntimeMethodHandle;
    isSecurityCritical?: boolean;
    isSecuritySafeCritical?: boolean;
    isSecurityTransparent?: boolean;
    memberType?: MemberTypes;
    returnParameter?: ParameterInfo;
    returnType?: Type;
    returnTypeCustomAttributes?: ICustomAttributeProvider;
}

export class Module implements IModule {
    assembly?: Assembly;
    readonly fullyQualifiedName?: string | undefined;
    readonly name?: string | undefined;
    readonly mDStreamVersion?: number;
    readonly moduleVersionId?: string;
    readonly scopeName?: string | undefined;
    moduleHandle?: ModuleHandle;
    readonly customAttributes?: CustomAttributeData[] | undefined;
    readonly metadataToken?: number;

    constructor(data?: IModule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.assembly = _data["Assembly"] ? Assembly.fromJS(_data["Assembly"]) : <any>undefined;
            (<any>this).fullyQualifiedName = _data["FullyQualifiedName"];
            (<any>this).name = _data["Name"];
            (<any>this).mDStreamVersion = _data["MDStreamVersion"];
            (<any>this).moduleVersionId = _data["ModuleVersionId"];
            (<any>this).scopeName = _data["ScopeName"];
            this.moduleHandle = _data["ModuleHandle"] ? ModuleHandle.fromJS(_data["ModuleHandle"]) : <any>undefined;
            if (Array.isArray(_data["CustomAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["CustomAttributes"])
                    (<any>this).customAttributes!.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).metadataToken = _data["MetadataToken"];
        }
    }

    static fromJS(data: any): Module {
        data = typeof data === 'object' ? data : {};
        let result = new Module();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Assembly"] = this.assembly ? this.assembly.toJSON() : <any>undefined;
        data["FullyQualifiedName"] = this.fullyQualifiedName;
        data["Name"] = this.name;
        data["MDStreamVersion"] = this.mDStreamVersion;
        data["ModuleVersionId"] = this.moduleVersionId;
        data["ScopeName"] = this.scopeName;
        data["ModuleHandle"] = this.moduleHandle ? this.moduleHandle.toJSON() : <any>undefined;
        if (Array.isArray(this.customAttributes)) {
            data["CustomAttributes"] = [];
            for (let item of this.customAttributes)
                data["CustomAttributes"].push(item.toJSON());
        }
        data["MetadataToken"] = this.metadataToken;
        return data;
    }
}

export interface IModule {
    assembly?: Assembly;
    fullyQualifiedName?: string | undefined;
    name?: string | undefined;
    mDStreamVersion?: number;
    moduleVersionId?: string;
    scopeName?: string | undefined;
    moduleHandle?: ModuleHandle;
    customAttributes?: CustomAttributeData[] | undefined;
    metadataToken?: number;
}

export class ModuleHandle implements IModuleHandle {
    readonly mDStreamVersion?: number;

    constructor(data?: IModuleHandle) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).mDStreamVersion = _data["MDStreamVersion"];
        }
    }

    static fromJS(data: any): ModuleHandle {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleHandle();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["MDStreamVersion"] = this.mDStreamVersion;
        return data;
    }
}

export interface IModuleHandle {
    mDStreamVersion?: number;
}

export class Neighborhood implements INeighborhood {
    id?: number;
    districtId?: number;
    district?: District;
    name?: string | undefined;
    zipCode?: string | undefined;

    constructor(data?: INeighborhood) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.districtId = _data["DistrictId"];
            this.district = _data["District"] ? District.fromJS(_data["District"]) : <any>undefined;
            this.name = _data["Name"];
            this.zipCode = _data["ZipCode"];
        }
    }

    static fromJS(data: any): Neighborhood {
        data = typeof data === 'object' ? data : {};
        let result = new Neighborhood();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["DistrictId"] = this.districtId;
        data["District"] = this.district ? this.district.toJSON() : <any>undefined;
        data["Name"] = this.name;
        data["ZipCode"] = this.zipCode;
        return data;
    }
}

export interface INeighborhood {
    id?: number;
    districtId?: number;
    district?: District;
    name?: string | undefined;
    zipCode?: string | undefined;
}

export class Nok implements INok {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: INok) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): Nok {
        data = typeof data === 'object' ? data : {};
        let result = new Nok();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface INok {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class NotificationModel implements INotificationModel {
    id?: number;
    title?: string | undefined;
    body?: string | undefined;
    data?: string | undefined;
    groupId?: number | undefined;
    group?: GroupModel;
    userId?: number | undefined;
    user?: UserModel;
    sendDate?: moment.Moment;
    sendFailCount?: number;
    typeId?: number;
    type?: NotificationTypeModel;
    isSent?: boolean;
    isDeleted?: boolean;

    constructor(data?: INotificationModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.title = _data["Title"];
            this.body = _data["Body"];
            this.data = _data["Data"];
            this.groupId = _data["GroupId"];
            this.group = _data["Group"] ? GroupModel.fromJS(_data["Group"]) : <any>undefined;
            this.userId = _data["UserId"];
            this.user = _data["User"] ? UserModel.fromJS(_data["User"]) : <any>undefined;
            this.sendDate = _data["SendDate"] ? moment(_data["SendDate"].toString()) : <any>undefined;
            this.sendFailCount = _data["SendFailCount"];
            this.typeId = _data["TypeId"];
            this.type = _data["Type"] ? NotificationTypeModel.fromJS(_data["Type"]) : <any>undefined;
            this.isSent = _data["IsSent"];
            this.isDeleted = _data["IsDeleted"];
        }
    }

    static fromJS(data: any): NotificationModel {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Title"] = this.title;
        data["Body"] = this.body;
        data["Data"] = this.data;
        data["GroupId"] = this.groupId;
        data["Group"] = this.group ? this.group.toJSON() : <any>undefined;
        data["UserId"] = this.userId;
        data["User"] = this.user ? this.user.toJSON() : <any>undefined;
        data["SendDate"] = this.sendDate ? this.sendDate.toISOString() : <any>undefined;
        data["SendFailCount"] = this.sendFailCount;
        data["TypeId"] = this.typeId;
        data["Type"] = this.type ? this.type.toJSON() : <any>undefined;
        data["IsSent"] = this.isSent;
        data["IsDeleted"] = this.isDeleted;
        return data;
    }
}

export interface INotificationModel {
    id?: number;
    title?: string | undefined;
    body?: string | undefined;
    data?: string | undefined;
    groupId?: number | undefined;
    group?: GroupModel;
    userId?: number | undefined;
    user?: UserModel;
    sendDate?: moment.Moment;
    sendFailCount?: number;
    typeId?: number;
    type?: NotificationTypeModel;
    isSent?: boolean;
    isDeleted?: boolean;
}

export class NotificationTypeModel implements INotificationTypeModel {
    id?: number;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;

    constructor(data?: INotificationTypeModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.code = _data["Code"];
            this.description = _data["Description"];
            this.displayOrder = _data["DisplayOrder"];
            this.isActive = _data["IsActive"];
        }
    }

    static fromJS(data: any): NotificationTypeModel {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationTypeModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Code"] = this.code;
        data["Description"] = this.description;
        data["DisplayOrder"] = this.displayOrder;
        data["IsActive"] = this.isActive;
        return data;
    }
}

export interface INotificationTypeModel {
    id?: number;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;
}

export class Ons implements IOns {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IOns) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): Ons {
        data = typeof data === 'object' ? data : {};
        let result = new Ons();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IOns {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class OrderItemModel implements IOrderItemModel {
    id?: number;
    orderId?: number;
    productId?: number;
    quantity?: number;
    productPrice?: number;
    amount?: number;

    constructor(data?: IOrderItemModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.orderId = _data["OrderId"];
            this.productId = _data["ProductId"];
            this.quantity = _data["Quantity"];
            this.productPrice = _data["ProductPrice"];
            this.amount = _data["Amount"];
        }
    }

    static fromJS(data: any): OrderItemModel {
        data = typeof data === 'object' ? data : {};
        let result = new OrderItemModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["OrderId"] = this.orderId;
        data["ProductId"] = this.productId;
        data["Quantity"] = this.quantity;
        data["ProductPrice"] = this.productPrice;
        data["Amount"] = this.amount;
        return data;
    }
}

export interface IOrderItemModel {
    id?: number;
    orderId?: number;
    productId?: number;
    quantity?: number;
    productPrice?: number;
    amount?: number;
}

export class OrderStatusModel implements IOrderStatusModel {
    id?: number;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;

    constructor(data?: IOrderStatusModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.code = _data["Code"];
            this.description = _data["Description"];
            this.displayOrder = _data["DisplayOrder"];
            this.isActive = _data["IsActive"];
        }
    }

    static fromJS(data: any): OrderStatusModel {
        data = typeof data === 'object' ? data : {};
        let result = new OrderStatusModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Code"] = this.code;
        data["Description"] = this.description;
        data["DisplayOrder"] = this.displayOrder;
        data["IsActive"] = this.isActive;
        return data;
    }
}

export interface IOrderStatusModel {
    id?: number;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;
}

export class Paladyum implements IPaladyum {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IPaladyum) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): Paladyum {
        data = typeof data === 'object' ? data : {};
        let result = new Paladyum();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IPaladyum {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class PaladyumfixAm implements IPaladyumfixAm {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IPaladyumfixAm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): PaladyumfixAm {
        data = typeof data === 'object' ? data : {};
        let result = new PaladyumfixAm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IPaladyumfixAm {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class PaladyumfixPm implements IPaladyumfixPm {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IPaladyumfixPm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): PaladyumfixPm {
        data = typeof data === 'object' ? data : {};
        let result = new PaladyumfixPm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IPaladyumfixPm {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export enum ParameterAttributes {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _4 = 4,
    _8 = 8,
    _16 = 16,
    _4096 = 4096,
    _8192 = 8192,
    _16384 = 16384,
    _32768 = 32768,
    _61440 = 61440,
}

export class ParameterInfo implements IParameterInfo {
    attributes?: ParameterAttributes;
    member?: MemberInfo;
    readonly name?: string | undefined;
    parameterType?: Type;
    readonly position?: number;
    readonly isIn?: boolean;
    readonly isLcid?: boolean;
    readonly isOptional?: boolean;
    readonly isOut?: boolean;
    readonly isRetval?: boolean;
    readonly defaultValue?: any | undefined;
    readonly rawDefaultValue?: any | undefined;
    readonly hasDefaultValue?: boolean;
    readonly customAttributes?: CustomAttributeData[] | undefined;
    readonly metadataToken?: number;

    constructor(data?: IParameterInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.attributes = _data["Attributes"];
            this.member = _data["Member"] ? MemberInfo.fromJS(_data["Member"]) : <any>undefined;
            (<any>this).name = _data["Name"];
            this.parameterType = _data["ParameterType"] ? Type.fromJS(_data["ParameterType"]) : <any>undefined;
            (<any>this).position = _data["Position"];
            (<any>this).isIn = _data["IsIn"];
            (<any>this).isLcid = _data["IsLcid"];
            (<any>this).isOptional = _data["IsOptional"];
            (<any>this).isOut = _data["IsOut"];
            (<any>this).isRetval = _data["IsRetval"];
            (<any>this).defaultValue = _data["DefaultValue"];
            (<any>this).rawDefaultValue = _data["RawDefaultValue"];
            (<any>this).hasDefaultValue = _data["HasDefaultValue"];
            if (Array.isArray(_data["CustomAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["CustomAttributes"])
                    (<any>this).customAttributes!.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).metadataToken = _data["MetadataToken"];
        }
    }

    static fromJS(data: any): ParameterInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ParameterInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Attributes"] = this.attributes;
        data["Member"] = this.member ? this.member.toJSON() : <any>undefined;
        data["Name"] = this.name;
        data["ParameterType"] = this.parameterType ? this.parameterType.toJSON() : <any>undefined;
        data["Position"] = this.position;
        data["IsIn"] = this.isIn;
        data["IsLcid"] = this.isLcid;
        data["IsOptional"] = this.isOptional;
        data["IsOut"] = this.isOut;
        data["IsRetval"] = this.isRetval;
        data["DefaultValue"] = this.defaultValue;
        data["RawDefaultValue"] = this.rawDefaultValue;
        data["HasDefaultValue"] = this.hasDefaultValue;
        if (Array.isArray(this.customAttributes)) {
            data["CustomAttributes"] = [];
            for (let item of this.customAttributes)
                data["CustomAttributes"].push(item.toJSON());
        }
        data["MetadataToken"] = this.metadataToken;
        return data;
    }
}

export interface IParameterInfo {
    attributes?: ParameterAttributes;
    member?: MemberInfo;
    name?: string | undefined;
    parameterType?: Type;
    position?: number;
    isIn?: boolean;
    isLcid?: boolean;
    isOptional?: boolean;
    isOut?: boolean;
    isRetval?: boolean;
    defaultValue?: any | undefined;
    rawDefaultValue?: any | undefined;
    hasDefaultValue?: boolean;
    customAttributes?: CustomAttributeData[] | undefined;
    metadataToken?: number;
}

export enum PaymentStatusEnum {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _8 = 8,
    _9 = 9,
}

export class PaymentType implements IPaymentType {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;

    constructor(data?: IPaymentType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.createdOn = _data["CreatedOn"] ? moment(_data["CreatedOn"].toString()) : <any>undefined;
            this.createdById = _data["CreatedById"];
            this.createdBy = _data["CreatedBy"] ? User.fromJS(_data["CreatedBy"]) : <any>undefined;
            this.updatedOn = _data["UpdatedOn"] ? moment(_data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedById = _data["UpdatedById"];
            this.updatedBy = _data["UpdatedBy"] ? User.fromJS(_data["UpdatedBy"]) : <any>undefined;
            this.deletedOn = _data["DeletedOn"] ? moment(_data["DeletedOn"].toString()) : <any>undefined;
            this.deletedById = _data["DeletedById"];
            this.deletedBy = _data["DeletedBy"] ? User.fromJS(_data["DeletedBy"]) : <any>undefined;
            this.isDeleted = _data["IsDeleted"];
            this.code = _data["Code"];
            this.description = _data["Description"];
            this.displayOrder = _data["DisplayOrder"];
            this.isActive = _data["IsActive"];
        }
    }

    static fromJS(data: any): PaymentType {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedById"] = this.createdById;
        data["CreatedBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["DeletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        data["DeletedById"] = this.deletedById;
        data["DeletedBy"] = this.deletedBy ? this.deletedBy.toJSON() : <any>undefined;
        data["IsDeleted"] = this.isDeleted;
        data["Code"] = this.code;
        data["Description"] = this.description;
        data["DisplayOrder"] = this.displayOrder;
        data["IsActive"] = this.isActive;
        return data;
    }
}

export interface IPaymentType {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;
}

export enum PaymentTypeEnum {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _8 = 8,
    _9 = 9,
    _10 = 10,
    _11 = 11,
}

export class PaymentTypeModel implements IPaymentTypeModel {
    id?: number;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;

    constructor(data?: IPaymentTypeModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.code = _data["Code"];
            this.description = _data["Description"];
            this.displayOrder = _data["DisplayOrder"];
            this.isActive = _data["IsActive"];
        }
    }

    static fromJS(data: any): PaymentTypeModel {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentTypeModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Code"] = this.code;
        data["Description"] = this.description;
        data["DisplayOrder"] = this.displayOrder;
        data["IsActive"] = this.isActive;
        return data;
    }
}

export interface IPaymentTypeModel {
    id?: number;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;
}

export class Platin implements IPlatin {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IPlatin) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): Platin {
        data = typeof data === 'object' ? data : {};
        let result = new Platin();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IPlatin {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class PlatinfixAm implements IPlatinfixAm {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IPlatinfixAm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): PlatinfixAm {
        data = typeof data === 'object' ? data : {};
        let result = new PlatinfixAm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IPlatinfixAm {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class PlatinfixPm implements IPlatinfixPm {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IPlatinfixPm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): PlatinfixPm {
        data = typeof data === 'object' ? data : {};
        let result = new PlatinfixPm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IPlatinfixPm {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class PostCategoryModel implements IPostCategoryModel {
    id?: number;
    name?: string | undefined;
    mediaId?: number | undefined;
    media?: MediaModel;

    constructor(data?: IPostCategoryModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.name = _data["Name"];
            this.mediaId = _data["MediaId"];
            this.media = _data["Media"] ? MediaModel.fromJS(_data["Media"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PostCategoryModel {
        data = typeof data === 'object' ? data : {};
        let result = new PostCategoryModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Name"] = this.name;
        data["MediaId"] = this.mediaId;
        data["Media"] = this.media ? this.media.toJSON() : <any>undefined;
        return data;
    }
}

export interface IPostCategoryModel {
    id?: number;
    name?: string | undefined;
    mediaId?: number | undefined;
    media?: MediaModel;
}

export class PostModel implements IPostModel {
    title!: string;
    subTitle?: string | undefined;
    slug?: string | undefined;
    metaKeywords?: string | undefined;
    metaDescription?: string | undefined;
    body?: string | undefined;
    mediaId?: number | undefined;
    media?: MediaModel;
    isPublished?: boolean;
    publishedOn?: moment.Moment | undefined;
    publishedTill?: moment.Moment | undefined;
    categoryId?: number | undefined;
    category?: PostCategoryModel;

    constructor(data?: IPostModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["Title"];
            this.subTitle = _data["SubTitle"];
            this.slug = _data["Slug"];
            this.metaKeywords = _data["MetaKeywords"];
            this.metaDescription = _data["MetaDescription"];
            this.body = _data["Body"];
            this.mediaId = _data["MediaId"];
            this.media = _data["Media"] ? MediaModel.fromJS(_data["Media"]) : <any>undefined;
            this.isPublished = _data["IsPublished"];
            this.publishedOn = _data["PublishedOn"] ? moment(_data["PublishedOn"].toString()) : <any>undefined;
            this.publishedTill = _data["PublishedTill"] ? moment(_data["PublishedTill"].toString()) : <any>undefined;
            this.categoryId = _data["CategoryId"];
            this.category = _data["Category"] ? PostCategoryModel.fromJS(_data["Category"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PostModel {
        data = typeof data === 'object' ? data : {};
        let result = new PostModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Title"] = this.title;
        data["SubTitle"] = this.subTitle;
        data["Slug"] = this.slug;
        data["MetaKeywords"] = this.metaKeywords;
        data["MetaDescription"] = this.metaDescription;
        data["Body"] = this.body;
        data["MediaId"] = this.mediaId;
        data["Media"] = this.media ? this.media.toJSON() : <any>undefined;
        data["IsPublished"] = this.isPublished;
        data["PublishedOn"] = this.publishedOn ? this.publishedOn.toISOString() : <any>undefined;
        data["PublishedTill"] = this.publishedTill ? this.publishedTill.toISOString() : <any>undefined;
        data["CategoryId"] = this.categoryId;
        data["Category"] = this.category ? this.category.toJSON() : <any>undefined;
        return data;
    }
}

export interface IPostModel {
    title: string;
    subTitle?: string | undefined;
    slug?: string | undefined;
    metaKeywords?: string | undefined;
    metaDescription?: string | undefined;
    body?: string | undefined;
    mediaId?: number | undefined;
    media?: MediaModel;
    isPublished?: boolean;
    publishedOn?: moment.Moment | undefined;
    publishedTill?: moment.Moment | undefined;
    categoryId?: number | undefined;
    category?: PostCategoryModel;
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data;
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
}

export class Product implements IProduct {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    code?: string | undefined;
    barcode?: string | undefined;
    name?: string | undefined;
    normalizedName?: string | undefined;
    description?: string | undefined;
    specification?: string | undefined;
    brand?: string | undefined;
    price?: number;
    oldPrice?: number | undefined;
    specialPrice?: number | undefined;
    specialPriceStart?: moment.Moment | undefined;
    specialPriceEnd?: moment.Moment | undefined;
    stockQuantity?: number;
    displayOrder?: number;
    isFeatured?: boolean;
    isPublished?: boolean;
    unitId?: number;
    unit?: ProductUnit;
    productTypeId?: number;
    productType?: ProductType;
    mediaId?: number | undefined;
    media?: Media;
    yatirimimId?: number | undefined;
    readonly categories?: ProductCategory[] | undefined;

    constructor(data?: IProduct) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.createdOn = _data["CreatedOn"] ? moment(_data["CreatedOn"].toString()) : <any>undefined;
            this.createdById = _data["CreatedById"];
            this.createdBy = _data["CreatedBy"] ? User.fromJS(_data["CreatedBy"]) : <any>undefined;
            this.updatedOn = _data["UpdatedOn"] ? moment(_data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedById = _data["UpdatedById"];
            this.updatedBy = _data["UpdatedBy"] ? User.fromJS(_data["UpdatedBy"]) : <any>undefined;
            this.deletedOn = _data["DeletedOn"] ? moment(_data["DeletedOn"].toString()) : <any>undefined;
            this.deletedById = _data["DeletedById"];
            this.deletedBy = _data["DeletedBy"] ? User.fromJS(_data["DeletedBy"]) : <any>undefined;
            this.isDeleted = _data["IsDeleted"];
            this.code = _data["Code"];
            this.barcode = _data["Barcode"];
            this.name = _data["Name"];
            this.normalizedName = _data["NormalizedName"];
            this.description = _data["Description"];
            this.specification = _data["Specification"];
            this.brand = _data["Brand"];
            this.price = _data["Price"];
            this.oldPrice = _data["OldPrice"];
            this.specialPrice = _data["SpecialPrice"];
            this.specialPriceStart = _data["SpecialPriceStart"] ? moment(_data["SpecialPriceStart"].toString()) : <any>undefined;
            this.specialPriceEnd = _data["SpecialPriceEnd"] ? moment(_data["SpecialPriceEnd"].toString()) : <any>undefined;
            this.stockQuantity = _data["StockQuantity"];
            this.displayOrder = _data["DisplayOrder"];
            this.isFeatured = _data["IsFeatured"];
            this.isPublished = _data["IsPublished"];
            this.unitId = _data["UnitId"];
            this.unit = _data["Unit"] ? ProductUnit.fromJS(_data["Unit"]) : <any>undefined;
            this.productTypeId = _data["ProductTypeId"];
            this.productType = _data["ProductType"] ? ProductType.fromJS(_data["ProductType"]) : <any>undefined;
            this.mediaId = _data["MediaId"];
            this.media = _data["Media"] ? Media.fromJS(_data["Media"]) : <any>undefined;
            this.yatirimimId = _data["YatirimimId"];
            if (Array.isArray(_data["Categories"])) {
                (<any>this).categories = [] as any;
                for (let item of _data["Categories"])
                    (<any>this).categories!.push(ProductCategory.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Product {
        data = typeof data === 'object' ? data : {};
        let result = new Product();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedById"] = this.createdById;
        data["CreatedBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["DeletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        data["DeletedById"] = this.deletedById;
        data["DeletedBy"] = this.deletedBy ? this.deletedBy.toJSON() : <any>undefined;
        data["IsDeleted"] = this.isDeleted;
        data["Code"] = this.code;
        data["Barcode"] = this.barcode;
        data["Name"] = this.name;
        data["NormalizedName"] = this.normalizedName;
        data["Description"] = this.description;
        data["Specification"] = this.specification;
        data["Brand"] = this.brand;
        data["Price"] = this.price;
        data["OldPrice"] = this.oldPrice;
        data["SpecialPrice"] = this.specialPrice;
        data["SpecialPriceStart"] = this.specialPriceStart ? this.specialPriceStart.toISOString() : <any>undefined;
        data["SpecialPriceEnd"] = this.specialPriceEnd ? this.specialPriceEnd.toISOString() : <any>undefined;
        data["StockQuantity"] = this.stockQuantity;
        data["DisplayOrder"] = this.displayOrder;
        data["IsFeatured"] = this.isFeatured;
        data["IsPublished"] = this.isPublished;
        data["UnitId"] = this.unitId;
        data["Unit"] = this.unit ? this.unit.toJSON() : <any>undefined;
        data["ProductTypeId"] = this.productTypeId;
        data["ProductType"] = this.productType ? this.productType.toJSON() : <any>undefined;
        data["MediaId"] = this.mediaId;
        data["Media"] = this.media ? this.media.toJSON() : <any>undefined;
        data["YatirimimId"] = this.yatirimimId;
        if (Array.isArray(this.categories)) {
            data["Categories"] = [];
            for (let item of this.categories)
                data["Categories"].push(item.toJSON());
        }
        return data;
    }
}

export interface IProduct {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    code?: string | undefined;
    barcode?: string | undefined;
    name?: string | undefined;
    normalizedName?: string | undefined;
    description?: string | undefined;
    specification?: string | undefined;
    brand?: string | undefined;
    price?: number;
    oldPrice?: number | undefined;
    specialPrice?: number | undefined;
    specialPriceStart?: moment.Moment | undefined;
    specialPriceEnd?: moment.Moment | undefined;
    stockQuantity?: number;
    displayOrder?: number;
    isFeatured?: boolean;
    isPublished?: boolean;
    unitId?: number;
    unit?: ProductUnit;
    productTypeId?: number;
    productType?: ProductType;
    mediaId?: number | undefined;
    media?: Media;
    yatirimimId?: number | undefined;
    categories?: ProductCategory[] | undefined;
}

export class ProductCategory implements IProductCategory {
    id?: number;
    productId?: number;
    product?: Product;
    categoryId?: number;
    category?: Category;

    constructor(data?: IProductCategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.productId = _data["ProductId"];
            this.product = _data["Product"] ? Product.fromJS(_data["Product"]) : <any>undefined;
            this.categoryId = _data["CategoryId"];
            this.category = _data["Category"] ? Category.fromJS(_data["Category"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ProductCategory {
        data = typeof data === 'object' ? data : {};
        let result = new ProductCategory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["ProductId"] = this.productId;
        data["Product"] = this.product ? this.product.toJSON() : <any>undefined;
        data["CategoryId"] = this.categoryId;
        data["Category"] = this.category ? this.category.toJSON() : <any>undefined;
        return data;
    }
}

export interface IProductCategory {
    id?: number;
    productId?: number;
    product?: Product;
    categoryId?: number;
    category?: Category;
}

export class ProductType implements IProductType {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;

    constructor(data?: IProductType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.createdOn = _data["CreatedOn"] ? moment(_data["CreatedOn"].toString()) : <any>undefined;
            this.createdById = _data["CreatedById"];
            this.createdBy = _data["CreatedBy"] ? User.fromJS(_data["CreatedBy"]) : <any>undefined;
            this.updatedOn = _data["UpdatedOn"] ? moment(_data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedById = _data["UpdatedById"];
            this.updatedBy = _data["UpdatedBy"] ? User.fromJS(_data["UpdatedBy"]) : <any>undefined;
            this.deletedOn = _data["DeletedOn"] ? moment(_data["DeletedOn"].toString()) : <any>undefined;
            this.deletedById = _data["DeletedById"];
            this.deletedBy = _data["DeletedBy"] ? User.fromJS(_data["DeletedBy"]) : <any>undefined;
            this.isDeleted = _data["IsDeleted"];
            this.code = _data["Code"];
            this.description = _data["Description"];
            this.displayOrder = _data["DisplayOrder"];
            this.isActive = _data["IsActive"];
        }
    }

    static fromJS(data: any): ProductType {
        data = typeof data === 'object' ? data : {};
        let result = new ProductType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedById"] = this.createdById;
        data["CreatedBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["DeletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        data["DeletedById"] = this.deletedById;
        data["DeletedBy"] = this.deletedBy ? this.deletedBy.toJSON() : <any>undefined;
        data["IsDeleted"] = this.isDeleted;
        data["Code"] = this.code;
        data["Description"] = this.description;
        data["DisplayOrder"] = this.displayOrder;
        data["IsActive"] = this.isActive;
        return data;
    }
}

export interface IProductType {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;
}

export class ProductTypeModel implements IProductTypeModel {
    id?: number;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;

    constructor(data?: IProductTypeModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.code = _data["Code"];
            this.description = _data["Description"];
            this.displayOrder = _data["DisplayOrder"];
            this.isActive = _data["IsActive"];
        }
    }

    static fromJS(data: any): ProductTypeModel {
        data = typeof data === 'object' ? data : {};
        let result = new ProductTypeModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Code"] = this.code;
        data["Description"] = this.description;
        data["DisplayOrder"] = this.displayOrder;
        data["IsActive"] = this.isActive;
        return data;
    }
}

export interface IProductTypeModel {
    id?: number;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;
}

export class ProductUnit implements IProductUnit {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    code?: string | undefined;
    short?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;

    constructor(data?: IProductUnit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.createdOn = _data["CreatedOn"] ? moment(_data["CreatedOn"].toString()) : <any>undefined;
            this.createdById = _data["CreatedById"];
            this.createdBy = _data["CreatedBy"] ? User.fromJS(_data["CreatedBy"]) : <any>undefined;
            this.updatedOn = _data["UpdatedOn"] ? moment(_data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedById = _data["UpdatedById"];
            this.updatedBy = _data["UpdatedBy"] ? User.fromJS(_data["UpdatedBy"]) : <any>undefined;
            this.deletedOn = _data["DeletedOn"] ? moment(_data["DeletedOn"].toString()) : <any>undefined;
            this.deletedById = _data["DeletedById"];
            this.deletedBy = _data["DeletedBy"] ? User.fromJS(_data["DeletedBy"]) : <any>undefined;
            this.isDeleted = _data["IsDeleted"];
            this.code = _data["Code"];
            this.short = _data["Short"];
            this.description = _data["Description"];
            this.displayOrder = _data["DisplayOrder"];
            this.isActive = _data["IsActive"];
        }
    }

    static fromJS(data: any): ProductUnit {
        data = typeof data === 'object' ? data : {};
        let result = new ProductUnit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedById"] = this.createdById;
        data["CreatedBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["DeletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        data["DeletedById"] = this.deletedById;
        data["DeletedBy"] = this.deletedBy ? this.deletedBy.toJSON() : <any>undefined;
        data["IsDeleted"] = this.isDeleted;
        data["Code"] = this.code;
        data["Short"] = this.short;
        data["Description"] = this.description;
        data["DisplayOrder"] = this.displayOrder;
        data["IsActive"] = this.isActive;
        return data;
    }
}

export interface IProductUnit {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    code?: string | undefined;
    short?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;
}

export class ProductUnitModel implements IProductUnitModel {
    id?: number;
    code?: string | undefined;
    short?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;

    constructor(data?: IProductUnitModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.code = _data["Code"];
            this.short = _data["Short"];
            this.description = _data["Description"];
            this.displayOrder = _data["DisplayOrder"];
            this.isActive = _data["IsActive"];
        }
    }

    static fromJS(data: any): ProductUnitModel {
        data = typeof data === 'object' ? data : {};
        let result = new ProductUnitModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Code"] = this.code;
        data["Short"] = this.short;
        data["Description"] = this.description;
        data["DisplayOrder"] = this.displayOrder;
        data["IsActive"] = this.isActive;
        return data;
    }
}

export interface IProductUnitModel {
    id?: number;
    code?: string | undefined;
    short?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;
}

export enum PropertyAttributes {
    _0 = 0,
    _512 = 512,
    _1024 = 1024,
    _4096 = 4096,
    _8192 = 8192,
    _16384 = 16384,
    _32768 = 32768,
    _62464 = 62464,
}

export class PropertyInfo implements IPropertyInfo {
    readonly name?: string | undefined;
    declaringType?: Type;
    reflectedType?: Type;
    module?: Module;
    readonly customAttributes?: CustomAttributeData[] | undefined;
    readonly isCollectible?: boolean;
    readonly metadataToken?: number;
    memberType?: MemberTypes;
    propertyType?: Type;
    attributes?: PropertyAttributes;
    readonly isSpecialName?: boolean;
    readonly canRead?: boolean;
    readonly canWrite?: boolean;
    getMethod?: MethodInfo;
    setMethod?: MethodInfo;

    constructor(data?: IPropertyInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).name = _data["Name"];
            this.declaringType = _data["DeclaringType"] ? Type.fromJS(_data["DeclaringType"]) : <any>undefined;
            this.reflectedType = _data["ReflectedType"] ? Type.fromJS(_data["ReflectedType"]) : <any>undefined;
            this.module = _data["Module"] ? Module.fromJS(_data["Module"]) : <any>undefined;
            if (Array.isArray(_data["CustomAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["CustomAttributes"])
                    (<any>this).customAttributes!.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).isCollectible = _data["IsCollectible"];
            (<any>this).metadataToken = _data["MetadataToken"];
            this.memberType = _data["MemberType"];
            this.propertyType = _data["PropertyType"] ? Type.fromJS(_data["PropertyType"]) : <any>undefined;
            this.attributes = _data["Attributes"];
            (<any>this).isSpecialName = _data["IsSpecialName"];
            (<any>this).canRead = _data["CanRead"];
            (<any>this).canWrite = _data["CanWrite"];
            this.getMethod = _data["GetMethod"] ? MethodInfo.fromJS(_data["GetMethod"]) : <any>undefined;
            this.setMethod = _data["SetMethod"] ? MethodInfo.fromJS(_data["SetMethod"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PropertyInfo {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Name"] = this.name;
        data["DeclaringType"] = this.declaringType ? this.declaringType.toJSON() : <any>undefined;
        data["ReflectedType"] = this.reflectedType ? this.reflectedType.toJSON() : <any>undefined;
        data["Module"] = this.module ? this.module.toJSON() : <any>undefined;
        if (Array.isArray(this.customAttributes)) {
            data["CustomAttributes"] = [];
            for (let item of this.customAttributes)
                data["CustomAttributes"].push(item.toJSON());
        }
        data["IsCollectible"] = this.isCollectible;
        data["MetadataToken"] = this.metadataToken;
        data["MemberType"] = this.memberType;
        data["PropertyType"] = this.propertyType ? this.propertyType.toJSON() : <any>undefined;
        data["Attributes"] = this.attributes;
        data["IsSpecialName"] = this.isSpecialName;
        data["CanRead"] = this.canRead;
        data["CanWrite"] = this.canWrite;
        data["GetMethod"] = this.getMethod ? this.getMethod.toJSON() : <any>undefined;
        data["SetMethod"] = this.setMethod ? this.setMethod.toJSON() : <any>undefined;
        return data;
    }
}

export interface IPropertyInfo {
    name?: string | undefined;
    declaringType?: Type;
    reflectedType?: Type;
    module?: Module;
    customAttributes?: CustomAttributeData[] | undefined;
    isCollectible?: boolean;
    metadataToken?: number;
    memberType?: MemberTypes;
    propertyType?: Type;
    attributes?: PropertyAttributes;
    isSpecialName?: boolean;
    canRead?: boolean;
    canWrite?: boolean;
    getMethod?: MethodInfo;
    setMethod?: MethodInfo;
}

export class Province implements IProvince {
    id?: number;
    countryId!: string;
    country?: Country;
    name!: string;
    type?: string | undefined;

    constructor(data?: IProvince) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.countryId = _data["CountryId"];
            this.country = _data["Country"] ? Country.fromJS(_data["Country"]) : <any>undefined;
            this.name = _data["Name"];
            this.type = _data["Type"];
        }
    }

    static fromJS(data: any): Province {
        data = typeof data === 'object' ? data : {};
        let result = new Province();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CountryId"] = this.countryId;
        data["Country"] = this.country ? this.country.toJSON() : <any>undefined;
        data["Name"] = this.name;
        data["Type"] = this.type;
        return data;
    }
}

export interface IProvince {
    id?: number;
    countryId: string;
    country?: Country;
    name: string;
    type?: string | undefined;
}

export class ProvinceModel implements IProvinceModel {
    id?: number;
    countryId!: string;
    country?: CountryModel;
    name!: string;
    type?: string | undefined;

    constructor(data?: IProvinceModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.countryId = _data["CountryId"];
            this.country = _data["Country"] ? CountryModel.fromJS(_data["Country"]) : <any>undefined;
            this.name = _data["Name"];
            this.type = _data["Type"];
        }
    }

    static fromJS(data: any): ProvinceModel {
        data = typeof data === 'object' ? data : {};
        let result = new ProvinceModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CountryId"] = this.countryId;
        data["Country"] = this.country ? this.country.toJSON() : <any>undefined;
        data["Name"] = this.name;
        data["Type"] = this.type;
        return data;
    }
}

export interface IProvinceModel {
    id?: number;
    countryId: string;
    country?: CountryModel;
    name: string;
    type?: string | undefined;
}

export class RegisterModel implements IRegisterModel {
    email?: string | undefined;
    phoneNumber?: string | undefined;
    password?: string | undefined;
    taxOffice?: string | undefined;
    taxNumber?: string | undefined;
    corporateName?: string | undefined;
    identityNo?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    isAcceptKvk?: boolean;
    isCorporate?: boolean;
    isAcceptTerms?: boolean;
    isAcceptContact?: boolean;

    constructor(data?: IRegisterModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["Email"];
            this.phoneNumber = _data["PhoneNumber"];
            this.password = _data["Password"];
            this.taxOffice = _data["TaxOffice"];
            this.taxNumber = _data["TaxNumber"];
            this.corporateName = _data["CorporateName"];
            this.identityNo = _data["IdentityNo"];
            this.firstName = _data["FirstName"];
            this.lastName = _data["LastName"];
            this.isAcceptKvk = _data["IsAcceptKvk"];
            this.isCorporate = _data["IsCorporate"];
            this.isAcceptTerms = _data["IsAcceptTerms"];
            this.isAcceptContact = _data["IsAcceptContact"];
        }
    }

    static fromJS(data: any): RegisterModel {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Email"] = this.email;
        data["PhoneNumber"] = this.phoneNumber;
        data["Password"] = this.password;
        data["TaxOffice"] = this.taxOffice;
        data["TaxNumber"] = this.taxNumber;
        data["CorporateName"] = this.corporateName;
        data["IdentityNo"] = this.identityNo;
        data["FirstName"] = this.firstName;
        data["LastName"] = this.lastName;
        data["IsAcceptKvk"] = this.isAcceptKvk;
        data["IsCorporate"] = this.isCorporate;
        data["IsAcceptTerms"] = this.isAcceptTerms;
        data["IsAcceptContact"] = this.isAcceptContact;
        return data;
    }
}

export interface IRegisterModel {
    email?: string | undefined;
    phoneNumber?: string | undefined;
    password?: string | undefined;
    taxOffice?: string | undefined;
    taxNumber?: string | undefined;
    corporateName?: string | undefined;
    identityNo?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    isAcceptKvk?: boolean;
    isCorporate?: boolean;
    isAcceptTerms?: boolean;
    isAcceptContact?: boolean;
}

export class Request implements IRequest {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    customerId?: number;
    customer?: Customer;
    customerBankAccountId?: number | undefined;
    customerBankAccount?: CustomerBankAccount;
    requestTypeId?: number;
    requestType?: RequestType;
    demandTypeId?: number;
    demandType?: DemandType;
    requestStatusId?: number;
    requestStatus?: RequestStatus;
    comment?: string | undefined;
    quantity?: number;
    symbolId?: number;
    symbol?: Symbol;
    price?: number;

    constructor(data?: IRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.createdOn = _data["CreatedOn"] ? moment(_data["CreatedOn"].toString()) : <any>undefined;
            this.createdById = _data["CreatedById"];
            this.createdBy = _data["CreatedBy"] ? User.fromJS(_data["CreatedBy"]) : <any>undefined;
            this.updatedOn = _data["UpdatedOn"] ? moment(_data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedById = _data["UpdatedById"];
            this.updatedBy = _data["UpdatedBy"] ? User.fromJS(_data["UpdatedBy"]) : <any>undefined;
            this.deletedOn = _data["DeletedOn"] ? moment(_data["DeletedOn"].toString()) : <any>undefined;
            this.deletedById = _data["DeletedById"];
            this.deletedBy = _data["DeletedBy"] ? User.fromJS(_data["DeletedBy"]) : <any>undefined;
            this.isDeleted = _data["IsDeleted"];
            this.customerId = _data["CustomerId"];
            this.customer = _data["Customer"] ? Customer.fromJS(_data["Customer"]) : <any>undefined;
            this.customerBankAccountId = _data["CustomerBankAccountId"];
            this.customerBankAccount = _data["CustomerBankAccount"] ? CustomerBankAccount.fromJS(_data["CustomerBankAccount"]) : <any>undefined;
            this.requestTypeId = _data["RequestTypeId"];
            this.requestType = _data["RequestType"] ? RequestType.fromJS(_data["RequestType"]) : <any>undefined;
            this.demandTypeId = _data["DemandTypeId"];
            this.demandType = _data["DemandType"] ? DemandType.fromJS(_data["DemandType"]) : <any>undefined;
            this.requestStatusId = _data["RequestStatusId"];
            this.requestStatus = _data["RequestStatus"] ? RequestStatus.fromJS(_data["RequestStatus"]) : <any>undefined;
            this.comment = _data["Comment"];
            this.quantity = _data["Quantity"];
            this.symbolId = _data["SymbolId"];
            this.symbol = _data["Symbol"] ? Symbol.fromJS(_data["Symbol"]) : <any>undefined;
            this.price = _data["Price"];
        }
    }

    static fromJS(data: any): Request {
        data = typeof data === 'object' ? data : {};
        let result = new Request();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedById"] = this.createdById;
        data["CreatedBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["DeletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        data["DeletedById"] = this.deletedById;
        data["DeletedBy"] = this.deletedBy ? this.deletedBy.toJSON() : <any>undefined;
        data["IsDeleted"] = this.isDeleted;
        data["CustomerId"] = this.customerId;
        data["Customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        data["CustomerBankAccountId"] = this.customerBankAccountId;
        data["CustomerBankAccount"] = this.customerBankAccount ? this.customerBankAccount.toJSON() : <any>undefined;
        data["RequestTypeId"] = this.requestTypeId;
        data["RequestType"] = this.requestType ? this.requestType.toJSON() : <any>undefined;
        data["DemandTypeId"] = this.demandTypeId;
        data["DemandType"] = this.demandType ? this.demandType.toJSON() : <any>undefined;
        data["RequestStatusId"] = this.requestStatusId;
        data["RequestStatus"] = this.requestStatus ? this.requestStatus.toJSON() : <any>undefined;
        data["Comment"] = this.comment;
        data["Quantity"] = this.quantity;
        data["SymbolId"] = this.symbolId;
        data["Symbol"] = this.symbol ? this.symbol.toJSON() : <any>undefined;
        data["Price"] = this.price;
        return data;
    }
}

export interface IRequest {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    customerId?: number;
    customer?: Customer;
    customerBankAccountId?: number | undefined;
    customerBankAccount?: CustomerBankAccount;
    requestTypeId?: number;
    requestType?: RequestType;
    demandTypeId?: number;
    demandType?: DemandType;
    requestStatusId?: number;
    requestStatus?: RequestStatus;
    comment?: string | undefined;
    quantity?: number;
    symbolId?: number;
    symbol?: Symbol;
    price?: number;
}

export class RequestCompleteDigitalOrderModel implements IRequestCompleteDigitalOrderModel {
    customerId?: number;
    paymentTypeId?: number;
    sourceAssetId?: number;
    targetAssetId?: number;
    subTotal?: number;
    total?: number;
    shippingAddressId?: number | undefined;
    billingAddressId?: number | undefined;
    readonly orderItems?: OrderItemModel[] | undefined;

    constructor(data?: IRequestCompleteDigitalOrderModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.customerId = _data["CustomerId"];
            this.paymentTypeId = _data["PaymentTypeId"];
            this.sourceAssetId = _data["SourceAssetId"];
            this.targetAssetId = _data["TargetAssetId"];
            this.subTotal = _data["SubTotal"];
            this.total = _data["Total"];
            this.shippingAddressId = _data["ShippingAddressId"];
            this.billingAddressId = _data["BillingAddressId"];
            if (Array.isArray(_data["OrderItems"])) {
                (<any>this).orderItems = [] as any;
                for (let item of _data["OrderItems"])
                    (<any>this).orderItems!.push(OrderItemModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RequestCompleteDigitalOrderModel {
        data = typeof data === 'object' ? data : {};
        let result = new RequestCompleteDigitalOrderModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["CustomerId"] = this.customerId;
        data["PaymentTypeId"] = this.paymentTypeId;
        data["SourceAssetId"] = this.sourceAssetId;
        data["TargetAssetId"] = this.targetAssetId;
        data["SubTotal"] = this.subTotal;
        data["Total"] = this.total;
        data["ShippingAddressId"] = this.shippingAddressId;
        data["BillingAddressId"] = this.billingAddressId;
        if (Array.isArray(this.orderItems)) {
            data["OrderItems"] = [];
            for (let item of this.orderItems)
                data["OrderItems"].push(item.toJSON());
        }
        return data;
    }
}

export interface IRequestCompleteDigitalOrderModel {
    customerId?: number;
    paymentTypeId?: number;
    sourceAssetId?: number;
    targetAssetId?: number;
    subTotal?: number;
    total?: number;
    shippingAddressId?: number | undefined;
    billingAddressId?: number | undefined;
    orderItems?: OrderItemModel[] | undefined;
}

export class RequestModel implements IRequestModel {
    id?: number;
    customerId?: number;
    customer?: CustomerModel;
    customerBankAccountId?: number | undefined;
    customerBankAccount?: CustomerBankAccountModel;
    requestTypeId?: number;
    requestType?: RequestTypeModel;
    demandTypeId?: number;
    demandType?: DemandTypeModel;
    requestStatusId?: number;
    requestStatus?: RequestStatusModel;
    comment?: string | undefined;
    quantity?: number;
    symbolId?: number;
    symbol?: SymbolModel;
    price?: number;

    constructor(data?: IRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.customerId = _data["CustomerId"];
            this.customer = _data["Customer"] ? CustomerModel.fromJS(_data["Customer"]) : <any>undefined;
            this.customerBankAccountId = _data["CustomerBankAccountId"];
            this.customerBankAccount = _data["CustomerBankAccount"] ? CustomerBankAccountModel.fromJS(_data["CustomerBankAccount"]) : <any>undefined;
            this.requestTypeId = _data["RequestTypeId"];
            this.requestType = _data["RequestType"] ? RequestTypeModel.fromJS(_data["RequestType"]) : <any>undefined;
            this.demandTypeId = _data["DemandTypeId"];
            this.demandType = _data["DemandType"] ? DemandTypeModel.fromJS(_data["DemandType"]) : <any>undefined;
            this.requestStatusId = _data["RequestStatusId"];
            this.requestStatus = _data["RequestStatus"] ? RequestStatusModel.fromJS(_data["RequestStatus"]) : <any>undefined;
            this.comment = _data["Comment"];
            this.quantity = _data["Quantity"];
            this.symbolId = _data["SymbolId"];
            this.symbol = _data["Symbol"] ? SymbolModel.fromJS(_data["Symbol"]) : <any>undefined;
            this.price = _data["Price"];
        }
    }

    static fromJS(data: any): RequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new RequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CustomerId"] = this.customerId;
        data["Customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        data["CustomerBankAccountId"] = this.customerBankAccountId;
        data["CustomerBankAccount"] = this.customerBankAccount ? this.customerBankAccount.toJSON() : <any>undefined;
        data["RequestTypeId"] = this.requestTypeId;
        data["RequestType"] = this.requestType ? this.requestType.toJSON() : <any>undefined;
        data["DemandTypeId"] = this.demandTypeId;
        data["DemandType"] = this.demandType ? this.demandType.toJSON() : <any>undefined;
        data["RequestStatusId"] = this.requestStatusId;
        data["RequestStatus"] = this.requestStatus ? this.requestStatus.toJSON() : <any>undefined;
        data["Comment"] = this.comment;
        data["Quantity"] = this.quantity;
        data["SymbolId"] = this.symbolId;
        data["Symbol"] = this.symbol ? this.symbol.toJSON() : <any>undefined;
        data["Price"] = this.price;
        return data;
    }
}

export interface IRequestModel {
    id?: number;
    customerId?: number;
    customer?: CustomerModel;
    customerBankAccountId?: number | undefined;
    customerBankAccount?: CustomerBankAccountModel;
    requestTypeId?: number;
    requestType?: RequestTypeModel;
    demandTypeId?: number;
    demandType?: DemandTypeModel;
    requestStatusId?: number;
    requestStatus?: RequestStatusModel;
    comment?: string | undefined;
    quantity?: number;
    symbolId?: number;
    symbol?: SymbolModel;
    price?: number;
}

export class RequestPhysicalOrderModel implements IRequestPhysicalOrderModel {
    customerId?: number;
    paymnetTypeId?: number;
    sourceAssetId?: number;
    subTotal?: number;
    total?: number;
    shippingAddressId?: number | undefined;
    billingAddressId?: number | undefined;
    readonly orderItems?: OrderItemModel[] | undefined;

    constructor(data?: IRequestPhysicalOrderModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.customerId = _data["CustomerId"];
            this.paymnetTypeId = _data["PaymnetTypeId"];
            this.sourceAssetId = _data["SourceAssetId"];
            this.subTotal = _data["SubTotal"];
            this.total = _data["Total"];
            this.shippingAddressId = _data["ShippingAddressId"];
            this.billingAddressId = _data["BillingAddressId"];
            if (Array.isArray(_data["OrderItems"])) {
                (<any>this).orderItems = [] as any;
                for (let item of _data["OrderItems"])
                    (<any>this).orderItems!.push(OrderItemModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RequestPhysicalOrderModel {
        data = typeof data === 'object' ? data : {};
        let result = new RequestPhysicalOrderModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["CustomerId"] = this.customerId;
        data["PaymnetTypeId"] = this.paymnetTypeId;
        data["SourceAssetId"] = this.sourceAssetId;
        data["SubTotal"] = this.subTotal;
        data["Total"] = this.total;
        data["ShippingAddressId"] = this.shippingAddressId;
        data["BillingAddressId"] = this.billingAddressId;
        if (Array.isArray(this.orderItems)) {
            data["OrderItems"] = [];
            for (let item of this.orderItems)
                data["OrderItems"].push(item.toJSON());
        }
        return data;
    }
}

export interface IRequestPhysicalOrderModel {
    customerId?: number;
    paymnetTypeId?: number;
    sourceAssetId?: number;
    subTotal?: number;
    total?: number;
    shippingAddressId?: number | undefined;
    billingAddressId?: number | undefined;
    orderItems?: OrderItemModel[] | undefined;
}

export class RequestStatus implements IRequestStatus {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;

    constructor(data?: IRequestStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.createdOn = _data["CreatedOn"] ? moment(_data["CreatedOn"].toString()) : <any>undefined;
            this.createdById = _data["CreatedById"];
            this.createdBy = _data["CreatedBy"] ? User.fromJS(_data["CreatedBy"]) : <any>undefined;
            this.updatedOn = _data["UpdatedOn"] ? moment(_data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedById = _data["UpdatedById"];
            this.updatedBy = _data["UpdatedBy"] ? User.fromJS(_data["UpdatedBy"]) : <any>undefined;
            this.deletedOn = _data["DeletedOn"] ? moment(_data["DeletedOn"].toString()) : <any>undefined;
            this.deletedById = _data["DeletedById"];
            this.deletedBy = _data["DeletedBy"] ? User.fromJS(_data["DeletedBy"]) : <any>undefined;
            this.isDeleted = _data["IsDeleted"];
            this.code = _data["Code"];
            this.description = _data["Description"];
            this.displayOrder = _data["DisplayOrder"];
            this.isActive = _data["IsActive"];
        }
    }

    static fromJS(data: any): RequestStatus {
        data = typeof data === 'object' ? data : {};
        let result = new RequestStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedById"] = this.createdById;
        data["CreatedBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["DeletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        data["DeletedById"] = this.deletedById;
        data["DeletedBy"] = this.deletedBy ? this.deletedBy.toJSON() : <any>undefined;
        data["IsDeleted"] = this.isDeleted;
        data["Code"] = this.code;
        data["Description"] = this.description;
        data["DisplayOrder"] = this.displayOrder;
        data["IsActive"] = this.isActive;
        return data;
    }
}

export interface IRequestStatus {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;
}

export class RequestStatusModel implements IRequestStatusModel {
    id?: number;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;

    constructor(data?: IRequestStatusModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.code = _data["Code"];
            this.description = _data["Description"];
            this.displayOrder = _data["DisplayOrder"];
            this.isActive = _data["IsActive"];
        }
    }

    static fromJS(data: any): RequestStatusModel {
        data = typeof data === 'object' ? data : {};
        let result = new RequestStatusModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Code"] = this.code;
        data["Description"] = this.description;
        data["DisplayOrder"] = this.displayOrder;
        data["IsActive"] = this.isActive;
        return data;
    }
}

export interface IRequestStatusModel {
    id?: number;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;
}

export class RequestType implements IRequestType {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;

    constructor(data?: IRequestType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.createdOn = _data["CreatedOn"] ? moment(_data["CreatedOn"].toString()) : <any>undefined;
            this.createdById = _data["CreatedById"];
            this.createdBy = _data["CreatedBy"] ? User.fromJS(_data["CreatedBy"]) : <any>undefined;
            this.updatedOn = _data["UpdatedOn"] ? moment(_data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedById = _data["UpdatedById"];
            this.updatedBy = _data["UpdatedBy"] ? User.fromJS(_data["UpdatedBy"]) : <any>undefined;
            this.deletedOn = _data["DeletedOn"] ? moment(_data["DeletedOn"].toString()) : <any>undefined;
            this.deletedById = _data["DeletedById"];
            this.deletedBy = _data["DeletedBy"] ? User.fromJS(_data["DeletedBy"]) : <any>undefined;
            this.isDeleted = _data["IsDeleted"];
            this.code = _data["Code"];
            this.description = _data["Description"];
            this.displayOrder = _data["DisplayOrder"];
            this.isActive = _data["IsActive"];
        }
    }

    static fromJS(data: any): RequestType {
        data = typeof data === 'object' ? data : {};
        let result = new RequestType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedById"] = this.createdById;
        data["CreatedBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["DeletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        data["DeletedById"] = this.deletedById;
        data["DeletedBy"] = this.deletedBy ? this.deletedBy.toJSON() : <any>undefined;
        data["IsDeleted"] = this.isDeleted;
        data["Code"] = this.code;
        data["Description"] = this.description;
        data["DisplayOrder"] = this.displayOrder;
        data["IsActive"] = this.isActive;
        return data;
    }
}

export interface IRequestType {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;
}

export class RequestTypeModel implements IRequestTypeModel {
    id?: number;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;

    constructor(data?: IRequestTypeModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.code = _data["Code"];
            this.description = _data["Description"];
            this.displayOrder = _data["DisplayOrder"];
            this.isActive = _data["IsActive"];
        }
    }

    static fromJS(data: any): RequestTypeModel {
        data = typeof data === 'object' ? data : {};
        let result = new RequestTypeModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Code"] = this.code;
        data["Description"] = this.description;
        data["DisplayOrder"] = this.displayOrder;
        data["IsActive"] = this.isActive;
        return data;
    }
}

export interface IRequestTypeModel {
    id?: number;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;
}

export class ResponseDigitalOrderModel implements IResponseDigitalOrderModel {
    orderId?: number;
    customerId?: number;
    paymnetTypeId?: number;
    sourceAssetId?: number;
    targetAssetId?: number;
    subTotal?: number;
    total?: number;
    shippingAddressId?: number | undefined;
    billingAddressId?: number | undefined;
    readonly orderItems?: OrderItemModel[] | undefined;

    constructor(data?: IResponseDigitalOrderModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.orderId = _data["OrderId"];
            this.customerId = _data["CustomerId"];
            this.paymnetTypeId = _data["PaymnetTypeId"];
            this.sourceAssetId = _data["SourceAssetId"];
            this.targetAssetId = _data["TargetAssetId"];
            this.subTotal = _data["SubTotal"];
            this.total = _data["Total"];
            this.shippingAddressId = _data["ShippingAddressId"];
            this.billingAddressId = _data["BillingAddressId"];
            if (Array.isArray(_data["OrderItems"])) {
                (<any>this).orderItems = [] as any;
                for (let item of _data["OrderItems"])
                    (<any>this).orderItems!.push(OrderItemModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ResponseDigitalOrderModel {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseDigitalOrderModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["OrderId"] = this.orderId;
        data["CustomerId"] = this.customerId;
        data["PaymnetTypeId"] = this.paymnetTypeId;
        data["SourceAssetId"] = this.sourceAssetId;
        data["TargetAssetId"] = this.targetAssetId;
        data["SubTotal"] = this.subTotal;
        data["Total"] = this.total;
        data["ShippingAddressId"] = this.shippingAddressId;
        data["BillingAddressId"] = this.billingAddressId;
        if (Array.isArray(this.orderItems)) {
            data["OrderItems"] = [];
            for (let item of this.orderItems)
                data["OrderItems"].push(item.toJSON());
        }
        return data;
    }
}

export interface IResponseDigitalOrderModel {
    orderId?: number;
    customerId?: number;
    paymnetTypeId?: number;
    sourceAssetId?: number;
    targetAssetId?: number;
    subTotal?: number;
    total?: number;
    shippingAddressId?: number | undefined;
    billingAddressId?: number | undefined;
    orderItems?: OrderItemModel[] | undefined;
}

export class ResponsePhysicalOrderModel implements IResponsePhysicalOrderModel {
    orderId?: number;
    customerId?: number;
    paymnetTypeId?: number;
    sourceAssetId?: number;
    subTotal?: number;
    total?: number;
    shippingAddressId?: number | undefined;
    billingAddressId?: number | undefined;
    readonly orderItems?: OrderItemModel[] | undefined;

    constructor(data?: IResponsePhysicalOrderModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.orderId = _data["OrderId"];
            this.customerId = _data["CustomerId"];
            this.paymnetTypeId = _data["PaymnetTypeId"];
            this.sourceAssetId = _data["SourceAssetId"];
            this.subTotal = _data["SubTotal"];
            this.total = _data["Total"];
            this.shippingAddressId = _data["ShippingAddressId"];
            this.billingAddressId = _data["BillingAddressId"];
            if (Array.isArray(_data["OrderItems"])) {
                (<any>this).orderItems = [] as any;
                for (let item of _data["OrderItems"])
                    (<any>this).orderItems!.push(OrderItemModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ResponsePhysicalOrderModel {
        data = typeof data === 'object' ? data : {};
        let result = new ResponsePhysicalOrderModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["OrderId"] = this.orderId;
        data["CustomerId"] = this.customerId;
        data["PaymnetTypeId"] = this.paymnetTypeId;
        data["SourceAssetId"] = this.sourceAssetId;
        data["SubTotal"] = this.subTotal;
        data["Total"] = this.total;
        data["ShippingAddressId"] = this.shippingAddressId;
        data["BillingAddressId"] = this.billingAddressId;
        if (Array.isArray(this.orderItems)) {
            data["OrderItems"] = [];
            for (let item of this.orderItems)
                data["OrderItems"].push(item.toJSON());
        }
        return data;
    }
}

export interface IResponsePhysicalOrderModel {
    orderId?: number;
    customerId?: number;
    paymnetTypeId?: number;
    sourceAssetId?: number;
    subTotal?: number;
    total?: number;
    shippingAddressId?: number | undefined;
    billingAddressId?: number | undefined;
    orderItems?: OrderItemModel[] | undefined;
}

export class Retail implements IRetail {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    nationalityId?: string | undefined;
    nationality?: Country;
    customer?: Customer;
    identityNo?: string | undefined;
    passportNo?: string | undefined;
    otpSentOn?: moment.Moment | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    normalizedFirstName?: string | undefined;
    normalizedLastName?: string | undefined;
    fatherFirstName?: string | undefined;
    fatherLastName?: string | undefined;
    motherFirstName?: string | undefined;
    motherLastName?: string | undefined;
    genderId?: number | undefined;
    gender?: Gender;
    bloodTypeId?: number | undefined;
    bloodType?: BloodType;
    birthDate?: moment.Moment | undefined;
    birthInCountry?: boolean;
    birthPlaceCountry?: string | undefined;
    birthPlaceProvince?: string | undefined;
    birthPlaceNeighborhood?: string | undefined;
    birthRegisterNumber?: string | undefined;
    livingState?: string | undefined;
    maritalStatus?: string | undefined;
    religion?: string | undefined;
    isCitizen?: boolean;
    sSN?: string | undefined;
    sectorId?: number | undefined;
    sector?: CorporateCategory;
    job?: string | undefined;
    notes?: string | undefined;
    isActive?: boolean;
    isVerifiedCitizen?: boolean;
    isVerifiedForeign?: boolean;

    constructor(data?: IRetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.isActive = true;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.createdOn = _data["CreatedOn"] ? moment(_data["CreatedOn"].toString()) : <any>undefined;
            this.createdById = _data["CreatedById"];
            this.createdBy = _data["CreatedBy"] ? User.fromJS(_data["CreatedBy"]) : <any>undefined;
            this.updatedOn = _data["UpdatedOn"] ? moment(_data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedById = _data["UpdatedById"];
            this.updatedBy = _data["UpdatedBy"] ? User.fromJS(_data["UpdatedBy"]) : <any>undefined;
            this.deletedOn = _data["DeletedOn"] ? moment(_data["DeletedOn"].toString()) : <any>undefined;
            this.deletedById = _data["DeletedById"];
            this.deletedBy = _data["DeletedBy"] ? User.fromJS(_data["DeletedBy"]) : <any>undefined;
            this.isDeleted = _data["IsDeleted"];
            this.nationalityId = _data["NationalityId"];
            this.nationality = _data["Nationality"] ? Country.fromJS(_data["Nationality"]) : <any>undefined;
            this.customer = _data["Customer"] ? Customer.fromJS(_data["Customer"]) : <any>undefined;
            this.identityNo = _data["IdentityNo"];
            this.passportNo = _data["PassportNo"];
            this.otpSentOn = _data["OtpSentOn"] ? moment(_data["OtpSentOn"].toString()) : <any>undefined;
            this.firstName = _data["FirstName"];
            this.lastName = _data["LastName"];
            this.normalizedFirstName = _data["NormalizedFirstName"];
            this.normalizedLastName = _data["NormalizedLastName"];
            this.fatherFirstName = _data["FatherFirstName"];
            this.fatherLastName = _data["FatherLastName"];
            this.motherFirstName = _data["MotherFirstName"];
            this.motherLastName = _data["MotherLastName"];
            this.genderId = _data["GenderId"];
            this.gender = _data["Gender"] ? Gender.fromJS(_data["Gender"]) : <any>undefined;
            this.bloodTypeId = _data["BloodTypeId"];
            this.bloodType = _data["BloodType"] ? BloodType.fromJS(_data["BloodType"]) : <any>undefined;
            this.birthDate = _data["BirthDate"] ? moment(_data["BirthDate"].toString()) : <any>undefined;
            this.birthInCountry = _data["BirthInCountry"];
            this.birthPlaceCountry = _data["BirthPlaceCountry"];
            this.birthPlaceProvince = _data["BirthPlaceProvince"];
            this.birthPlaceNeighborhood = _data["BirthPlaceNeighborhood"];
            this.birthRegisterNumber = _data["BirthRegisterNumber"];
            this.livingState = _data["LivingState"];
            this.maritalStatus = _data["MaritalStatus"];
            this.religion = _data["Religion"];
            this.isCitizen = _data["IsCitizen"];
            this.sSN = _data["SSN"];
            this.sectorId = _data["SectorId"];
            this.sector = _data["Sector"] ? CorporateCategory.fromJS(_data["Sector"]) : <any>undefined;
            this.job = _data["Job"];
            this.notes = _data["Notes"];
            this.isActive = _data["IsActive"] !== undefined ? _data["IsActive"] : true;
            this.isVerifiedCitizen = _data["IsVerifiedCitizen"];
            this.isVerifiedForeign = _data["IsVerifiedForeign"];
        }
    }

    static fromJS(data: any): Retail {
        data = typeof data === 'object' ? data : {};
        let result = new Retail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedById"] = this.createdById;
        data["CreatedBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["DeletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        data["DeletedById"] = this.deletedById;
        data["DeletedBy"] = this.deletedBy ? this.deletedBy.toJSON() : <any>undefined;
        data["IsDeleted"] = this.isDeleted;
        data["NationalityId"] = this.nationalityId;
        data["Nationality"] = this.nationality ? this.nationality.toJSON() : <any>undefined;
        data["Customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        data["IdentityNo"] = this.identityNo;
        data["PassportNo"] = this.passportNo;
        data["OtpSentOn"] = this.otpSentOn ? this.otpSentOn.toISOString() : <any>undefined;
        data["FirstName"] = this.firstName;
        data["LastName"] = this.lastName;
        data["NormalizedFirstName"] = this.normalizedFirstName;
        data["NormalizedLastName"] = this.normalizedLastName;
        data["FatherFirstName"] = this.fatherFirstName;
        data["FatherLastName"] = this.fatherLastName;
        data["MotherFirstName"] = this.motherFirstName;
        data["MotherLastName"] = this.motherLastName;
        data["GenderId"] = this.genderId;
        data["Gender"] = this.gender ? this.gender.toJSON() : <any>undefined;
        data["BloodTypeId"] = this.bloodTypeId;
        data["BloodType"] = this.bloodType ? this.bloodType.toJSON() : <any>undefined;
        data["BirthDate"] = this.birthDate ? this.birthDate.toISOString() : <any>undefined;
        data["BirthInCountry"] = this.birthInCountry;
        data["BirthPlaceCountry"] = this.birthPlaceCountry;
        data["BirthPlaceProvince"] = this.birthPlaceProvince;
        data["BirthPlaceNeighborhood"] = this.birthPlaceNeighborhood;
        data["BirthRegisterNumber"] = this.birthRegisterNumber;
        data["LivingState"] = this.livingState;
        data["MaritalStatus"] = this.maritalStatus;
        data["Religion"] = this.religion;
        data["IsCitizen"] = this.isCitizen;
        data["SSN"] = this.sSN;
        data["SectorId"] = this.sectorId;
        data["Sector"] = this.sector ? this.sector.toJSON() : <any>undefined;
        data["Job"] = this.job;
        data["Notes"] = this.notes;
        data["IsActive"] = this.isActive;
        data["IsVerifiedCitizen"] = this.isVerifiedCitizen;
        data["IsVerifiedForeign"] = this.isVerifiedForeign;
        return data;
    }
}

export interface IRetail {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    nationalityId?: string | undefined;
    nationality?: Country;
    customer?: Customer;
    identityNo?: string | undefined;
    passportNo?: string | undefined;
    otpSentOn?: moment.Moment | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    normalizedFirstName?: string | undefined;
    normalizedLastName?: string | undefined;
    fatherFirstName?: string | undefined;
    fatherLastName?: string | undefined;
    motherFirstName?: string | undefined;
    motherLastName?: string | undefined;
    genderId?: number | undefined;
    gender?: Gender;
    bloodTypeId?: number | undefined;
    bloodType?: BloodType;
    birthDate?: moment.Moment | undefined;
    birthInCountry?: boolean;
    birthPlaceCountry?: string | undefined;
    birthPlaceProvince?: string | undefined;
    birthPlaceNeighborhood?: string | undefined;
    birthRegisterNumber?: string | undefined;
    livingState?: string | undefined;
    maritalStatus?: string | undefined;
    religion?: string | undefined;
    isCitizen?: boolean;
    sSN?: string | undefined;
    sectorId?: number | undefined;
    sector?: CorporateCategory;
    job?: string | undefined;
    notes?: string | undefined;
    isActive?: boolean;
    isVerifiedCitizen?: boolean;
    isVerifiedForeign?: boolean;
}

export class RetailModel implements IRetailModel {
    id?: number;
    nationalityId?: string | undefined;
    nationality?: CountryModel;
    customer?: CustomerModel;
    identityNo?: string | undefined;
    passportNo?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    genderId?: number | undefined;
    gender?: GenderModel;

    constructor(data?: IRetailModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.nationalityId = _data["NationalityId"];
            this.nationality = _data["Nationality"] ? CountryModel.fromJS(_data["Nationality"]) : <any>undefined;
            this.customer = _data["Customer"] ? CustomerModel.fromJS(_data["Customer"]) : <any>undefined;
            this.identityNo = _data["IdentityNo"];
            this.passportNo = _data["PassportNo"];
            this.firstName = _data["FirstName"];
            this.lastName = _data["LastName"];
            this.genderId = _data["GenderId"];
            this.gender = _data["Gender"] ? GenderModel.fromJS(_data["Gender"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RetailModel {
        data = typeof data === 'object' ? data : {};
        let result = new RetailModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["NationalityId"] = this.nationalityId;
        data["Nationality"] = this.nationality ? this.nationality.toJSON() : <any>undefined;
        data["Customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        data["IdentityNo"] = this.identityNo;
        data["PassportNo"] = this.passportNo;
        data["FirstName"] = this.firstName;
        data["LastName"] = this.lastName;
        data["GenderId"] = this.genderId;
        data["Gender"] = this.gender ? this.gender.toJSON() : <any>undefined;
        return data;
    }
}

export interface IRetailModel {
    id?: number;
    nationalityId?: string | undefined;
    nationality?: CountryModel;
    customer?: CustomerModel;
    identityNo?: string | undefined;
    passportNo?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    genderId?: number | undefined;
    gender?: GenderModel;
}

export class Rodyumfix implements IRodyumfix {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IRodyumfix) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): Rodyumfix {
        data = typeof data === 'object' ? data : {};
        let result = new Rodyumfix();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IRodyumfix {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class Role implements IRole {
    id?: number;
    name?: string | undefined;
    normalizedName?: string | undefined;
    concurrencyStamp?: string | undefined;
    description?: string | undefined;
    userRoles?: UserRole[] | undefined;
    isDeleted?: boolean;

    constructor(data?: IRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.name = _data["Name"];
            this.normalizedName = _data["NormalizedName"];
            this.concurrencyStamp = _data["ConcurrencyStamp"];
            this.description = _data["Description"];
            if (Array.isArray(_data["UserRoles"])) {
                this.userRoles = [] as any;
                for (let item of _data["UserRoles"])
                    this.userRoles!.push(UserRole.fromJS(item));
            }
            this.isDeleted = _data["IsDeleted"];
        }
    }

    static fromJS(data: any): Role {
        data = typeof data === 'object' ? data : {};
        let result = new Role();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Name"] = this.name;
        data["NormalizedName"] = this.normalizedName;
        data["ConcurrencyStamp"] = this.concurrencyStamp;
        data["Description"] = this.description;
        if (Array.isArray(this.userRoles)) {
            data["UserRoles"] = [];
            for (let item of this.userRoles)
                data["UserRoles"].push(item.toJSON());
        }
        data["IsDeleted"] = this.isDeleted;
        return data;
    }
}

export interface IRole {
    id?: number;
    name?: string | undefined;
    normalizedName?: string | undefined;
    concurrencyStamp?: string | undefined;
    description?: string | undefined;
    userRoles?: UserRole[] | undefined;
    isDeleted?: boolean;
}

export class RssFeedModel implements IRssFeedModel {
    id?: number;
    title!: string;
    subTitle?: string | undefined;
    link!: string;

    constructor(data?: IRssFeedModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.title = _data["Title"];
            this.subTitle = _data["SubTitle"];
            this.link = _data["Link"];
        }
    }

    static fromJS(data: any): RssFeedModel {
        data = typeof data === 'object' ? data : {};
        let result = new RssFeedModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Title"] = this.title;
        data["SubTitle"] = this.subTitle;
        data["Link"] = this.link;
        return data;
    }
}

export interface IRssFeedModel {
    id?: number;
    title: string;
    subTitle?: string | undefined;
    link: string;
}

export class RuntimeFieldHandle implements IRuntimeFieldHandle {
    value?: IntPtr;

    constructor(data?: IRuntimeFieldHandle) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["Value"] ? IntPtr.fromJS(_data["Value"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RuntimeFieldHandle {
        data = typeof data === 'object' ? data : {};
        let result = new RuntimeFieldHandle();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Value"] = this.value ? this.value.toJSON() : <any>undefined;
        return data;
    }
}

export interface IRuntimeFieldHandle {
    value?: IntPtr;
}

export class RuntimeMethodHandle implements IRuntimeMethodHandle {
    value?: IntPtr;

    constructor(data?: IRuntimeMethodHandle) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["Value"] ? IntPtr.fromJS(_data["Value"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RuntimeMethodHandle {
        data = typeof data === 'object' ? data : {};
        let result = new RuntimeMethodHandle();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Value"] = this.value ? this.value.toJSON() : <any>undefined;
        return data;
    }
}

export interface IRuntimeMethodHandle {
    value?: IntPtr;
}

export class RuntimeTypeHandle implements IRuntimeTypeHandle {
    value?: IntPtr;

    constructor(data?: IRuntimeTypeHandle) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["Value"] ? IntPtr.fromJS(_data["Value"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RuntimeTypeHandle {
        data = typeof data === 'object' ? data : {};
        let result = new RuntimeTypeHandle();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Value"] = this.value ? this.value.toJSON() : <any>undefined;
        return data;
    }
}

export interface IRuntimeTypeHandle {
    value?: IntPtr;
}

export class Sar implements ISar {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: ISar) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): Sar {
        data = typeof data === 'object' ? data : {};
        let result = new Sar();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface ISar {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class ScanType implements IScanType {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;

    constructor(data?: IScanType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.createdOn = _data["CreatedOn"] ? moment(_data["CreatedOn"].toString()) : <any>undefined;
            this.createdById = _data["CreatedById"];
            this.createdBy = _data["CreatedBy"] ? User.fromJS(_data["CreatedBy"]) : <any>undefined;
            this.updatedOn = _data["UpdatedOn"] ? moment(_data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedById = _data["UpdatedById"];
            this.updatedBy = _data["UpdatedBy"] ? User.fromJS(_data["UpdatedBy"]) : <any>undefined;
            this.deletedOn = _data["DeletedOn"] ? moment(_data["DeletedOn"].toString()) : <any>undefined;
            this.deletedById = _data["DeletedById"];
            this.deletedBy = _data["DeletedBy"] ? User.fromJS(_data["DeletedBy"]) : <any>undefined;
            this.isDeleted = _data["IsDeleted"];
            this.code = _data["Code"];
            this.description = _data["Description"];
            this.displayOrder = _data["DisplayOrder"];
            this.isActive = _data["IsActive"];
        }
    }

    static fromJS(data: any): ScanType {
        data = typeof data === 'object' ? data : {};
        let result = new ScanType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedById"] = this.createdById;
        data["CreatedBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["DeletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        data["DeletedById"] = this.deletedById;
        data["DeletedBy"] = this.deletedBy ? this.deletedBy.toJSON() : <any>undefined;
        data["IsDeleted"] = this.isDeleted;
        data["Code"] = this.code;
        data["Description"] = this.description;
        data["DisplayOrder"] = this.displayOrder;
        data["IsActive"] = this.isActive;
        return data;
    }
}

export interface IScanType {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;
}

export class ScanTypeModel implements IScanTypeModel {
    id?: number;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;

    constructor(data?: IScanTypeModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.code = _data["Code"];
            this.description = _data["Description"];
            this.displayOrder = _data["DisplayOrder"];
            this.isActive = _data["IsActive"];
        }
    }

    static fromJS(data: any): ScanTypeModel {
        data = typeof data === 'object' ? data : {};
        let result = new ScanTypeModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Code"] = this.code;
        data["Description"] = this.description;
        data["DisplayOrder"] = this.displayOrder;
        data["IsActive"] = this.isActive;
        return data;
    }
}

export interface IScanTypeModel {
    id?: number;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;
}

export enum SecurityRuleSet {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export class Sek implements ISek {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: ISek) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): Sek {
        data = typeof data === 'object' ? data : {};
        let result = new Sek();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface ISek {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class SettingModel implements ISettingModel {
    id?: number;
    key?: string | undefined;
    value?: string | undefined;

    constructor(data?: ISettingModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.key = _data["Key"];
            this.value = _data["Value"];
        }
    }

    static fromJS(data: any): SettingModel {
        data = typeof data === 'object' ? data : {};
        let result = new SettingModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Key"] = this.key;
        data["Value"] = this.value;
        return data;
    }
}

export interface ISettingModel {
    id?: number;
    key?: string | undefined;
    value?: string | undefined;
}

export class SlideModel implements ISlideModel {
    id?: number;
    title!: string;
    description!: string;
    darkMediaUrl?: string | undefined;
    lightMediaUrl!: string;
    displayOrder?: number;

    constructor(data?: ISlideModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.title = _data["Title"];
            this.description = _data["Description"];
            this.darkMediaUrl = _data["DarkMediaUrl"];
            this.lightMediaUrl = _data["LightMediaUrl"];
            this.displayOrder = _data["DisplayOrder"];
        }
    }

    static fromJS(data: any): SlideModel {
        data = typeof data === 'object' ? data : {};
        let result = new SlideModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Title"] = this.title;
        data["Description"] = this.description;
        data["DarkMediaUrl"] = this.darkMediaUrl;
        data["LightMediaUrl"] = this.lightMediaUrl;
        data["DisplayOrder"] = this.displayOrder;
        return data;
    }
}

export interface ISlideModel {
    id?: number;
    title: string;
    description: string;
    darkMediaUrl?: string | undefined;
    lightMediaUrl: string;
    displayOrder?: number;
}

export class StaticPageModel implements IStaticPageModel {
    title!: string;
    subTitle?: string | undefined;
    slug?: string | undefined;
    metaKeywords?: string | undefined;
    metaDescription?: string | undefined;
    body?: string | undefined;
    mediaId?: number | undefined;
    media?: MediaModel;
    isPublished?: boolean;
    publishedOn?: moment.Moment | undefined;
    publishedTill?: moment.Moment | undefined;

    constructor(data?: IStaticPageModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["Title"];
            this.subTitle = _data["SubTitle"];
            this.slug = _data["Slug"];
            this.metaKeywords = _data["MetaKeywords"];
            this.metaDescription = _data["MetaDescription"];
            this.body = _data["Body"];
            this.mediaId = _data["MediaId"];
            this.media = _data["Media"] ? MediaModel.fromJS(_data["Media"]) : <any>undefined;
            this.isPublished = _data["IsPublished"];
            this.publishedOn = _data["PublishedOn"] ? moment(_data["PublishedOn"].toString()) : <any>undefined;
            this.publishedTill = _data["PublishedTill"] ? moment(_data["PublishedTill"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): StaticPageModel {
        data = typeof data === 'object' ? data : {};
        let result = new StaticPageModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Title"] = this.title;
        data["SubTitle"] = this.subTitle;
        data["Slug"] = this.slug;
        data["MetaKeywords"] = this.metaKeywords;
        data["MetaDescription"] = this.metaDescription;
        data["Body"] = this.body;
        data["MediaId"] = this.mediaId;
        data["Media"] = this.media ? this.media.toJSON() : <any>undefined;
        data["IsPublished"] = this.isPublished;
        data["PublishedOn"] = this.publishedOn ? this.publishedOn.toISOString() : <any>undefined;
        data["PublishedTill"] = this.publishedTill ? this.publishedTill.toISOString() : <any>undefined;
        return data;
    }
}

export interface IStaticPageModel {
    title: string;
    subTitle?: string | undefined;
    slug?: string | undefined;
    metaKeywords?: string | undefined;
    metaDescription?: string | undefined;
    body?: string | undefined;
    mediaId?: number | undefined;
    media?: MediaModel;
    isPublished?: boolean;
    publishedOn?: moment.Moment | undefined;
    publishedTill?: moment.Moment | undefined;
}

export class Store implements IStore {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    name?: string | undefined;
    customer?: Customer;
    storeInvetories?: StoreInventory[] | undefined;

    constructor(data?: IStore) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.createdOn = _data["CreatedOn"] ? moment(_data["CreatedOn"].toString()) : <any>undefined;
            this.createdById = _data["CreatedById"];
            this.createdBy = _data["CreatedBy"] ? User.fromJS(_data["CreatedBy"]) : <any>undefined;
            this.updatedOn = _data["UpdatedOn"] ? moment(_data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedById = _data["UpdatedById"];
            this.updatedBy = _data["UpdatedBy"] ? User.fromJS(_data["UpdatedBy"]) : <any>undefined;
            this.deletedOn = _data["DeletedOn"] ? moment(_data["DeletedOn"].toString()) : <any>undefined;
            this.deletedById = _data["DeletedById"];
            this.deletedBy = _data["DeletedBy"] ? User.fromJS(_data["DeletedBy"]) : <any>undefined;
            this.isDeleted = _data["IsDeleted"];
            this.name = _data["Name"];
            this.customer = _data["Customer"] ? Customer.fromJS(_data["Customer"]) : <any>undefined;
            if (Array.isArray(_data["StoreInvetories"])) {
                this.storeInvetories = [] as any;
                for (let item of _data["StoreInvetories"])
                    this.storeInvetories!.push(StoreInventory.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Store {
        data = typeof data === 'object' ? data : {};
        let result = new Store();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedById"] = this.createdById;
        data["CreatedBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["DeletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        data["DeletedById"] = this.deletedById;
        data["DeletedBy"] = this.deletedBy ? this.deletedBy.toJSON() : <any>undefined;
        data["IsDeleted"] = this.isDeleted;
        data["Name"] = this.name;
        data["Customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        if (Array.isArray(this.storeInvetories)) {
            data["StoreInvetories"] = [];
            for (let item of this.storeInvetories)
                data["StoreInvetories"].push(item.toJSON());
        }
        return data;
    }
}

export interface IStore {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    name?: string | undefined;
    customer?: Customer;
    storeInvetories?: StoreInventory[] | undefined;
}

export class StoreInventory implements IStoreInventory {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    storeId?: number;
    store?: Store;
    productId?: number;
    product?: Product;
    quantity?: number;

    constructor(data?: IStoreInventory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.createdOn = _data["CreatedOn"] ? moment(_data["CreatedOn"].toString()) : <any>undefined;
            this.createdById = _data["CreatedById"];
            this.createdBy = _data["CreatedBy"] ? User.fromJS(_data["CreatedBy"]) : <any>undefined;
            this.updatedOn = _data["UpdatedOn"] ? moment(_data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedById = _data["UpdatedById"];
            this.updatedBy = _data["UpdatedBy"] ? User.fromJS(_data["UpdatedBy"]) : <any>undefined;
            this.deletedOn = _data["DeletedOn"] ? moment(_data["DeletedOn"].toString()) : <any>undefined;
            this.deletedById = _data["DeletedById"];
            this.deletedBy = _data["DeletedBy"] ? User.fromJS(_data["DeletedBy"]) : <any>undefined;
            this.isDeleted = _data["IsDeleted"];
            this.storeId = _data["StoreId"];
            this.store = _data["Store"] ? Store.fromJS(_data["Store"]) : <any>undefined;
            this.productId = _data["ProductId"];
            this.product = _data["Product"] ? Product.fromJS(_data["Product"]) : <any>undefined;
            this.quantity = _data["Quantity"];
        }
    }

    static fromJS(data: any): StoreInventory {
        data = typeof data === 'object' ? data : {};
        let result = new StoreInventory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedById"] = this.createdById;
        data["CreatedBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["DeletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        data["DeletedById"] = this.deletedById;
        data["DeletedBy"] = this.deletedBy ? this.deletedBy.toJSON() : <any>undefined;
        data["IsDeleted"] = this.isDeleted;
        data["StoreId"] = this.storeId;
        data["Store"] = this.store ? this.store.toJSON() : <any>undefined;
        data["ProductId"] = this.productId;
        data["Product"] = this.product ? this.product.toJSON() : <any>undefined;
        data["Quantity"] = this.quantity;
        return data;
    }
}

export interface IStoreInventory {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    storeId?: number;
    store?: Store;
    productId?: number;
    product?: Product;
    quantity?: number;
}

export class StructLayoutAttribute implements IStructLayoutAttribute {
    readonly typeId?: any | undefined;
    value?: LayoutKind;

    constructor(data?: IStructLayoutAttribute) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).typeId = _data["TypeId"];
            this.value = _data["Value"];
        }
    }

    static fromJS(data: any): StructLayoutAttribute {
        data = typeof data === 'object' ? data : {};
        let result = new StructLayoutAttribute();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["TypeId"] = this.typeId;
        data["Value"] = this.value;
        return data;
    }
}

export interface IStructLayoutAttribute {
    typeId?: any | undefined;
    value?: LayoutKind;
}

export class Symbol implements ISymbol {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    countryId?: string | undefined;
    country?: Country;
    symbolTypeId?: number;
    symbolType?: SymbolType;
    mediaId?: number | undefined;
    media?: Media;
    isoCode?: string | undefined;
    currencySymbol?: string | undefined;
    matriksId?: number;
    matriksCode?: string | undefined;
    name?: string | undefined;
    isActive?: boolean;
    isSyncRateEnabled?: boolean;
    isMainCurrency?: boolean;
    isTradeable?: boolean;
    buyAddPercent?: number;
    buyAddValue?: number;
    sellAddPercent?: number;
    sellAddValue?: number;

    constructor(data?: ISymbol) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.createdOn = _data["CreatedOn"] ? moment(_data["CreatedOn"].toString()) : <any>undefined;
            this.createdById = _data["CreatedById"];
            this.createdBy = _data["CreatedBy"] ? User.fromJS(_data["CreatedBy"]) : <any>undefined;
            this.updatedOn = _data["UpdatedOn"] ? moment(_data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedById = _data["UpdatedById"];
            this.updatedBy = _data["UpdatedBy"] ? User.fromJS(_data["UpdatedBy"]) : <any>undefined;
            this.deletedOn = _data["DeletedOn"] ? moment(_data["DeletedOn"].toString()) : <any>undefined;
            this.deletedById = _data["DeletedById"];
            this.deletedBy = _data["DeletedBy"] ? User.fromJS(_data["DeletedBy"]) : <any>undefined;
            this.isDeleted = _data["IsDeleted"];
            this.countryId = _data["CountryId"];
            this.country = _data["Country"] ? Country.fromJS(_data["Country"]) : <any>undefined;
            this.symbolTypeId = _data["SymbolTypeId"];
            this.symbolType = _data["SymbolType"] ? SymbolType.fromJS(_data["SymbolType"]) : <any>undefined;
            this.mediaId = _data["MediaId"];
            this.media = _data["Media"] ? Media.fromJS(_data["Media"]) : <any>undefined;
            this.isoCode = _data["IsoCode"];
            this.currencySymbol = _data["CurrencySymbol"];
            this.matriksId = _data["MatriksId"];
            this.matriksCode = _data["MatriksCode"];
            this.name = _data["Name"];
            this.isActive = _data["IsActive"];
            this.isSyncRateEnabled = _data["IsSyncRateEnabled"];
            this.isMainCurrency = _data["IsMainCurrency"];
            this.isTradeable = _data["IsTradeable"];
            this.buyAddPercent = _data["BuyAddPercent"];
            this.buyAddValue = _data["BuyAddValue"];
            this.sellAddPercent = _data["SellAddPercent"];
            this.sellAddValue = _data["SellAddValue"];
        }
    }

    static fromJS(data: any): Symbol {
        data = typeof data === 'object' ? data : {};
        let result = new Symbol();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedById"] = this.createdById;
        data["CreatedBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["DeletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        data["DeletedById"] = this.deletedById;
        data["DeletedBy"] = this.deletedBy ? this.deletedBy.toJSON() : <any>undefined;
        data["IsDeleted"] = this.isDeleted;
        data["CountryId"] = this.countryId;
        data["Country"] = this.country ? this.country.toJSON() : <any>undefined;
        data["SymbolTypeId"] = this.symbolTypeId;
        data["SymbolType"] = this.symbolType ? this.symbolType.toJSON() : <any>undefined;
        data["MediaId"] = this.mediaId;
        data["Media"] = this.media ? this.media.toJSON() : <any>undefined;
        data["IsoCode"] = this.isoCode;
        data["CurrencySymbol"] = this.currencySymbol;
        data["MatriksId"] = this.matriksId;
        data["MatriksCode"] = this.matriksCode;
        data["Name"] = this.name;
        data["IsActive"] = this.isActive;
        data["IsSyncRateEnabled"] = this.isSyncRateEnabled;
        data["IsMainCurrency"] = this.isMainCurrency;
        data["IsTradeable"] = this.isTradeable;
        data["BuyAddPercent"] = this.buyAddPercent;
        data["BuyAddValue"] = this.buyAddValue;
        data["SellAddPercent"] = this.sellAddPercent;
        data["SellAddValue"] = this.sellAddValue;
        return data;
    }
}

export interface ISymbol {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    countryId?: string | undefined;
    country?: Country;
    symbolTypeId?: number;
    symbolType?: SymbolType;
    mediaId?: number | undefined;
    media?: Media;
    isoCode?: string | undefined;
    currencySymbol?: string | undefined;
    matriksId?: number;
    matriksCode?: string | undefined;
    name?: string | undefined;
    isActive?: boolean;
    isSyncRateEnabled?: boolean;
    isMainCurrency?: boolean;
    isTradeable?: boolean;
    buyAddPercent?: number;
    buyAddValue?: number;
    sellAddPercent?: number;
    sellAddValue?: number;
}

export class SymbolAlarmModel implements ISymbolAlarmModel {
    symbolAlarmTypeId?: number;
    symbolAlarmType?: SymbolAlarmTypeModel;
    value?: number;
    isRate?: boolean;
    whileOnStatus?: boolean;
    anyTimeStatus?: boolean;
    validityStatus?: boolean;
    customerId?: number;
    customer?: CustomerModel;
    symbolId?: number;
    symbol?: SymbolModel;
    transactionTypeId?: number;
    transactionType?: TransactionTypeModel;

    constructor(data?: ISymbolAlarmModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.symbolAlarmTypeId = _data["SymbolAlarmTypeId"];
            this.symbolAlarmType = _data["SymbolAlarmType"] ? SymbolAlarmTypeModel.fromJS(_data["SymbolAlarmType"]) : <any>undefined;
            this.value = _data["Value"];
            this.isRate = _data["IsRate"];
            this.whileOnStatus = _data["WhileOnStatus"];
            this.anyTimeStatus = _data["AnyTimeStatus"];
            this.validityStatus = _data["ValidityStatus"];
            this.customerId = _data["CustomerId"];
            this.customer = _data["Customer"] ? CustomerModel.fromJS(_data["Customer"]) : <any>undefined;
            this.symbolId = _data["SymbolId"];
            this.symbol = _data["Symbol"] ? SymbolModel.fromJS(_data["Symbol"]) : <any>undefined;
            this.transactionTypeId = _data["TransactionTypeId"];
            this.transactionType = _data["TransactionType"] ? TransactionTypeModel.fromJS(_data["TransactionType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SymbolAlarmModel {
        data = typeof data === 'object' ? data : {};
        let result = new SymbolAlarmModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["SymbolAlarmTypeId"] = this.symbolAlarmTypeId;
        data["SymbolAlarmType"] = this.symbolAlarmType ? this.symbolAlarmType.toJSON() : <any>undefined;
        data["Value"] = this.value;
        data["IsRate"] = this.isRate;
        data["WhileOnStatus"] = this.whileOnStatus;
        data["AnyTimeStatus"] = this.anyTimeStatus;
        data["ValidityStatus"] = this.validityStatus;
        data["CustomerId"] = this.customerId;
        data["Customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        data["SymbolId"] = this.symbolId;
        data["Symbol"] = this.symbol ? this.symbol.toJSON() : <any>undefined;
        data["TransactionTypeId"] = this.transactionTypeId;
        data["TransactionType"] = this.transactionType ? this.transactionType.toJSON() : <any>undefined;
        return data;
    }
}

export interface ISymbolAlarmModel {
    symbolAlarmTypeId?: number;
    symbolAlarmType?: SymbolAlarmTypeModel;
    value?: number;
    isRate?: boolean;
    whileOnStatus?: boolean;
    anyTimeStatus?: boolean;
    validityStatus?: boolean;
    customerId?: number;
    customer?: CustomerModel;
    symbolId?: number;
    symbol?: SymbolModel;
    transactionTypeId?: number;
    transactionType?: TransactionTypeModel;
}

export class SymbolAlarmTypeModel implements ISymbolAlarmTypeModel {
    id?: number;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;

    constructor(data?: ISymbolAlarmTypeModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.code = _data["Code"];
            this.description = _data["Description"];
            this.displayOrder = _data["DisplayOrder"];
            this.isActive = _data["IsActive"];
        }
    }

    static fromJS(data: any): SymbolAlarmTypeModel {
        data = typeof data === 'object' ? data : {};
        let result = new SymbolAlarmTypeModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Code"] = this.code;
        data["Description"] = this.description;
        data["DisplayOrder"] = this.displayOrder;
        data["IsActive"] = this.isActive;
        return data;
    }
}

export interface ISymbolAlarmTypeModel {
    id?: number;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;
}

export class SymbolModel implements ISymbolModel {
    id?: number;
    countryId?: string | undefined;
    country?: CountryModel;
    symbolTypeId?: number;
    symbolType?: SymbolTypeModel;
    isoCode?: string | undefined;
    matriksId?: number;
    matriksCode?: string | undefined;
    currencySymbol?: string | undefined;
    name?: string | undefined;
    isActive?: boolean;
    isSyncRateEnabled?: boolean;
    isMainCurrency?: boolean;
    isTradeable?: boolean;
    buyAddPercent?: number;
    buyAddValue?: number;
    sellAddPercent?: number;
    sellAddValue?: number;

    constructor(data?: ISymbolModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.countryId = _data["CountryId"];
            this.country = _data["Country"] ? CountryModel.fromJS(_data["Country"]) : <any>undefined;
            this.symbolTypeId = _data["SymbolTypeId"];
            this.symbolType = _data["SymbolType"] ? SymbolTypeModel.fromJS(_data["SymbolType"]) : <any>undefined;
            this.isoCode = _data["IsoCode"];
            this.matriksId = _data["MatriksId"];
            this.matriksCode = _data["MatriksCode"];
            this.currencySymbol = _data["CurrencySymbol"];
            this.name = _data["Name"];
            this.isActive = _data["IsActive"];
            this.isSyncRateEnabled = _data["IsSyncRateEnabled"];
            this.isMainCurrency = _data["IsMainCurrency"];
            this.isTradeable = _data["IsTradeable"];
            this.buyAddPercent = _data["BuyAddPercent"];
            this.buyAddValue = _data["BuyAddValue"];
            this.sellAddPercent = _data["SellAddPercent"];
            this.sellAddValue = _data["SellAddValue"];
        }
    }

    static fromJS(data: any): SymbolModel {
        data = typeof data === 'object' ? data : {};
        let result = new SymbolModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CountryId"] = this.countryId;
        data["Country"] = this.country ? this.country.toJSON() : <any>undefined;
        data["SymbolTypeId"] = this.symbolTypeId;
        data["SymbolType"] = this.symbolType ? this.symbolType.toJSON() : <any>undefined;
        data["IsoCode"] = this.isoCode;
        data["MatriksId"] = this.matriksId;
        data["MatriksCode"] = this.matriksCode;
        data["CurrencySymbol"] = this.currencySymbol;
        data["Name"] = this.name;
        data["IsActive"] = this.isActive;
        data["IsSyncRateEnabled"] = this.isSyncRateEnabled;
        data["IsMainCurrency"] = this.isMainCurrency;
        data["IsTradeable"] = this.isTradeable;
        data["BuyAddPercent"] = this.buyAddPercent;
        data["BuyAddValue"] = this.buyAddValue;
        data["SellAddPercent"] = this.sellAddPercent;
        data["SellAddValue"] = this.sellAddValue;
        return data;
    }
}

export interface ISymbolModel {
    id?: number;
    countryId?: string | undefined;
    country?: CountryModel;
    symbolTypeId?: number;
    symbolType?: SymbolTypeModel;
    isoCode?: string | undefined;
    matriksId?: number;
    matriksCode?: string | undefined;
    currencySymbol?: string | undefined;
    name?: string | undefined;
    isActive?: boolean;
    isSyncRateEnabled?: boolean;
    isMainCurrency?: boolean;
    isTradeable?: boolean;
    buyAddPercent?: number;
    buyAddValue?: number;
    sellAddPercent?: number;
    sellAddValue?: number;
}

export class SymbolRateModel implements ISymbolRateModel {
    symbolTypeId?: number;
    symbolType?: SymbolTypeModel;
    isoCode?: string | undefined;
    matriksId?: number;
    matriksCode?: string | undefined;
    name?: string | undefined;
    isMainCurrency?: boolean;
    isTradeable?: boolean;
    rateDate?: moment.Moment;
    buy?: number;
    sell?: number;
    difference?: number;
    min?: number;
    max?: number;
    minYear?: number;
    maxYear?: number;
    dailyChangePercent?: number;
    latestClosing?: number;
    opening?: number;
    volumeLot?: number;
    volumeTry?: number;
    capital?: number;

    constructor(data?: ISymbolRateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.symbolTypeId = _data["SymbolTypeId"];
            this.symbolType = _data["SymbolType"] ? SymbolTypeModel.fromJS(_data["SymbolType"]) : <any>undefined;
            this.isoCode = _data["IsoCode"];
            this.matriksId = _data["MatriksId"];
            this.matriksCode = _data["MatriksCode"];
            this.name = _data["Name"];
            this.isMainCurrency = _data["IsMainCurrency"];
            this.isTradeable = _data["IsTradeable"];
            this.rateDate = _data["RateDate"] ? moment(_data["RateDate"].toString()) : <any>undefined;
            this.buy = _data["Buy"];
            this.sell = _data["Sell"];
            this.difference = _data["Difference"];
            this.min = _data["Min"];
            this.max = _data["Max"];
            this.minYear = _data["MinYear"];
            this.maxYear = _data["MaxYear"];
            this.dailyChangePercent = _data["DailyChangePercent"];
            this.latestClosing = _data["LatestClosing"];
            this.opening = _data["Opening"];
            this.volumeLot = _data["VolumeLot"];
            this.volumeTry = _data["VolumeTry"];
            this.capital = _data["Capital"];
        }
    }

    static fromJS(data: any): SymbolRateModel {
        data = typeof data === 'object' ? data : {};
        let result = new SymbolRateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["SymbolTypeId"] = this.symbolTypeId;
        data["SymbolType"] = this.symbolType ? this.symbolType.toJSON() : <any>undefined;
        data["IsoCode"] = this.isoCode;
        data["MatriksId"] = this.matriksId;
        data["MatriksCode"] = this.matriksCode;
        data["Name"] = this.name;
        data["IsMainCurrency"] = this.isMainCurrency;
        data["IsTradeable"] = this.isTradeable;
        data["RateDate"] = this.rateDate ? this.rateDate.toISOString() : <any>undefined;
        data["Buy"] = this.buy;
        data["Sell"] = this.sell;
        data["Difference"] = this.difference;
        data["Min"] = this.min;
        data["Max"] = this.max;
        data["MinYear"] = this.minYear;
        data["MaxYear"] = this.maxYear;
        data["DailyChangePercent"] = this.dailyChangePercent;
        data["LatestClosing"] = this.latestClosing;
        data["Opening"] = this.opening;
        data["VolumeLot"] = this.volumeLot;
        data["VolumeTry"] = this.volumeTry;
        data["Capital"] = this.capital;
        return data;
    }
}

export interface ISymbolRateModel {
    symbolTypeId?: number;
    symbolType?: SymbolTypeModel;
    isoCode?: string | undefined;
    matriksId?: number;
    matriksCode?: string | undefined;
    name?: string | undefined;
    isMainCurrency?: boolean;
    isTradeable?: boolean;
    rateDate?: moment.Moment;
    buy?: number;
    sell?: number;
    difference?: number;
    min?: number;
    max?: number;
    minYear?: number;
    maxYear?: number;
    dailyChangePercent?: number;
    latestClosing?: number;
    opening?: number;
    volumeLot?: number;
    volumeTry?: number;
    capital?: number;
}

export class SymbolType implements ISymbolType {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;

    constructor(data?: ISymbolType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.createdOn = _data["CreatedOn"] ? moment(_data["CreatedOn"].toString()) : <any>undefined;
            this.createdById = _data["CreatedById"];
            this.createdBy = _data["CreatedBy"] ? User.fromJS(_data["CreatedBy"]) : <any>undefined;
            this.updatedOn = _data["UpdatedOn"] ? moment(_data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedById = _data["UpdatedById"];
            this.updatedBy = _data["UpdatedBy"] ? User.fromJS(_data["UpdatedBy"]) : <any>undefined;
            this.deletedOn = _data["DeletedOn"] ? moment(_data["DeletedOn"].toString()) : <any>undefined;
            this.deletedById = _data["DeletedById"];
            this.deletedBy = _data["DeletedBy"] ? User.fromJS(_data["DeletedBy"]) : <any>undefined;
            this.isDeleted = _data["IsDeleted"];
            this.code = _data["Code"];
            this.description = _data["Description"];
            this.displayOrder = _data["DisplayOrder"];
            this.isActive = _data["IsActive"];
        }
    }

    static fromJS(data: any): SymbolType {
        data = typeof data === 'object' ? data : {};
        let result = new SymbolType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedById"] = this.createdById;
        data["CreatedBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["DeletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        data["DeletedById"] = this.deletedById;
        data["DeletedBy"] = this.deletedBy ? this.deletedBy.toJSON() : <any>undefined;
        data["IsDeleted"] = this.isDeleted;
        data["Code"] = this.code;
        data["Description"] = this.description;
        data["DisplayOrder"] = this.displayOrder;
        data["IsActive"] = this.isActive;
        return data;
    }
}

export interface ISymbolType {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;
}

export class SymbolTypeModel implements ISymbolTypeModel {
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;

    constructor(data?: ISymbolTypeModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["Code"];
            this.description = _data["Description"];
            this.displayOrder = _data["DisplayOrder"];
            this.isActive = _data["IsActive"];
        }
    }

    static fromJS(data: any): SymbolTypeModel {
        data = typeof data === 'object' ? data : {};
        let result = new SymbolTypeModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Code"] = this.code;
        data["Description"] = this.description;
        data["DisplayOrder"] = this.displayOrder;
        data["IsActive"] = this.isActive;
        return data;
    }
}

export interface ISymbolTypeModel {
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;
}

export class SymbolVoteRequestModel implements ISymbolVoteRequestModel {
    customerId?: number;
    symbolId?: number;
    vote?: boolean;

    constructor(data?: ISymbolVoteRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.customerId = _data["CustomerId"];
            this.symbolId = _data["SymbolId"];
            this.vote = _data["Vote"];
        }
    }

    static fromJS(data: any): SymbolVoteRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new SymbolVoteRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["CustomerId"] = this.customerId;
        data["SymbolId"] = this.symbolId;
        data["Vote"] = this.vote;
        return data;
    }
}

export interface ISymbolVoteRequestModel {
    customerId?: number;
    symbolId?: number;
    vote?: boolean;
}

export class SymbolVoteSummaryModel implements ISymbolVoteSummaryModel {
    increasingCount?: number;
    decreasingCount?: number;
    hasCustomerVote?: boolean;
    customerVote?: boolean;

    constructor(data?: ISymbolVoteSummaryModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.increasingCount = _data["IncreasingCount"];
            this.decreasingCount = _data["DecreasingCount"];
            this.hasCustomerVote = _data["HasCustomerVote"];
            this.customerVote = _data["CustomerVote"];
        }
    }

    static fromJS(data: any): SymbolVoteSummaryModel {
        data = typeof data === 'object' ? data : {};
        let result = new SymbolVoteSummaryModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["IncreasingCount"] = this.increasingCount;
        data["DecreasingCount"] = this.decreasingCount;
        data["HasCustomerVote"] = this.hasCustomerVote;
        data["CustomerVote"] = this.customerVote;
        return data;
    }
}

export interface ISymbolVoteSummaryModel {
    increasingCount?: number;
    decreasingCount?: number;
    hasCustomerVote?: boolean;
    customerVote?: boolean;
}

export class TokenModel implements ITokenModel {
    token?: string | undefined;

    constructor(data?: ITokenModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["Token"];
        }
    }

    static fromJS(data: any): TokenModel {
        data = typeof data === 'object' ? data : {};
        let result = new TokenModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Token"] = this.token;
        return data;
    }
}

export interface ITokenModel {
    token?: string | undefined;
}

export class Transaction implements ITransaction {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    customerId?: number;
    customer?: Customer;
    symbolId?: number;
    symbol?: Symbol;
    transactionTypeId?: number;
    transactionType?: TransactionType;
    paymentTypeId?: number;
    paymentType?: PaymentType;
    actionDate?: moment.Moment;
    quantity?: number;
    amount?: number;
    netAmount?: number;
    commissionAmount?: number;
    tax?: number;
    kpayTxnId?: string | undefined;
    paymentCardId?: string | undefined;
    paymentMessage?: string | undefined;
    description?: string | undefined;

    constructor(data?: ITransaction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.createdOn = _data["CreatedOn"] ? moment(_data["CreatedOn"].toString()) : <any>undefined;
            this.createdById = _data["CreatedById"];
            this.createdBy = _data["CreatedBy"] ? User.fromJS(_data["CreatedBy"]) : <any>undefined;
            this.updatedOn = _data["UpdatedOn"] ? moment(_data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedById = _data["UpdatedById"];
            this.updatedBy = _data["UpdatedBy"] ? User.fromJS(_data["UpdatedBy"]) : <any>undefined;
            this.deletedOn = _data["DeletedOn"] ? moment(_data["DeletedOn"].toString()) : <any>undefined;
            this.deletedById = _data["DeletedById"];
            this.deletedBy = _data["DeletedBy"] ? User.fromJS(_data["DeletedBy"]) : <any>undefined;
            this.isDeleted = _data["IsDeleted"];
            this.customerId = _data["CustomerId"];
            this.customer = _data["Customer"] ? Customer.fromJS(_data["Customer"]) : <any>undefined;
            this.symbolId = _data["SymbolId"];
            this.symbol = _data["Symbol"] ? Symbol.fromJS(_data["Symbol"]) : <any>undefined;
            this.transactionTypeId = _data["TransactionTypeId"];
            this.transactionType = _data["TransactionType"] ? TransactionType.fromJS(_data["TransactionType"]) : <any>undefined;
            this.paymentTypeId = _data["PaymentTypeId"];
            this.paymentType = _data["PaymentType"] ? PaymentType.fromJS(_data["PaymentType"]) : <any>undefined;
            this.actionDate = _data["ActionDate"] ? moment(_data["ActionDate"].toString()) : <any>undefined;
            this.quantity = _data["Quantity"];
            this.amount = _data["Amount"];
            this.netAmount = _data["NetAmount"];
            this.commissionAmount = _data["CommissionAmount"];
            this.tax = _data["Tax"];
            this.kpayTxnId = _data["KpayTxnId"];
            this.paymentCardId = _data["PaymentCardId"];
            this.paymentMessage = _data["PaymentMessage"];
            this.description = _data["Description"];
        }
    }

    static fromJS(data: any): Transaction {
        data = typeof data === 'object' ? data : {};
        let result = new Transaction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedById"] = this.createdById;
        data["CreatedBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["DeletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        data["DeletedById"] = this.deletedById;
        data["DeletedBy"] = this.deletedBy ? this.deletedBy.toJSON() : <any>undefined;
        data["IsDeleted"] = this.isDeleted;
        data["CustomerId"] = this.customerId;
        data["Customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        data["SymbolId"] = this.symbolId;
        data["Symbol"] = this.symbol ? this.symbol.toJSON() : <any>undefined;
        data["TransactionTypeId"] = this.transactionTypeId;
        data["TransactionType"] = this.transactionType ? this.transactionType.toJSON() : <any>undefined;
        data["PaymentTypeId"] = this.paymentTypeId;
        data["PaymentType"] = this.paymentType ? this.paymentType.toJSON() : <any>undefined;
        data["ActionDate"] = this.actionDate ? this.actionDate.toISOString() : <any>undefined;
        data["Quantity"] = this.quantity;
        data["Amount"] = this.amount;
        data["NetAmount"] = this.netAmount;
        data["CommissionAmount"] = this.commissionAmount;
        data["Tax"] = this.tax;
        data["KpayTxnId"] = this.kpayTxnId;
        data["PaymentCardId"] = this.paymentCardId;
        data["PaymentMessage"] = this.paymentMessage;
        data["Description"] = this.description;
        return data;
    }
}

export interface ITransaction {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    customerId?: number;
    customer?: Customer;
    symbolId?: number;
    symbol?: Symbol;
    transactionTypeId?: number;
    transactionType?: TransactionType;
    paymentTypeId?: number;
    paymentType?: PaymentType;
    actionDate?: moment.Moment;
    quantity?: number;
    amount?: number;
    netAmount?: number;
    commissionAmount?: number;
    tax?: number;
    kpayTxnId?: string | undefined;
    paymentCardId?: string | undefined;
    paymentMessage?: string | undefined;
    description?: string | undefined;
}

export class TransactionModel implements ITransactionModel {
    id?: number;
    customerId?: number;
    customer?: CustomerModel;
    symbolId?: number;
    symbol?: SymbolModel;
    transactionTypeId?: number;
    transactionType?: TransactionTypeModel;
    paymentTypeId?: number;
    paymentType?: PaymentTypeModel;
    actionDate?: moment.Moment;
    quantity?: number;
    amount?: number;
    netAmount?: number;
    commissionAmount?: number;
    tax?: number;
    kpayTxnId?: string | undefined;
    paymentCardId?: string | undefined;
    paymentMessage?: string | undefined;
    description?: string | undefined;

    constructor(data?: ITransactionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.customerId = _data["CustomerId"];
            this.customer = _data["Customer"] ? CustomerModel.fromJS(_data["Customer"]) : <any>undefined;
            this.symbolId = _data["SymbolId"];
            this.symbol = _data["Symbol"] ? SymbolModel.fromJS(_data["Symbol"]) : <any>undefined;
            this.transactionTypeId = _data["TransactionTypeId"];
            this.transactionType = _data["TransactionType"] ? TransactionTypeModel.fromJS(_data["TransactionType"]) : <any>undefined;
            this.paymentTypeId = _data["PaymentTypeId"];
            this.paymentType = _data["PaymentType"] ? PaymentTypeModel.fromJS(_data["PaymentType"]) : <any>undefined;
            this.actionDate = _data["ActionDate"] ? moment(_data["ActionDate"].toString()) : <any>undefined;
            this.quantity = _data["Quantity"];
            this.amount = _data["Amount"];
            this.netAmount = _data["NetAmount"];
            this.commissionAmount = _data["CommissionAmount"];
            this.tax = _data["Tax"];
            this.kpayTxnId = _data["KpayTxnId"];
            this.paymentCardId = _data["PaymentCardId"];
            this.paymentMessage = _data["PaymentMessage"];
            this.description = _data["Description"];
        }
    }

    static fromJS(data: any): TransactionModel {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CustomerId"] = this.customerId;
        data["Customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        data["SymbolId"] = this.symbolId;
        data["Symbol"] = this.symbol ? this.symbol.toJSON() : <any>undefined;
        data["TransactionTypeId"] = this.transactionTypeId;
        data["TransactionType"] = this.transactionType ? this.transactionType.toJSON() : <any>undefined;
        data["PaymentTypeId"] = this.paymentTypeId;
        data["PaymentType"] = this.paymentType ? this.paymentType.toJSON() : <any>undefined;
        data["ActionDate"] = this.actionDate ? this.actionDate.toISOString() : <any>undefined;
        data["Quantity"] = this.quantity;
        data["Amount"] = this.amount;
        data["NetAmount"] = this.netAmount;
        data["CommissionAmount"] = this.commissionAmount;
        data["Tax"] = this.tax;
        data["KpayTxnId"] = this.kpayTxnId;
        data["PaymentCardId"] = this.paymentCardId;
        data["PaymentMessage"] = this.paymentMessage;
        data["Description"] = this.description;
        return data;
    }
}

export interface ITransactionModel {
    id?: number;
    customerId?: number;
    customer?: CustomerModel;
    symbolId?: number;
    symbol?: SymbolModel;
    transactionTypeId?: number;
    transactionType?: TransactionTypeModel;
    paymentTypeId?: number;
    paymentType?: PaymentTypeModel;
    actionDate?: moment.Moment;
    quantity?: number;
    amount?: number;
    netAmount?: number;
    commissionAmount?: number;
    tax?: number;
    kpayTxnId?: string | undefined;
    paymentCardId?: string | undefined;
    paymentMessage?: string | undefined;
    description?: string | undefined;
}

export class TransactionRequestModel implements ITransactionRequestModel {
    customerId?: number;
    symbolId?: number;
    transactionTypeId?: number;
    startDate?: moment.Moment;
    endDate?: moment.Moment;

    constructor(data?: ITransactionRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.customerId = _data["CustomerId"];
            this.symbolId = _data["SymbolId"];
            this.transactionTypeId = _data["TransactionTypeId"];
            this.startDate = _data["StartDate"] ? moment(_data["StartDate"].toString()) : <any>undefined;
            this.endDate = _data["EndDate"] ? moment(_data["EndDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): TransactionRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["CustomerId"] = this.customerId;
        data["SymbolId"] = this.symbolId;
        data["TransactionTypeId"] = this.transactionTypeId;
        data["StartDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["EndDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface ITransactionRequestModel {
    customerId?: number;
    symbolId?: number;
    transactionTypeId?: number;
    startDate?: moment.Moment;
    endDate?: moment.Moment;
}

export class TransactionType implements ITransactionType {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;

    constructor(data?: ITransactionType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.createdOn = _data["CreatedOn"] ? moment(_data["CreatedOn"].toString()) : <any>undefined;
            this.createdById = _data["CreatedById"];
            this.createdBy = _data["CreatedBy"] ? User.fromJS(_data["CreatedBy"]) : <any>undefined;
            this.updatedOn = _data["UpdatedOn"] ? moment(_data["UpdatedOn"].toString()) : <any>undefined;
            this.updatedById = _data["UpdatedById"];
            this.updatedBy = _data["UpdatedBy"] ? User.fromJS(_data["UpdatedBy"]) : <any>undefined;
            this.deletedOn = _data["DeletedOn"] ? moment(_data["DeletedOn"].toString()) : <any>undefined;
            this.deletedById = _data["DeletedById"];
            this.deletedBy = _data["DeletedBy"] ? User.fromJS(_data["DeletedBy"]) : <any>undefined;
            this.isDeleted = _data["IsDeleted"];
            this.code = _data["Code"];
            this.description = _data["Description"];
            this.displayOrder = _data["DisplayOrder"];
            this.isActive = _data["IsActive"];
        }
    }

    static fromJS(data: any): TransactionType {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["CreatedById"] = this.createdById;
        data["CreatedBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["UpdatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["UpdatedById"] = this.updatedById;
        data["UpdatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["DeletedOn"] = this.deletedOn ? this.deletedOn.toISOString() : <any>undefined;
        data["DeletedById"] = this.deletedById;
        data["DeletedBy"] = this.deletedBy ? this.deletedBy.toJSON() : <any>undefined;
        data["IsDeleted"] = this.isDeleted;
        data["Code"] = this.code;
        data["Description"] = this.description;
        data["DisplayOrder"] = this.displayOrder;
        data["IsActive"] = this.isActive;
        return data;
    }
}

export interface ITransactionType {
    id?: number;
    createdOn?: moment.Moment | undefined;
    createdById?: number | undefined;
    createdBy?: User;
    updatedOn?: moment.Moment | undefined;
    updatedById?: number | undefined;
    updatedBy?: User;
    deletedOn?: moment.Moment | undefined;
    deletedById?: number | undefined;
    deletedBy?: User;
    isDeleted?: boolean;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;
}

export class TransactionTypeModel implements ITransactionTypeModel {
    id?: number;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;

    constructor(data?: ITransactionTypeModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.code = _data["Code"];
            this.description = _data["Description"];
            this.displayOrder = _data["DisplayOrder"];
            this.isActive = _data["IsActive"];
        }
    }

    static fromJS(data: any): TransactionTypeModel {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionTypeModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Code"] = this.code;
        data["Description"] = this.description;
        data["DisplayOrder"] = this.displayOrder;
        data["IsActive"] = this.isActive;
        return data;
    }
}

export interface ITransactionTypeModel {
    id?: number;
    code?: string | undefined;
    description?: string | undefined;
    displayOrder?: number;
    isActive?: boolean;
}

export class Type implements IType {
    readonly name?: string | undefined;
    readonly customAttributes?: CustomAttributeData[] | undefined;
    readonly isCollectible?: boolean;
    readonly metadataToken?: number;
    readonly isInterface?: boolean;
    memberType?: MemberTypes;
    readonly namespace?: string | undefined;
    readonly assemblyQualifiedName?: string | undefined;
    readonly fullName?: string | undefined;
    assembly?: Assembly;
    module?: Module;
    readonly isNested?: boolean;
    declaringType?: Type;
    declaringMethod?: MethodBase;
    reflectedType?: Type;
    underlyingSystemType?: Type;
    readonly isTypeDefinition?: boolean;
    readonly isArray?: boolean;
    readonly isByRef?: boolean;
    readonly isPointer?: boolean;
    readonly isConstructedGenericType?: boolean;
    readonly isGenericParameter?: boolean;
    readonly isGenericTypeParameter?: boolean;
    readonly isGenericMethodParameter?: boolean;
    readonly isGenericType?: boolean;
    readonly isGenericTypeDefinition?: boolean;
    readonly isSZArray?: boolean;
    readonly isVariableBoundArray?: boolean;
    readonly isByRefLike?: boolean;
    readonly hasElementType?: boolean;
    readonly genericTypeArguments?: Type[] | undefined;
    readonly genericParameterPosition?: number;
    genericParameterAttributes?: GenericParameterAttributes;
    attributes?: TypeAttributes;
    readonly isAbstract?: boolean;
    readonly isImport?: boolean;
    readonly isSealed?: boolean;
    readonly isSpecialName?: boolean;
    readonly isClass?: boolean;
    readonly isNestedAssembly?: boolean;
    readonly isNestedFamANDAssem?: boolean;
    readonly isNestedFamily?: boolean;
    readonly isNestedFamORAssem?: boolean;
    readonly isNestedPrivate?: boolean;
    readonly isNestedPublic?: boolean;
    readonly isNotPublic?: boolean;
    readonly isPublic?: boolean;
    readonly isAutoLayout?: boolean;
    readonly isExplicitLayout?: boolean;
    readonly isLayoutSequential?: boolean;
    readonly isAnsiClass?: boolean;
    readonly isAutoClass?: boolean;
    readonly isUnicodeClass?: boolean;
    readonly isCOMObject?: boolean;
    readonly isContextful?: boolean;
    readonly isEnum?: boolean;
    readonly isMarshalByRef?: boolean;
    readonly isPrimitive?: boolean;
    readonly isValueType?: boolean;
    readonly isSignatureType?: boolean;
    readonly isSecurityCritical?: boolean;
    readonly isSecuritySafeCritical?: boolean;
    readonly isSecurityTransparent?: boolean;
    structLayoutAttribute?: StructLayoutAttribute;
    typeInitializer?: ConstructorInfo;
    typeHandle?: RuntimeTypeHandle;
    readonly gUID?: string;
    baseType?: Type;
    readonly isSerializable?: boolean;
    readonly containsGenericParameters?: boolean;
    readonly isVisible?: boolean;

    constructor(data?: IType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).name = _data["Name"];
            if (Array.isArray(_data["CustomAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["CustomAttributes"])
                    (<any>this).customAttributes!.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).isCollectible = _data["IsCollectible"];
            (<any>this).metadataToken = _data["MetadataToken"];
            (<any>this).isInterface = _data["IsInterface"];
            this.memberType = _data["MemberType"];
            (<any>this).namespace = _data["Namespace"];
            (<any>this).assemblyQualifiedName = _data["AssemblyQualifiedName"];
            (<any>this).fullName = _data["FullName"];
            this.assembly = _data["Assembly"] ? Assembly.fromJS(_data["Assembly"]) : <any>undefined;
            this.module = _data["Module"] ? Module.fromJS(_data["Module"]) : <any>undefined;
            (<any>this).isNested = _data["IsNested"];
            this.declaringType = _data["DeclaringType"] ? Type.fromJS(_data["DeclaringType"]) : <any>undefined;
            this.declaringMethod = _data["DeclaringMethod"] ? MethodBase.fromJS(_data["DeclaringMethod"]) : <any>undefined;
            this.reflectedType = _data["ReflectedType"] ? Type.fromJS(_data["ReflectedType"]) : <any>undefined;
            this.underlyingSystemType = _data["UnderlyingSystemType"] ? Type.fromJS(_data["UnderlyingSystemType"]) : <any>undefined;
            (<any>this).isTypeDefinition = _data["IsTypeDefinition"];
            (<any>this).isArray = _data["IsArray"];
            (<any>this).isByRef = _data["IsByRef"];
            (<any>this).isPointer = _data["IsPointer"];
            (<any>this).isConstructedGenericType = _data["IsConstructedGenericType"];
            (<any>this).isGenericParameter = _data["IsGenericParameter"];
            (<any>this).isGenericTypeParameter = _data["IsGenericTypeParameter"];
            (<any>this).isGenericMethodParameter = _data["IsGenericMethodParameter"];
            (<any>this).isGenericType = _data["IsGenericType"];
            (<any>this).isGenericTypeDefinition = _data["IsGenericTypeDefinition"];
            (<any>this).isSZArray = _data["IsSZArray"];
            (<any>this).isVariableBoundArray = _data["IsVariableBoundArray"];
            (<any>this).isByRefLike = _data["IsByRefLike"];
            (<any>this).hasElementType = _data["HasElementType"];
            if (Array.isArray(_data["GenericTypeArguments"])) {
                (<any>this).genericTypeArguments = [] as any;
                for (let item of _data["GenericTypeArguments"])
                    (<any>this).genericTypeArguments!.push(Type.fromJS(item));
            }
            (<any>this).genericParameterPosition = _data["GenericParameterPosition"];
            this.genericParameterAttributes = _data["GenericParameterAttributes"];
            this.attributes = _data["Attributes"];
            (<any>this).isAbstract = _data["IsAbstract"];
            (<any>this).isImport = _data["IsImport"];
            (<any>this).isSealed = _data["IsSealed"];
            (<any>this).isSpecialName = _data["IsSpecialName"];
            (<any>this).isClass = _data["IsClass"];
            (<any>this).isNestedAssembly = _data["IsNestedAssembly"];
            (<any>this).isNestedFamANDAssem = _data["IsNestedFamANDAssem"];
            (<any>this).isNestedFamily = _data["IsNestedFamily"];
            (<any>this).isNestedFamORAssem = _data["IsNestedFamORAssem"];
            (<any>this).isNestedPrivate = _data["IsNestedPrivate"];
            (<any>this).isNestedPublic = _data["IsNestedPublic"];
            (<any>this).isNotPublic = _data["IsNotPublic"];
            (<any>this).isPublic = _data["IsPublic"];
            (<any>this).isAutoLayout = _data["IsAutoLayout"];
            (<any>this).isExplicitLayout = _data["IsExplicitLayout"];
            (<any>this).isLayoutSequential = _data["IsLayoutSequential"];
            (<any>this).isAnsiClass = _data["IsAnsiClass"];
            (<any>this).isAutoClass = _data["IsAutoClass"];
            (<any>this).isUnicodeClass = _data["IsUnicodeClass"];
            (<any>this).isCOMObject = _data["IsCOMObject"];
            (<any>this).isContextful = _data["IsContextful"];
            (<any>this).isEnum = _data["IsEnum"];
            (<any>this).isMarshalByRef = _data["IsMarshalByRef"];
            (<any>this).isPrimitive = _data["IsPrimitive"];
            (<any>this).isValueType = _data["IsValueType"];
            (<any>this).isSignatureType = _data["IsSignatureType"];
            (<any>this).isSecurityCritical = _data["IsSecurityCritical"];
            (<any>this).isSecuritySafeCritical = _data["IsSecuritySafeCritical"];
            (<any>this).isSecurityTransparent = _data["IsSecurityTransparent"];
            this.structLayoutAttribute = _data["StructLayoutAttribute"] ? StructLayoutAttribute.fromJS(_data["StructLayoutAttribute"]) : <any>undefined;
            this.typeInitializer = _data["TypeInitializer"] ? ConstructorInfo.fromJS(_data["TypeInitializer"]) : <any>undefined;
            this.typeHandle = _data["TypeHandle"] ? RuntimeTypeHandle.fromJS(_data["TypeHandle"]) : <any>undefined;
            (<any>this).gUID = _data["GUID"];
            this.baseType = _data["BaseType"] ? Type.fromJS(_data["BaseType"]) : <any>undefined;
            (<any>this).isSerializable = _data["IsSerializable"];
            (<any>this).containsGenericParameters = _data["ContainsGenericParameters"];
            (<any>this).isVisible = _data["IsVisible"];
        }
    }

    static fromJS(data: any): Type {
        data = typeof data === 'object' ? data : {};
        let result = new Type();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Name"] = this.name;
        if (Array.isArray(this.customAttributes)) {
            data["CustomAttributes"] = [];
            for (let item of this.customAttributes)
                data["CustomAttributes"].push(item.toJSON());
        }
        data["IsCollectible"] = this.isCollectible;
        data["MetadataToken"] = this.metadataToken;
        data["IsInterface"] = this.isInterface;
        data["MemberType"] = this.memberType;
        data["Namespace"] = this.namespace;
        data["AssemblyQualifiedName"] = this.assemblyQualifiedName;
        data["FullName"] = this.fullName;
        data["Assembly"] = this.assembly ? this.assembly.toJSON() : <any>undefined;
        data["Module"] = this.module ? this.module.toJSON() : <any>undefined;
        data["IsNested"] = this.isNested;
        data["DeclaringType"] = this.declaringType ? this.declaringType.toJSON() : <any>undefined;
        data["DeclaringMethod"] = this.declaringMethod ? this.declaringMethod.toJSON() : <any>undefined;
        data["ReflectedType"] = this.reflectedType ? this.reflectedType.toJSON() : <any>undefined;
        data["UnderlyingSystemType"] = this.underlyingSystemType ? this.underlyingSystemType.toJSON() : <any>undefined;
        data["IsTypeDefinition"] = this.isTypeDefinition;
        data["IsArray"] = this.isArray;
        data["IsByRef"] = this.isByRef;
        data["IsPointer"] = this.isPointer;
        data["IsConstructedGenericType"] = this.isConstructedGenericType;
        data["IsGenericParameter"] = this.isGenericParameter;
        data["IsGenericTypeParameter"] = this.isGenericTypeParameter;
        data["IsGenericMethodParameter"] = this.isGenericMethodParameter;
        data["IsGenericType"] = this.isGenericType;
        data["IsGenericTypeDefinition"] = this.isGenericTypeDefinition;
        data["IsSZArray"] = this.isSZArray;
        data["IsVariableBoundArray"] = this.isVariableBoundArray;
        data["IsByRefLike"] = this.isByRefLike;
        data["HasElementType"] = this.hasElementType;
        if (Array.isArray(this.genericTypeArguments)) {
            data["GenericTypeArguments"] = [];
            for (let item of this.genericTypeArguments)
                data["GenericTypeArguments"].push(item.toJSON());
        }
        data["GenericParameterPosition"] = this.genericParameterPosition;
        data["GenericParameterAttributes"] = this.genericParameterAttributes;
        data["Attributes"] = this.attributes;
        data["IsAbstract"] = this.isAbstract;
        data["IsImport"] = this.isImport;
        data["IsSealed"] = this.isSealed;
        data["IsSpecialName"] = this.isSpecialName;
        data["IsClass"] = this.isClass;
        data["IsNestedAssembly"] = this.isNestedAssembly;
        data["IsNestedFamANDAssem"] = this.isNestedFamANDAssem;
        data["IsNestedFamily"] = this.isNestedFamily;
        data["IsNestedFamORAssem"] = this.isNestedFamORAssem;
        data["IsNestedPrivate"] = this.isNestedPrivate;
        data["IsNestedPublic"] = this.isNestedPublic;
        data["IsNotPublic"] = this.isNotPublic;
        data["IsPublic"] = this.isPublic;
        data["IsAutoLayout"] = this.isAutoLayout;
        data["IsExplicitLayout"] = this.isExplicitLayout;
        data["IsLayoutSequential"] = this.isLayoutSequential;
        data["IsAnsiClass"] = this.isAnsiClass;
        data["IsAutoClass"] = this.isAutoClass;
        data["IsUnicodeClass"] = this.isUnicodeClass;
        data["IsCOMObject"] = this.isCOMObject;
        data["IsContextful"] = this.isContextful;
        data["IsEnum"] = this.isEnum;
        data["IsMarshalByRef"] = this.isMarshalByRef;
        data["IsPrimitive"] = this.isPrimitive;
        data["IsValueType"] = this.isValueType;
        data["IsSignatureType"] = this.isSignatureType;
        data["IsSecurityCritical"] = this.isSecurityCritical;
        data["IsSecuritySafeCritical"] = this.isSecuritySafeCritical;
        data["IsSecurityTransparent"] = this.isSecurityTransparent;
        data["StructLayoutAttribute"] = this.structLayoutAttribute ? this.structLayoutAttribute.toJSON() : <any>undefined;
        data["TypeInitializer"] = this.typeInitializer ? this.typeInitializer.toJSON() : <any>undefined;
        data["TypeHandle"] = this.typeHandle ? this.typeHandle.toJSON() : <any>undefined;
        data["GUID"] = this.gUID;
        data["BaseType"] = this.baseType ? this.baseType.toJSON() : <any>undefined;
        data["IsSerializable"] = this.isSerializable;
        data["ContainsGenericParameters"] = this.containsGenericParameters;
        data["IsVisible"] = this.isVisible;
        return data;
    }
}

export interface IType {
    name?: string | undefined;
    customAttributes?: CustomAttributeData[] | undefined;
    isCollectible?: boolean;
    metadataToken?: number;
    isInterface?: boolean;
    memberType?: MemberTypes;
    namespace?: string | undefined;
    assemblyQualifiedName?: string | undefined;
    fullName?: string | undefined;
    assembly?: Assembly;
    module?: Module;
    isNested?: boolean;
    declaringType?: Type;
    declaringMethod?: MethodBase;
    reflectedType?: Type;
    underlyingSystemType?: Type;
    isTypeDefinition?: boolean;
    isArray?: boolean;
    isByRef?: boolean;
    isPointer?: boolean;
    isConstructedGenericType?: boolean;
    isGenericParameter?: boolean;
    isGenericTypeParameter?: boolean;
    isGenericMethodParameter?: boolean;
    isGenericType?: boolean;
    isGenericTypeDefinition?: boolean;
    isSZArray?: boolean;
    isVariableBoundArray?: boolean;
    isByRefLike?: boolean;
    hasElementType?: boolean;
    genericTypeArguments?: Type[] | undefined;
    genericParameterPosition?: number;
    genericParameterAttributes?: GenericParameterAttributes;
    attributes?: TypeAttributes;
    isAbstract?: boolean;
    isImport?: boolean;
    isSealed?: boolean;
    isSpecialName?: boolean;
    isClass?: boolean;
    isNestedAssembly?: boolean;
    isNestedFamANDAssem?: boolean;
    isNestedFamily?: boolean;
    isNestedFamORAssem?: boolean;
    isNestedPrivate?: boolean;
    isNestedPublic?: boolean;
    isNotPublic?: boolean;
    isPublic?: boolean;
    isAutoLayout?: boolean;
    isExplicitLayout?: boolean;
    isLayoutSequential?: boolean;
    isAnsiClass?: boolean;
    isAutoClass?: boolean;
    isUnicodeClass?: boolean;
    isCOMObject?: boolean;
    isContextful?: boolean;
    isEnum?: boolean;
    isMarshalByRef?: boolean;
    isPrimitive?: boolean;
    isValueType?: boolean;
    isSignatureType?: boolean;
    isSecurityCritical?: boolean;
    isSecuritySafeCritical?: boolean;
    isSecurityTransparent?: boolean;
    structLayoutAttribute?: StructLayoutAttribute;
    typeInitializer?: ConstructorInfo;
    typeHandle?: RuntimeTypeHandle;
    gUID?: string;
    baseType?: Type;
    isSerializable?: boolean;
    containsGenericParameters?: boolean;
    isVisible?: boolean;
}

export enum TypeAttributes {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _8 = 8,
    _16 = 16,
    _24 = 24,
    _32 = 32,
    _128 = 128,
    _256 = 256,
    _1024 = 1024,
    _2048 = 2048,
    _4096 = 4096,
    _8192 = 8192,
    _16384 = 16384,
    _65536 = 65536,
    _131072 = 131072,
    _196608 = 196608,
    _262144 = 262144,
    _264192 = 264192,
    _1048576 = 1048576,
    _12582912 = 12582912,
}

export class TypeInfo implements ITypeInfo {
    readonly name?: string | undefined;
    readonly customAttributes?: CustomAttributeData[] | undefined;
    readonly isCollectible?: boolean;
    readonly metadataToken?: number;
    readonly isInterface?: boolean;
    memberType?: MemberTypes;
    readonly namespace?: string | undefined;
    readonly assemblyQualifiedName?: string | undefined;
    readonly fullName?: string | undefined;
    assembly?: Assembly;
    module?: Module;
    readonly isNested?: boolean;
    declaringType?: Type;
    declaringMethod?: MethodBase;
    reflectedType?: Type;
    underlyingSystemType?: Type;
    readonly isTypeDefinition?: boolean;
    readonly isArray?: boolean;
    readonly isByRef?: boolean;
    readonly isPointer?: boolean;
    readonly isConstructedGenericType?: boolean;
    readonly isGenericParameter?: boolean;
    readonly isGenericTypeParameter?: boolean;
    readonly isGenericMethodParameter?: boolean;
    readonly isGenericType?: boolean;
    readonly isGenericTypeDefinition?: boolean;
    readonly isSZArray?: boolean;
    readonly isVariableBoundArray?: boolean;
    readonly isByRefLike?: boolean;
    readonly hasElementType?: boolean;
    readonly genericTypeArguments?: Type[] | undefined;
    readonly genericParameterPosition?: number;
    genericParameterAttributes?: GenericParameterAttributes;
    attributes?: TypeAttributes;
    readonly isAbstract?: boolean;
    readonly isImport?: boolean;
    readonly isSealed?: boolean;
    readonly isSpecialName?: boolean;
    readonly isClass?: boolean;
    readonly isNestedAssembly?: boolean;
    readonly isNestedFamANDAssem?: boolean;
    readonly isNestedFamily?: boolean;
    readonly isNestedFamORAssem?: boolean;
    readonly isNestedPrivate?: boolean;
    readonly isNestedPublic?: boolean;
    readonly isNotPublic?: boolean;
    readonly isPublic?: boolean;
    readonly isAutoLayout?: boolean;
    readonly isExplicitLayout?: boolean;
    readonly isLayoutSequential?: boolean;
    readonly isAnsiClass?: boolean;
    readonly isAutoClass?: boolean;
    readonly isUnicodeClass?: boolean;
    readonly isCOMObject?: boolean;
    readonly isContextful?: boolean;
    readonly isEnum?: boolean;
    readonly isMarshalByRef?: boolean;
    readonly isPrimitive?: boolean;
    readonly isValueType?: boolean;
    readonly isSignatureType?: boolean;
    readonly isSecurityCritical?: boolean;
    readonly isSecuritySafeCritical?: boolean;
    readonly isSecurityTransparent?: boolean;
    structLayoutAttribute?: StructLayoutAttribute;
    typeInitializer?: ConstructorInfo;
    typeHandle?: RuntimeTypeHandle;
    readonly gUID?: string;
    baseType?: Type;
    readonly isSerializable?: boolean;
    readonly containsGenericParameters?: boolean;
    readonly isVisible?: boolean;
    readonly genericTypeParameters?: Type[] | undefined;
    readonly declaredConstructors?: ConstructorInfo[] | undefined;
    readonly declaredEvents?: EventInfo[] | undefined;
    readonly declaredFields?: FieldInfo[] | undefined;
    readonly declaredMembers?: MemberInfo[] | undefined;
    readonly declaredMethods?: MethodInfo[] | undefined;
    readonly declaredNestedTypes?: TypeInfo[] | undefined;
    readonly declaredProperties?: PropertyInfo[] | undefined;
    readonly implementedInterfaces?: Type[] | undefined;

    constructor(data?: ITypeInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).name = _data["Name"];
            if (Array.isArray(_data["CustomAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["CustomAttributes"])
                    (<any>this).customAttributes!.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).isCollectible = _data["IsCollectible"];
            (<any>this).metadataToken = _data["MetadataToken"];
            (<any>this).isInterface = _data["IsInterface"];
            this.memberType = _data["MemberType"];
            (<any>this).namespace = _data["Namespace"];
            (<any>this).assemblyQualifiedName = _data["AssemblyQualifiedName"];
            (<any>this).fullName = _data["FullName"];
            this.assembly = _data["Assembly"] ? Assembly.fromJS(_data["Assembly"]) : <any>undefined;
            this.module = _data["Module"] ? Module.fromJS(_data["Module"]) : <any>undefined;
            (<any>this).isNested = _data["IsNested"];
            this.declaringType = _data["DeclaringType"] ? Type.fromJS(_data["DeclaringType"]) : <any>undefined;
            this.declaringMethod = _data["DeclaringMethod"] ? MethodBase.fromJS(_data["DeclaringMethod"]) : <any>undefined;
            this.reflectedType = _data["ReflectedType"] ? Type.fromJS(_data["ReflectedType"]) : <any>undefined;
            this.underlyingSystemType = _data["UnderlyingSystemType"] ? Type.fromJS(_data["UnderlyingSystemType"]) : <any>undefined;
            (<any>this).isTypeDefinition = _data["IsTypeDefinition"];
            (<any>this).isArray = _data["IsArray"];
            (<any>this).isByRef = _data["IsByRef"];
            (<any>this).isPointer = _data["IsPointer"];
            (<any>this).isConstructedGenericType = _data["IsConstructedGenericType"];
            (<any>this).isGenericParameter = _data["IsGenericParameter"];
            (<any>this).isGenericTypeParameter = _data["IsGenericTypeParameter"];
            (<any>this).isGenericMethodParameter = _data["IsGenericMethodParameter"];
            (<any>this).isGenericType = _data["IsGenericType"];
            (<any>this).isGenericTypeDefinition = _data["IsGenericTypeDefinition"];
            (<any>this).isSZArray = _data["IsSZArray"];
            (<any>this).isVariableBoundArray = _data["IsVariableBoundArray"];
            (<any>this).isByRefLike = _data["IsByRefLike"];
            (<any>this).hasElementType = _data["HasElementType"];
            if (Array.isArray(_data["GenericTypeArguments"])) {
                (<any>this).genericTypeArguments = [] as any;
                for (let item of _data["GenericTypeArguments"])
                    (<any>this).genericTypeArguments!.push(Type.fromJS(item));
            }
            (<any>this).genericParameterPosition = _data["GenericParameterPosition"];
            this.genericParameterAttributes = _data["GenericParameterAttributes"];
            this.attributes = _data["Attributes"];
            (<any>this).isAbstract = _data["IsAbstract"];
            (<any>this).isImport = _data["IsImport"];
            (<any>this).isSealed = _data["IsSealed"];
            (<any>this).isSpecialName = _data["IsSpecialName"];
            (<any>this).isClass = _data["IsClass"];
            (<any>this).isNestedAssembly = _data["IsNestedAssembly"];
            (<any>this).isNestedFamANDAssem = _data["IsNestedFamANDAssem"];
            (<any>this).isNestedFamily = _data["IsNestedFamily"];
            (<any>this).isNestedFamORAssem = _data["IsNestedFamORAssem"];
            (<any>this).isNestedPrivate = _data["IsNestedPrivate"];
            (<any>this).isNestedPublic = _data["IsNestedPublic"];
            (<any>this).isNotPublic = _data["IsNotPublic"];
            (<any>this).isPublic = _data["IsPublic"];
            (<any>this).isAutoLayout = _data["IsAutoLayout"];
            (<any>this).isExplicitLayout = _data["IsExplicitLayout"];
            (<any>this).isLayoutSequential = _data["IsLayoutSequential"];
            (<any>this).isAnsiClass = _data["IsAnsiClass"];
            (<any>this).isAutoClass = _data["IsAutoClass"];
            (<any>this).isUnicodeClass = _data["IsUnicodeClass"];
            (<any>this).isCOMObject = _data["IsCOMObject"];
            (<any>this).isContextful = _data["IsContextful"];
            (<any>this).isEnum = _data["IsEnum"];
            (<any>this).isMarshalByRef = _data["IsMarshalByRef"];
            (<any>this).isPrimitive = _data["IsPrimitive"];
            (<any>this).isValueType = _data["IsValueType"];
            (<any>this).isSignatureType = _data["IsSignatureType"];
            (<any>this).isSecurityCritical = _data["IsSecurityCritical"];
            (<any>this).isSecuritySafeCritical = _data["IsSecuritySafeCritical"];
            (<any>this).isSecurityTransparent = _data["IsSecurityTransparent"];
            this.structLayoutAttribute = _data["StructLayoutAttribute"] ? StructLayoutAttribute.fromJS(_data["StructLayoutAttribute"]) : <any>undefined;
            this.typeInitializer = _data["TypeInitializer"] ? ConstructorInfo.fromJS(_data["TypeInitializer"]) : <any>undefined;
            this.typeHandle = _data["TypeHandle"] ? RuntimeTypeHandle.fromJS(_data["TypeHandle"]) : <any>undefined;
            (<any>this).gUID = _data["GUID"];
            this.baseType = _data["BaseType"] ? Type.fromJS(_data["BaseType"]) : <any>undefined;
            (<any>this).isSerializable = _data["IsSerializable"];
            (<any>this).containsGenericParameters = _data["ContainsGenericParameters"];
            (<any>this).isVisible = _data["IsVisible"];
            if (Array.isArray(_data["GenericTypeParameters"])) {
                (<any>this).genericTypeParameters = [] as any;
                for (let item of _data["GenericTypeParameters"])
                    (<any>this).genericTypeParameters!.push(Type.fromJS(item));
            }
            if (Array.isArray(_data["DeclaredConstructors"])) {
                (<any>this).declaredConstructors = [] as any;
                for (let item of _data["DeclaredConstructors"])
                    (<any>this).declaredConstructors!.push(ConstructorInfo.fromJS(item));
            }
            if (Array.isArray(_data["DeclaredEvents"])) {
                (<any>this).declaredEvents = [] as any;
                for (let item of _data["DeclaredEvents"])
                    (<any>this).declaredEvents!.push(EventInfo.fromJS(item));
            }
            if (Array.isArray(_data["DeclaredFields"])) {
                (<any>this).declaredFields = [] as any;
                for (let item of _data["DeclaredFields"])
                    (<any>this).declaredFields!.push(FieldInfo.fromJS(item));
            }
            if (Array.isArray(_data["DeclaredMembers"])) {
                (<any>this).declaredMembers = [] as any;
                for (let item of _data["DeclaredMembers"])
                    (<any>this).declaredMembers!.push(MemberInfo.fromJS(item));
            }
            if (Array.isArray(_data["DeclaredMethods"])) {
                (<any>this).declaredMethods = [] as any;
                for (let item of _data["DeclaredMethods"])
                    (<any>this).declaredMethods!.push(MethodInfo.fromJS(item));
            }
            if (Array.isArray(_data["DeclaredNestedTypes"])) {
                (<any>this).declaredNestedTypes = [] as any;
                for (let item of _data["DeclaredNestedTypes"])
                    (<any>this).declaredNestedTypes!.push(TypeInfo.fromJS(item));
            }
            if (Array.isArray(_data["DeclaredProperties"])) {
                (<any>this).declaredProperties = [] as any;
                for (let item of _data["DeclaredProperties"])
                    (<any>this).declaredProperties!.push(PropertyInfo.fromJS(item));
            }
            if (Array.isArray(_data["ImplementedInterfaces"])) {
                (<any>this).implementedInterfaces = [] as any;
                for (let item of _data["ImplementedInterfaces"])
                    (<any>this).implementedInterfaces!.push(Type.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TypeInfo {
        data = typeof data === 'object' ? data : {};
        let result = new TypeInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Name"] = this.name;
        if (Array.isArray(this.customAttributes)) {
            data["CustomAttributes"] = [];
            for (let item of this.customAttributes)
                data["CustomAttributes"].push(item.toJSON());
        }
        data["IsCollectible"] = this.isCollectible;
        data["MetadataToken"] = this.metadataToken;
        data["IsInterface"] = this.isInterface;
        data["MemberType"] = this.memberType;
        data["Namespace"] = this.namespace;
        data["AssemblyQualifiedName"] = this.assemblyQualifiedName;
        data["FullName"] = this.fullName;
        data["Assembly"] = this.assembly ? this.assembly.toJSON() : <any>undefined;
        data["Module"] = this.module ? this.module.toJSON() : <any>undefined;
        data["IsNested"] = this.isNested;
        data["DeclaringType"] = this.declaringType ? this.declaringType.toJSON() : <any>undefined;
        data["DeclaringMethod"] = this.declaringMethod ? this.declaringMethod.toJSON() : <any>undefined;
        data["ReflectedType"] = this.reflectedType ? this.reflectedType.toJSON() : <any>undefined;
        data["UnderlyingSystemType"] = this.underlyingSystemType ? this.underlyingSystemType.toJSON() : <any>undefined;
        data["IsTypeDefinition"] = this.isTypeDefinition;
        data["IsArray"] = this.isArray;
        data["IsByRef"] = this.isByRef;
        data["IsPointer"] = this.isPointer;
        data["IsConstructedGenericType"] = this.isConstructedGenericType;
        data["IsGenericParameter"] = this.isGenericParameter;
        data["IsGenericTypeParameter"] = this.isGenericTypeParameter;
        data["IsGenericMethodParameter"] = this.isGenericMethodParameter;
        data["IsGenericType"] = this.isGenericType;
        data["IsGenericTypeDefinition"] = this.isGenericTypeDefinition;
        data["IsSZArray"] = this.isSZArray;
        data["IsVariableBoundArray"] = this.isVariableBoundArray;
        data["IsByRefLike"] = this.isByRefLike;
        data["HasElementType"] = this.hasElementType;
        if (Array.isArray(this.genericTypeArguments)) {
            data["GenericTypeArguments"] = [];
            for (let item of this.genericTypeArguments)
                data["GenericTypeArguments"].push(item.toJSON());
        }
        data["GenericParameterPosition"] = this.genericParameterPosition;
        data["GenericParameterAttributes"] = this.genericParameterAttributes;
        data["Attributes"] = this.attributes;
        data["IsAbstract"] = this.isAbstract;
        data["IsImport"] = this.isImport;
        data["IsSealed"] = this.isSealed;
        data["IsSpecialName"] = this.isSpecialName;
        data["IsClass"] = this.isClass;
        data["IsNestedAssembly"] = this.isNestedAssembly;
        data["IsNestedFamANDAssem"] = this.isNestedFamANDAssem;
        data["IsNestedFamily"] = this.isNestedFamily;
        data["IsNestedFamORAssem"] = this.isNestedFamORAssem;
        data["IsNestedPrivate"] = this.isNestedPrivate;
        data["IsNestedPublic"] = this.isNestedPublic;
        data["IsNotPublic"] = this.isNotPublic;
        data["IsPublic"] = this.isPublic;
        data["IsAutoLayout"] = this.isAutoLayout;
        data["IsExplicitLayout"] = this.isExplicitLayout;
        data["IsLayoutSequential"] = this.isLayoutSequential;
        data["IsAnsiClass"] = this.isAnsiClass;
        data["IsAutoClass"] = this.isAutoClass;
        data["IsUnicodeClass"] = this.isUnicodeClass;
        data["IsCOMObject"] = this.isCOMObject;
        data["IsContextful"] = this.isContextful;
        data["IsEnum"] = this.isEnum;
        data["IsMarshalByRef"] = this.isMarshalByRef;
        data["IsPrimitive"] = this.isPrimitive;
        data["IsValueType"] = this.isValueType;
        data["IsSignatureType"] = this.isSignatureType;
        data["IsSecurityCritical"] = this.isSecurityCritical;
        data["IsSecuritySafeCritical"] = this.isSecuritySafeCritical;
        data["IsSecurityTransparent"] = this.isSecurityTransparent;
        data["StructLayoutAttribute"] = this.structLayoutAttribute ? this.structLayoutAttribute.toJSON() : <any>undefined;
        data["TypeInitializer"] = this.typeInitializer ? this.typeInitializer.toJSON() : <any>undefined;
        data["TypeHandle"] = this.typeHandle ? this.typeHandle.toJSON() : <any>undefined;
        data["GUID"] = this.gUID;
        data["BaseType"] = this.baseType ? this.baseType.toJSON() : <any>undefined;
        data["IsSerializable"] = this.isSerializable;
        data["ContainsGenericParameters"] = this.containsGenericParameters;
        data["IsVisible"] = this.isVisible;
        if (Array.isArray(this.genericTypeParameters)) {
            data["GenericTypeParameters"] = [];
            for (let item of this.genericTypeParameters)
                data["GenericTypeParameters"].push(item.toJSON());
        }
        if (Array.isArray(this.declaredConstructors)) {
            data["DeclaredConstructors"] = [];
            for (let item of this.declaredConstructors)
                data["DeclaredConstructors"].push(item.toJSON());
        }
        if (Array.isArray(this.declaredEvents)) {
            data["DeclaredEvents"] = [];
            for (let item of this.declaredEvents)
                data["DeclaredEvents"].push(item.toJSON());
        }
        if (Array.isArray(this.declaredFields)) {
            data["DeclaredFields"] = [];
            for (let item of this.declaredFields)
                data["DeclaredFields"].push(item.toJSON());
        }
        if (Array.isArray(this.declaredMembers)) {
            data["DeclaredMembers"] = [];
            for (let item of this.declaredMembers)
                data["DeclaredMembers"].push(item.toJSON());
        }
        if (Array.isArray(this.declaredMethods)) {
            data["DeclaredMethods"] = [];
            for (let item of this.declaredMethods)
                data["DeclaredMethods"].push(item.toJSON());
        }
        if (Array.isArray(this.declaredNestedTypes)) {
            data["DeclaredNestedTypes"] = [];
            for (let item of this.declaredNestedTypes)
                data["DeclaredNestedTypes"].push(item.toJSON());
        }
        if (Array.isArray(this.declaredProperties)) {
            data["DeclaredProperties"] = [];
            for (let item of this.declaredProperties)
                data["DeclaredProperties"].push(item.toJSON());
        }
        if (Array.isArray(this.implementedInterfaces)) {
            data["ImplementedInterfaces"] = [];
            for (let item of this.implementedInterfaces)
                data["ImplementedInterfaces"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITypeInfo {
    name?: string | undefined;
    customAttributes?: CustomAttributeData[] | undefined;
    isCollectible?: boolean;
    metadataToken?: number;
    isInterface?: boolean;
    memberType?: MemberTypes;
    namespace?: string | undefined;
    assemblyQualifiedName?: string | undefined;
    fullName?: string | undefined;
    assembly?: Assembly;
    module?: Module;
    isNested?: boolean;
    declaringType?: Type;
    declaringMethod?: MethodBase;
    reflectedType?: Type;
    underlyingSystemType?: Type;
    isTypeDefinition?: boolean;
    isArray?: boolean;
    isByRef?: boolean;
    isPointer?: boolean;
    isConstructedGenericType?: boolean;
    isGenericParameter?: boolean;
    isGenericTypeParameter?: boolean;
    isGenericMethodParameter?: boolean;
    isGenericType?: boolean;
    isGenericTypeDefinition?: boolean;
    isSZArray?: boolean;
    isVariableBoundArray?: boolean;
    isByRefLike?: boolean;
    hasElementType?: boolean;
    genericTypeArguments?: Type[] | undefined;
    genericParameterPosition?: number;
    genericParameterAttributes?: GenericParameterAttributes;
    attributes?: TypeAttributes;
    isAbstract?: boolean;
    isImport?: boolean;
    isSealed?: boolean;
    isSpecialName?: boolean;
    isClass?: boolean;
    isNestedAssembly?: boolean;
    isNestedFamANDAssem?: boolean;
    isNestedFamily?: boolean;
    isNestedFamORAssem?: boolean;
    isNestedPrivate?: boolean;
    isNestedPublic?: boolean;
    isNotPublic?: boolean;
    isPublic?: boolean;
    isAutoLayout?: boolean;
    isExplicitLayout?: boolean;
    isLayoutSequential?: boolean;
    isAnsiClass?: boolean;
    isAutoClass?: boolean;
    isUnicodeClass?: boolean;
    isCOMObject?: boolean;
    isContextful?: boolean;
    isEnum?: boolean;
    isMarshalByRef?: boolean;
    isPrimitive?: boolean;
    isValueType?: boolean;
    isSignatureType?: boolean;
    isSecurityCritical?: boolean;
    isSecuritySafeCritical?: boolean;
    isSecurityTransparent?: boolean;
    structLayoutAttribute?: StructLayoutAttribute;
    typeInitializer?: ConstructorInfo;
    typeHandle?: RuntimeTypeHandle;
    gUID?: string;
    baseType?: Type;
    isSerializable?: boolean;
    containsGenericParameters?: boolean;
    isVisible?: boolean;
    genericTypeParameters?: Type[] | undefined;
    declaredConstructors?: ConstructorInfo[] | undefined;
    declaredEvents?: EventInfo[] | undefined;
    declaredFields?: FieldInfo[] | undefined;
    declaredMembers?: MemberInfo[] | undefined;
    declaredMethods?: MethodInfo[] | undefined;
    declaredNestedTypes?: TypeInfo[] | undefined;
    declaredProperties?: PropertyInfo[] | undefined;
    implementedInterfaces?: Type[] | undefined;
}

export class Usd implements IUsd {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;

    constructor(data?: IUsd) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.alis = _data["Alis"];
            this.satis = _data["Satis"];
            this.tarih = _data["Tarih"];
            this.sonkapanis = _data["Sonkapanis"];
            this.son = _data["Son"];
            this.endusuk = _data["Endusuk"];
            this.enyuksek = _data["Enyuksek"];
            this.gunlukyuzde = _data["Gunlukyuzde"];
        }
    }

    static fromJS(data: any): Usd {
        data = typeof data === 'object' ? data : {};
        let result = new Usd();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Alis"] = this.alis;
        data["Satis"] = this.satis;
        data["Tarih"] = this.tarih;
        data["Sonkapanis"] = this.sonkapanis;
        data["Son"] = this.son;
        data["Endusuk"] = this.endusuk;
        data["Enyuksek"] = this.enyuksek;
        data["Gunlukyuzde"] = this.gunlukyuzde;
        return data;
    }
}

export interface IUsd {
    alis?: string | undefined;
    satis?: string | undefined;
    tarih?: string | undefined;
    sonkapanis?: string | undefined;
    son?: string | undefined;
    endusuk?: string | undefined;
    enyuksek?: string | undefined;
    gunlukyuzde?: string | undefined;
}

export class User implements IUser {
    id?: number;
    userName?: string | undefined;
    normalizedUserName?: string | undefined;
    email?: string | undefined;
    normalizedEmail?: string | undefined;
    emailConfirmed?: boolean;
    passwordHash?: string | undefined;
    securityStamp?: string | undefined;
    concurrencyStamp?: string | undefined;
    phoneNumber?: string | undefined;
    phoneNumberConfirmed?: boolean;
    twoFactorEnabled?: boolean;
    lockoutEnd?: moment.Moment | undefined;
    lockoutEnabled?: boolean;
    accessFailedCount?: number;
    userGuid?: string;
    kpayMemberId?: string | undefined;
    kpayUsername?: string | undefined;
    customerId?: number | undefined;
    customer?: Customer;
    version?: number;
    isAcceptKvk?: boolean;
    isAcceptTerms?: boolean;
    isAcceptContact?: boolean;
    isActive?: boolean;
    isDeleted?: boolean;
    newPhoneNumber?: string | undefined;
    otp?: string | undefined;
    userRoles?: UserRole[] | undefined;

    constructor(data?: IUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.userName = _data["UserName"];
            this.normalizedUserName = _data["NormalizedUserName"];
            this.email = _data["Email"];
            this.normalizedEmail = _data["NormalizedEmail"];
            this.emailConfirmed = _data["EmailConfirmed"];
            this.passwordHash = _data["PasswordHash"];
            this.securityStamp = _data["SecurityStamp"];
            this.concurrencyStamp = _data["ConcurrencyStamp"];
            this.phoneNumber = _data["PhoneNumber"];
            this.phoneNumberConfirmed = _data["PhoneNumberConfirmed"];
            this.twoFactorEnabled = _data["TwoFactorEnabled"];
            this.lockoutEnd = _data["LockoutEnd"] ? moment(_data["LockoutEnd"].toString()) : <any>undefined;
            this.lockoutEnabled = _data["LockoutEnabled"];
            this.accessFailedCount = _data["AccessFailedCount"];
            this.userGuid = _data["UserGuid"];
            this.kpayMemberId = _data["KpayMemberId"];
            this.kpayUsername = _data["KpayUsername"];
            this.customerId = _data["CustomerId"];
            this.customer = _data["Customer"] ? Customer.fromJS(_data["Customer"]) : <any>undefined;
            this.version = _data["Version"];
            this.isAcceptKvk = _data["IsAcceptKvk"];
            this.isAcceptTerms = _data["IsAcceptTerms"];
            this.isAcceptContact = _data["IsAcceptContact"];
            this.isActive = _data["IsActive"];
            this.isDeleted = _data["IsDeleted"];
            this.newPhoneNumber = _data["NewPhoneNumber"];
            this.otp = _data["Otp"];
            if (Array.isArray(_data["UserRoles"])) {
                this.userRoles = [] as any;
                for (let item of _data["UserRoles"])
                    this.userRoles!.push(UserRole.fromJS(item));
            }
        }
    }

    static fromJS(data: any): User {
        data = typeof data === 'object' ? data : {};
        let result = new User();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["UserName"] = this.userName;
        data["NormalizedUserName"] = this.normalizedUserName;
        data["Email"] = this.email;
        data["NormalizedEmail"] = this.normalizedEmail;
        data["EmailConfirmed"] = this.emailConfirmed;
        data["PasswordHash"] = this.passwordHash;
        data["SecurityStamp"] = this.securityStamp;
        data["ConcurrencyStamp"] = this.concurrencyStamp;
        data["PhoneNumber"] = this.phoneNumber;
        data["PhoneNumberConfirmed"] = this.phoneNumberConfirmed;
        data["TwoFactorEnabled"] = this.twoFactorEnabled;
        data["LockoutEnd"] = this.lockoutEnd ? this.lockoutEnd.toISOString() : <any>undefined;
        data["LockoutEnabled"] = this.lockoutEnabled;
        data["AccessFailedCount"] = this.accessFailedCount;
        data["UserGuid"] = this.userGuid;
        data["KpayMemberId"] = this.kpayMemberId;
        data["KpayUsername"] = this.kpayUsername;
        data["CustomerId"] = this.customerId;
        data["Customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        data["Version"] = this.version;
        data["IsAcceptKvk"] = this.isAcceptKvk;
        data["IsAcceptTerms"] = this.isAcceptTerms;
        data["IsAcceptContact"] = this.isAcceptContact;
        data["IsActive"] = this.isActive;
        data["IsDeleted"] = this.isDeleted;
        data["NewPhoneNumber"] = this.newPhoneNumber;
        data["Otp"] = this.otp;
        if (Array.isArray(this.userRoles)) {
            data["UserRoles"] = [];
            for (let item of this.userRoles)
                data["UserRoles"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUser {
    id?: number;
    userName?: string | undefined;
    normalizedUserName?: string | undefined;
    email?: string | undefined;
    normalizedEmail?: string | undefined;
    emailConfirmed?: boolean;
    passwordHash?: string | undefined;
    securityStamp?: string | undefined;
    concurrencyStamp?: string | undefined;
    phoneNumber?: string | undefined;
    phoneNumberConfirmed?: boolean;
    twoFactorEnabled?: boolean;
    lockoutEnd?: moment.Moment | undefined;
    lockoutEnabled?: boolean;
    accessFailedCount?: number;
    userGuid?: string;
    kpayMemberId?: string | undefined;
    kpayUsername?: string | undefined;
    customerId?: number | undefined;
    customer?: Customer;
    version?: number;
    isAcceptKvk?: boolean;
    isAcceptTerms?: boolean;
    isAcceptContact?: boolean;
    isActive?: boolean;
    isDeleted?: boolean;
    newPhoneNumber?: string | undefined;
    otp?: string | undefined;
    userRoles?: UserRole[] | undefined;
}

export class UserModel implements IUserModel {
    userId?: number;
    firstName?: string | undefined;
    lastName?: string | undefined;
    email?: string | undefined;
    phoneNumber?: string | undefined;
    institutionId?: number | undefined;
    institutionName?: string | undefined;
    departmentId?: number | undefined;
    departmentName?: string | undefined;

    constructor(data?: IUserModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["UserId"];
            this.firstName = _data["FirstName"];
            this.lastName = _data["LastName"];
            this.email = _data["Email"];
            this.phoneNumber = _data["PhoneNumber"];
            this.institutionId = _data["InstitutionId"];
            this.institutionName = _data["InstitutionName"];
            this.departmentId = _data["DepartmentId"];
            this.departmentName = _data["DepartmentName"];
        }
    }

    static fromJS(data: any): UserModel {
        data = typeof data === 'object' ? data : {};
        let result = new UserModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["UserId"] = this.userId;
        data["FirstName"] = this.firstName;
        data["LastName"] = this.lastName;
        data["Email"] = this.email;
        data["PhoneNumber"] = this.phoneNumber;
        data["InstitutionId"] = this.institutionId;
        data["InstitutionName"] = this.institutionName;
        data["DepartmentId"] = this.departmentId;
        data["DepartmentName"] = this.departmentName;
        return data;
    }
}

export interface IUserModel {
    userId?: number;
    firstName?: string | undefined;
    lastName?: string | undefined;
    email?: string | undefined;
    phoneNumber?: string | undefined;
    institutionId?: number | undefined;
    institutionName?: string | undefined;
    departmentId?: number | undefined;
    departmentName?: string | undefined;
}

export class UserRole implements IUserRole {
    userId?: number;
    user?: User;
    roleId?: number;
    role?: Role;

    constructor(data?: IUserRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["UserId"];
            this.user = _data["User"] ? User.fromJS(_data["User"]) : <any>undefined;
            this.roleId = _data["RoleId"];
            this.role = _data["Role"] ? Role.fromJS(_data["Role"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UserRole {
        data = typeof data === 'object' ? data : {};
        let result = new UserRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["UserId"] = this.userId;
        data["User"] = this.user ? this.user.toJSON() : <any>undefined;
        data["RoleId"] = this.roleId;
        data["Role"] = this.role ? this.role.toJSON() : <any>undefined;
        return data;
    }
}

export interface IUserRole {
    userId?: number;
    user?: User;
    roleId?: number;
    role?: Role;
}

export class VerifyModel implements IVerifyModel {
    otp!: string;
    phoneNumber!: string;

    constructor(data?: IVerifyModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.otp = _data["Otp"];
            this.phoneNumber = _data["PhoneNumber"];
        }
    }

    static fromJS(data: any): VerifyModel {
        data = typeof data === 'object' ? data : {};
        let result = new VerifyModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Otp"] = this.otp;
        data["PhoneNumber"] = this.phoneNumber;
        return data;
    }
}

export interface IVerifyModel {
    otp: string;
    phoneNumber: string;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}