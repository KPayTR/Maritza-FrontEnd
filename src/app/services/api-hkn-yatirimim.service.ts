//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import * as moment from 'moment';

export const MARITZA_API_URL = new InjectionToken<string>('MARITZA_API_URL');

@Injectable()
export class ServiceApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "/AppBackend/V1";
    }

    /**
     * Checks service access and returns server date time
     * @return Ok (Service is running and accessible)
     */
    ping(): Observable<PingResultDTO> {
        let url_ = this.baseUrl + "/Ping";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPing(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPing(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PingResultDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PingResultDTO>;
        }));
    }

    protected processPing(response: HttpResponseBase): Observable<PingResultDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PingResultDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = APIResultDTO.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PingResultDTO>(null as any);
    }

    /**
     * Returns a list of API Result codes and descriptions
     * @return Operation completed successfully
     */
    getAPIResultList(): Observable<APIResultDTO[]> {
        let url_ = this.baseUrl + "/APIResult";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAPIResultList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAPIResultList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<APIResultDTO[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<APIResultDTO[]>;
        }));
    }

    protected processGetAPIResultList(response: HttpResponseBase): Observable<APIResultDTO[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(APIResultDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = APIResultDTO.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<APIResultDTO[]>(null as any);
    }
}

@Injectable()
export class AuthenticationApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "/AppBackend/V1";
    }

    /**
     * Authenticates a member and returns a JWT
     * @param body Logon information
     * @return Operation completed successfully
     */
    authenticateMember(body: AuthenticationRequestDTO): Observable<AuthenticationResponseDTO> {
        let url_ = this.baseUrl + "/Authentication/Authenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthenticateMember(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthenticateMember(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AuthenticationResponseDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AuthenticationResponseDTO>;
        }));
    }

    protected processAuthenticateMember(response: HttpResponseBase): Observable<AuthenticationResponseDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthenticationResponseDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("No Content (Requested resource not found)", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = APIResultDTO.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = APIResultDTO.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = APIResultDTO.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = APIResultDTO.fromJS(resultData422);
            return throwException("Unprocessable Entity", status, _responseText, _headers, result422);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = APIResultDTO.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthenticationResponseDTO>(null as any);
    }

    /**
     * Creates an OTP (NNNNNN, e.g. 854269) and sends it to the member
     * @param oTPTarget Target GSM No or email address
     * @return OTP is sent
     */
    sendOTP(oTPTypeEnum: OTPTypeEnum, oTPTarget: string): Observable<void> {
        let url_ = this.baseUrl + "/Authentication/SendOTP?";
        if (oTPTypeEnum === undefined || oTPTypeEnum === null)
            throw new Error("The parameter 'oTPTypeEnum' must be defined and cannot be null.");
        else
            url_ += "OTPTypeEnum=" + encodeURIComponent("" + oTPTypeEnum) + "&";
        if (oTPTarget === undefined || oTPTarget === null)
            throw new Error("The parameter 'oTPTarget' must be defined and cannot be null.");
        else
            url_ += "OTPTarget=" + encodeURIComponent("" + oTPTarget) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendOTP(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendOTP(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSendOTP(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = APIResultDTO.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = APIResultDTO.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = APIResultDTO.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = APIResultDTO.fromJS(resultData422);
            return throwException("Unprocessable Entity", status, _responseText, _headers, result422);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = APIResultDTO.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * Checks if the OTP is correct and not timed out (3 mins)
     * @param oTPTarget Target GSM No or email address
     * @param oTP OTP to be checked
     * @return OTP is correct
     */
    checkOTP(oTPTypeEnum: OTPTypeEnum, oTPTarget: string, oTP: string): Observable<void> {
        let url_ = this.baseUrl + "/Authentication/CheckOTP?";
        if (oTPTypeEnum === undefined || oTPTypeEnum === null)
            throw new Error("The parameter 'oTPTypeEnum' must be defined and cannot be null.");
        else
            url_ += "OTPTypeEnum=" + encodeURIComponent("" + oTPTypeEnum) + "&";
        if (oTPTarget === undefined || oTPTarget === null)
            throw new Error("The parameter 'oTPTarget' must be defined and cannot be null.");
        else
            url_ += "OTPTarget=" + encodeURIComponent("" + oTPTarget) + "&";
        if (oTP === undefined || oTP === null)
            throw new Error("The parameter 'oTP' must be defined and cannot be null.");
        else
            url_ += "OTP=" + encodeURIComponent("" + oTP) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckOTP(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckOTP(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCheckOTP(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = APIResultDTO.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = APIResultDTO.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = APIResultDTO.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = APIResultDTO.fromJS(resultData422);
            return throwException("Unprocessable Entity", status, _responseText, _headers, result422);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = APIResultDTO.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class MemberApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "/AppBackend/V1";
    }

    /**
     * Creates a member
     * @param body Information about the member
     * @return The member created successfully
     */
    createMember(body: MemberCreateDTO): Observable<MemberDTO> {
        let url_ = this.baseUrl + "/Member";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateMember(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateMember(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MemberDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MemberDTO>;
        }));
    }

    protected processCreateMember(response: HttpResponseBase): Observable<MemberDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = MemberDTO.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = APIResultDTO.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = APIResultDTO.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = APIResultDTO.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = APIResultDTO.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = APIResultDTO.fromJS(resultData422);
            return throwException("Unprocessable Entity", status, _responseText, _headers, result422);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = APIResultDTO.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MemberDTO>(null as any);
    }

    /**
     * Gets member information
     * @return The member found
     */
    getMember(): Observable<MemberDTO> {
        let url_ = this.baseUrl + "/Member";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMember(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMember(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MemberDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MemberDTO>;
        }));
    }

    protected processGetMember(response: HttpResponseBase): Observable<MemberDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MemberDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("No Content (Requested resource not found)", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = APIResultDTO.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = APIResultDTO.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = APIResultDTO.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = APIResultDTO.fromJS(resultData422);
            return throwException("Unprocessable Entity", status, _responseText, _headers, result422);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = APIResultDTO.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MemberDTO>(null as any);
    }

    /**
     * Updates a member
     * @param body Information about the member
     * @return The member updated successfully
     */
    updateMember(body: MemberDTO): Observable<MemberDTO> {
        let url_ = this.baseUrl + "/Member";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateMember(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMember(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MemberDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MemberDTO>;
        }));
    }

    protected processUpdateMember(response: HttpResponseBase): Observable<MemberDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MemberDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("No Content (Requested resource not found)", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = APIResultDTO.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = APIResultDTO.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = APIResultDTO.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = APIResultDTO.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = APIResultDTO.fromJS(resultData422);
            return throwException("Unprocessable Entity", status, _responseText, _headers, result422);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = APIResultDTO.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MemberDTO>(null as any);
    }

    /**
     * Creates an address
     * @param body Information about the address
     * @return The address created successfully
     */
    createMemberAddress(body: MemberAddressDTO): Observable<MemberAddressDTO> {
        let url_ = this.baseUrl + "/Member/Address";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateMemberAddress(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateMemberAddress(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MemberAddressDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MemberAddressDTO>;
        }));
    }

    protected processCreateMemberAddress(response: HttpResponseBase): Observable<MemberAddressDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = MemberAddressDTO.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = APIResultDTO.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = APIResultDTO.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = APIResultDTO.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = APIResultDTO.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = APIResultDTO.fromJS(resultData422);
            return throwException("Unprocessable Entity", status, _responseText, _headers, result422);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = APIResultDTO.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MemberAddressDTO>(null as any);
    }

    /**
     * Gets address list
     * @return The address list
     */
    getMemberAddresses(): Observable<MemberAddressDTO[]> {
        let url_ = this.baseUrl + "/Member/Address";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMemberAddresses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMemberAddresses(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MemberAddressDTO[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MemberAddressDTO[]>;
        }));
    }

    protected processGetMemberAddresses(response: HttpResponseBase): Observable<MemberAddressDTO[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MemberAddressDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("No Content (Requested resource not found)", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = APIResultDTO.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = APIResultDTO.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = APIResultDTO.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = APIResultDTO.fromJS(resultData422);
            return throwException("Unprocessable Entity", status, _responseText, _headers, result422);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = APIResultDTO.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MemberAddressDTO[]>(null as any);
    }

    /**
     * Updates an address
     * @param body Information about address
     * @param rID Unique integer ID for the entity
     * @return The Address updated successfully
     */
    updateMemberAddress(body: MemberAddressDTO, rID: number): Observable<MemberAddressDTO> {
        let url_ = this.baseUrl + "/Member/Address/{RID}";
        if (rID === undefined || rID === null)
            throw new Error("The parameter 'rID' must be defined.");
        url_ = url_.replace("{RID}", encodeURIComponent("" + rID));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateMemberAddress(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMemberAddress(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MemberAddressDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MemberAddressDTO>;
        }));
    }

    protected processUpdateMemberAddress(response: HttpResponseBase): Observable<MemberAddressDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MemberAddressDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("No Content (Requested resource not found)", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = APIResultDTO.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = APIResultDTO.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = APIResultDTO.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = APIResultDTO.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = APIResultDTO.fromJS(resultData422);
            return throwException("Unprocessable Entity", status, _responseText, _headers, result422);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = APIResultDTO.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MemberAddressDTO>(null as any);
    }

    /**
     * Deletes an address
     * @param rID Unique integer ID for the entity
     * @return The address deleted successfully
     */
    deleteMemberAddress(rID: number): Observable<void> {
        let url_ = this.baseUrl + "/Member/Address/{RID}";
        if (rID === undefined || rID === null)
            throw new Error("The parameter 'rID' must be defined.");
        url_ = url_.replace("{RID}", encodeURIComponent("" + rID));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteMemberAddress(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMemberAddress(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteMemberAddress(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = APIResultDTO.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = APIResultDTO.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = APIResultDTO.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = APIResultDTO.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = APIResultDTO.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * Creates a bank account
     * @param body Information about the bank account
     * @return The bank account created successfully
     */
    createMemberBankAccount(body: MemberBankAccountDTO): Observable<MemberBankAccountDTO> {
        let url_ = this.baseUrl + "/Member/BankAccount";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateMemberBankAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateMemberBankAccount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MemberBankAccountDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MemberBankAccountDTO>;
        }));
    }

    protected processCreateMemberBankAccount(response: HttpResponseBase): Observable<MemberBankAccountDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = MemberBankAccountDTO.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = APIResultDTO.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = APIResultDTO.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = APIResultDTO.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = APIResultDTO.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = APIResultDTO.fromJS(resultData422);
            return throwException("Unprocessable Entity", status, _responseText, _headers, result422);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = APIResultDTO.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MemberBankAccountDTO>(null as any);
    }

    /**
     * Gets bank account list
     * @return The bank account list
     */
    getMemberBankAccounts(): Observable<MemberBankAccountDTO[]> {
        let url_ = this.baseUrl + "/Member/BankAccount";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMemberBankAccounts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMemberBankAccounts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MemberBankAccountDTO[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MemberBankAccountDTO[]>;
        }));
    }

    protected processGetMemberBankAccounts(response: HttpResponseBase): Observable<MemberBankAccountDTO[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MemberBankAccountDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("No Content (Requested resource not found)", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = APIResultDTO.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = APIResultDTO.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = APIResultDTO.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = APIResultDTO.fromJS(resultData422);
            return throwException("Unprocessable Entity", status, _responseText, _headers, result422);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = APIResultDTO.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MemberBankAccountDTO[]>(null as any);
    }

    /**
     * Updates a bank account
     * @param body Information about bank account
     * @param rID Unique integer ID for the entity
     * @return The BankAccount updated successfully
     */
    updateMemberBankAccount(body: MemberBankAccountDTO, rID: number): Observable<MemberBankAccountDTO> {
        let url_ = this.baseUrl + "/Member/BankAccount/{RID}";
        if (rID === undefined || rID === null)
            throw new Error("The parameter 'rID' must be defined.");
        url_ = url_.replace("{RID}", encodeURIComponent("" + rID));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateMemberBankAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMemberBankAccount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MemberBankAccountDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MemberBankAccountDTO>;
        }));
    }

    protected processUpdateMemberBankAccount(response: HttpResponseBase): Observable<MemberBankAccountDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MemberBankAccountDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("No Content (Requested resource not found)", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = APIResultDTO.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = APIResultDTO.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = APIResultDTO.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = APIResultDTO.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = APIResultDTO.fromJS(resultData422);
            return throwException("Unprocessable Entity", status, _responseText, _headers, result422);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = APIResultDTO.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MemberBankAccountDTO>(null as any);
    }

    /**
     * Deletes a bank account
     * @param rID Unique integer ID for the entity
     * @return The bank account deleted successfully
     */
    deleteMemberBankAccount(rID: number): Observable<void> {
        let url_ = this.baseUrl + "/Member/BankAccount/{RID}";
        if (rID === undefined || rID === null)
            throw new Error("The parameter 'rID' must be defined.");
        url_ = url_.replace("{RID}", encodeURIComponent("" + rID));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteMemberBankAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMemberBankAccount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteMemberBankAccount(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = APIResultDTO.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = APIResultDTO.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = APIResultDTO.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = APIResultDTO.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = APIResultDTO.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * Posts a comment
     * @param body Information about the comment
     * @return The comment created successfully
     */
    postMemberComment(body: MemberCommentDTO): Observable<void> {
        let url_ = this.baseUrl + "/Member/Comment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostMemberComment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostMemberComment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPostMemberComment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = APIResultDTO.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = APIResultDTO.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = APIResultDTO.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = APIResultDTO.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = APIResultDTO.fromJS(resultData422);
            return throwException("Unprocessable Entity", status, _responseText, _headers, result422);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = APIResultDTO.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * Returns a paginated list of Member Comments
     * @param symbolRID Unique integer ID for a Symbol
     * @param pageNumber The requested page number
     * @param pageSize The requested page size
     * @return List of Member Comments
     */
    getPaginatedMemberCommentList(symbolRID: number, pageNumber: number, pageSize: number): Observable<PaginatedMemberCommentListDTO> {
        let url_ = this.baseUrl + "/Member/Comment?";
        if (symbolRID === undefined || symbolRID === null)
            throw new Error("The parameter 'symbolRID' must be defined and cannot be null.");
        else
            url_ += "SymbolRID=" + encodeURIComponent("" + symbolRID) + "&";
        if (pageNumber === undefined || pageNumber === null)
            throw new Error("The parameter 'pageNumber' must be defined and cannot be null.");
        else
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === undefined || pageSize === null)
            throw new Error("The parameter 'pageSize' must be defined and cannot be null.");
        else
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaginatedMemberCommentList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaginatedMemberCommentList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedMemberCommentListDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedMemberCommentListDTO>;
        }));
    }

    protected processGetPaginatedMemberCommentList(response: HttpResponseBase): Observable<PaginatedMemberCommentListDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedMemberCommentListDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("No Content (Requested resource not found)", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = APIResultDTO.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = APIResultDTO.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = APIResultDTO.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = APIResultDTO.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = APIResultDTO.fromJS(resultData422);
            return throwException("Unprocessable Entity", status, _responseText, _headers, result422);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = APIResultDTO.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaginatedMemberCommentListDTO>(null as any);
    }

    /**
     * Gets member devices
     * @return Device list
     */
    getMemberDevices(): Observable<MemberDeviceDTO[]> {
        let url_ = this.baseUrl + "/Member/Device";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMemberDevices(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMemberDevices(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MemberDeviceDTO[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MemberDeviceDTO[]>;
        }));
    }

    protected processGetMemberDevices(response: HttpResponseBase): Observable<MemberDeviceDTO[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MemberDeviceDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("No Content (Requested resource not found)", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = APIResultDTO.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = APIResultDTO.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = APIResultDTO.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = APIResultDTO.fromJS(resultData422);
            return throwException("Unprocessable Entity", status, _responseText, _headers, result422);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = APIResultDTO.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MemberDeviceDTO[]>(null as any);
    }

    /**
     * Posts a document
     * @param body Information about the document
     * @return The document created successfully
     */
    postMemberDocument(body: MemberDocumentDTO): Observable<void> {
        let url_ = this.baseUrl + "/Member/Document";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostMemberDocument(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostMemberDocument(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPostMemberDocument(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = APIResultDTO.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = APIResultDTO.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = APIResultDTO.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = APIResultDTO.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = APIResultDTO.fromJS(resultData422);
            return throwException("Unprocessable Entity", status, _responseText, _headers, result422);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = APIResultDTO.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * Posts a vote
     * @param body Information about the vote
     * @return The vote created successfully
     */
    postMemberVote(body: MemberVoteDTO): Observable<SymbolVoteDTO> {
        let url_ = this.baseUrl + "/Member/Vote";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostMemberVote(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostMemberVote(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SymbolVoteDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SymbolVoteDTO>;
        }));
    }

    protected processPostMemberVote(response: HttpResponseBase): Observable<SymbolVoteDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = SymbolVoteDTO.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = APIResultDTO.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = APIResultDTO.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = APIResultDTO.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = APIResultDTO.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = APIResultDTO.fromJS(resultData422);
            return throwException("Unprocessable Entity", status, _responseText, _headers, result422);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = APIResultDTO.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SymbolVoteDTO>(null as any);
    }
}

@Injectable()
export class FinanceApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "/AppBackend/V1";
    }

    /**
     * Gets list of symbols
     * @return Symbol list
     */
    getSymbolList(): Observable<SymbolDTO[]> {
        let url_ = this.baseUrl + "/Symbol";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSymbolList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSymbolList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SymbolDTO[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SymbolDTO[]>;
        }));
    }

    protected processGetSymbolList(response: HttpResponseBase): Observable<SymbolDTO[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SymbolDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("No Content (Requested resource not found)", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = APIResultDTO.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = APIResultDTO.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = APIResultDTO.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = APIResultDTO.fromJS(resultData422);
            return throwException("Unprocessable Entity", status, _responseText, _headers, result422);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = APIResultDTO.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SymbolDTO[]>(null as any);
    }

    /**
     * Gets a symbol's rate info
     * @param rIDList List of comma delimited RIDs
     * @return Symbol info
     */
    getSymbolRates(rIDList: string): Observable<SymbolRateDTO[]> {
        let url_ = this.baseUrl + "/Symbol/Rate?";
        if (rIDList === undefined || rIDList === null)
            throw new Error("The parameter 'rIDList' must be defined and cannot be null.");
        else
            url_ += "RIDList=" + encodeURIComponent("" + rIDList) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSymbolRates(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSymbolRates(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SymbolRateDTO[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SymbolRateDTO[]>;
        }));
    }

    protected processGetSymbolRates(response: HttpResponseBase): Observable<SymbolRateDTO[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SymbolRateDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("No Content (Requested resource not found)", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = APIResultDTO.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = APIResultDTO.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = APIResultDTO.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = APIResultDTO.fromJS(resultData422);
            return throwException("Unprocessable Entity", status, _responseText, _headers, result422);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = APIResultDTO.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SymbolRateDTO[]>(null as any);
    }

    /**
     * Gets symbol vote
     * @param rID Unique integer ID for the entity
     * @return Symbol vote for the day
     */
    getSymbolVote(rID: number): Observable<SymbolVoteDTO> {
        let url_ = this.baseUrl + "/Symbol/{RID}/Vote";
        if (rID === undefined || rID === null)
            throw new Error("The parameter 'rID' must be defined.");
        url_ = url_.replace("{RID}", encodeURIComponent("" + rID));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSymbolVote(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSymbolVote(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SymbolVoteDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SymbolVoteDTO>;
        }));
    }

    protected processGetSymbolVote(response: HttpResponseBase): Observable<SymbolVoteDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SymbolVoteDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("No Content (Requested resource not found)", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = APIResultDTO.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = APIResultDTO.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = APIResultDTO.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = APIResultDTO.fromJS(resultData422);
            return throwException("Unprocessable Entity", status, _responseText, _headers, result422);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = APIResultDTO.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SymbolVoteDTO>(null as any);
    }
}

@Injectable()
export class SystemApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MARITZA_API_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "/AppBackend/V1";
    }

    /**
     * Returns list of provinces
     * @return OK (The request has succeeded)
     */
    getProvinces(): Observable<ProvinceDTO[]> {
        let url_ = this.baseUrl + "/System/Province";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProvinces(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProvinces(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProvinceDTO[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProvinceDTO[]>;
        }));
    }

    protected processGetProvinces(response: HttpResponseBase): Observable<ProvinceDTO[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProvinceDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = APIResultDTO.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = APIResultDTO.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = APIResultDTO.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = APIResultDTO.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProvinceDTO[]>(null as any);
    }

    /**
     * Returns list of districts for a province
     * @param provinceRID Unique integer ID for a Province
     * @return OK (The request has succeeded)
     */
    getDistricts(provinceRID: number): Observable<DistrictDTO[]> {
        let url_ = this.baseUrl + "/System/Province/{ProvinceRID}/District";
        if (provinceRID === undefined || provinceRID === null)
            throw new Error("The parameter 'provinceRID' must be defined.");
        url_ = url_.replace("{ProvinceRID}", encodeURIComponent("" + provinceRID));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDistricts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDistricts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DistrictDTO[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DistrictDTO[]>;
        }));
    }

    protected processGetDistricts(response: HttpResponseBase): Observable<DistrictDTO[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DistrictDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = APIResultDTO.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = APIResultDTO.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = APIResultDTO.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = APIResultDTO.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DistrictDTO[]>(null as any);
    }
}

/** Language */
export enum LanguageEnum {
    TR = "TR",
    EN = "EN",
}

/** Type of the connecting device */
export enum DeviceTypeEnum {
    AndroidPhone = "AndroidPhone",
    AndroidTablet = "AndroidTablet",
    ApplePhone = "ApplePhone",
    AppleTablet = "AppleTablet",
    Web = "Web",
}

/** Member authentication request */
export class AuthenticationRequestDTO implements IAuthenticationRequestDTO {
    gSMNo!: string;
    password!: string;
    deviceID!: string;
    deviceType!: DeviceTypeEnum;
    fCMToken!: string;
    isNewDevice!: boolean;

    constructor(data?: IAuthenticationRequestDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.isNewDevice = false;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gSMNo = _data["GSMNo"];
            this.password = _data["Password"];
            this.deviceID = _data["DeviceID"];
            this.deviceType = _data["DeviceType"];
            this.fCMToken = _data["FCMToken"];
            this.isNewDevice = _data["IsNewDevice"] !== undefined ? _data["IsNewDevice"] : false;
        }
    }

    static fromJS(data: any): AuthenticationRequestDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticationRequestDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["GSMNo"] = this.gSMNo;
        data["Password"] = this.password;
        data["DeviceID"] = this.deviceID;
        data["DeviceType"] = this.deviceType;
        data["FCMToken"] = this.fCMToken;
        data["IsNewDevice"] = this.isNewDevice;
        return data;
    }
}

/** Member authentication request */
export interface IAuthenticationRequestDTO {
    gSMNo: string;
    password: string;
    deviceID: string;
    deviceType: DeviceTypeEnum;
    fCMToken: string;
    isNewDevice: boolean;
}

/** Member authentication response */
export class AuthenticationResponseDTO implements IAuthenticationResponseDTO {
    jWT?: string;
    member?: MemberDTO;

    constructor(data?: IAuthenticationResponseDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.jWT = _data["JWT"];
            this.member = _data["Member"] ? MemberDTO.fromJS(_data["Member"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AuthenticationResponseDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticationResponseDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["JWT"] = this.jWT;
        data["Member"] = this.member ? this.member.toJSON() : <any>undefined;
        return data;
    }
}

/** Member authentication response */
export interface IAuthenticationResponseDTO {
    jWT?: string;
    member?: MemberDTO;
}

/** Type of the member */
export enum MemberTypeEnum {
    Personal = "Personal",
    Corporate = "Corporate",
}

/** Member information for creation */
export class MemberCreateDTO implements IMemberCreateDTO {
    memberType!: MemberTypeEnum;
    /** First name of the member */
    firstName!: string;
    /** Last name of the member */
    lastName!: string;
    gSMNo!: string;
    email!: string;
    password?: string;
    selectedLanguage!: LanguageEnum;
    /** The member has accepted the End User Agreement (default is true) */
    hasAcceptedEUA!: boolean;
    /** The member has accepted the Storage and Use of Personal Data Agreement */
    hasAcceptedSUPDA!: boolean;
    /** The member has accepted has accepted notifications */
    hasAcceptedNotifications!: boolean;
    /** Free storage for member specific data (preferably in JSON) */
    data?: string;
    tCKN?: string;
    officialName?: string;
    taxOffice?: string;
    taxNumber?: string;
    mERSISNo?: string;

    constructor(data?: IMemberCreateDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.hasAcceptedEUA = true;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberType = _data["MemberType"];
            this.firstName = _data["FirstName"];
            this.lastName = _data["LastName"];
            this.gSMNo = _data["GSMNo"];
            this.email = _data["Email"];
            this.password = _data["Password"];
            this.selectedLanguage = _data["SelectedLanguage"];
            this.hasAcceptedEUA = _data["HasAcceptedEUA"] !== undefined ? _data["HasAcceptedEUA"] : true;
            this.hasAcceptedSUPDA = _data["HasAcceptedSUPDA"];
            this.hasAcceptedNotifications = _data["HasAcceptedNotifications"];
            this.data = _data["Data"];
            this.tCKN = _data["TCKN"];
            this.officialName = _data["OfficialName"];
            this.taxOffice = _data["TaxOffice"];
            this.taxNumber = _data["TaxNumber"];
            this.mERSISNo = _data["MERSISNo"];
        }
    }

    static fromJS(data: any): MemberCreateDTO {
        data = typeof data === 'object' ? data : {};
        let result = new MemberCreateDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["MemberType"] = this.memberType;
        data["FirstName"] = this.firstName;
        data["LastName"] = this.lastName;
        data["GSMNo"] = this.gSMNo;
        data["Email"] = this.email;
        data["Password"] = this.password;
        data["SelectedLanguage"] = this.selectedLanguage;
        data["HasAcceptedEUA"] = this.hasAcceptedEUA;
        data["HasAcceptedSUPDA"] = this.hasAcceptedSUPDA;
        data["HasAcceptedNotifications"] = this.hasAcceptedNotifications;
        data["Data"] = this.data;
        data["TCKN"] = this.tCKN;
        data["OfficialName"] = this.officialName;
        data["TaxOffice"] = this.taxOffice;
        data["TaxNumber"] = this.taxNumber;
        data["MERSISNo"] = this.mERSISNo;
        return data;
    }
}

/** Member information for creation */
export interface IMemberCreateDTO {
    memberType: MemberTypeEnum;
    /** First name of the member */
    firstName: string;
    /** Last name of the member */
    lastName: string;
    gSMNo: string;
    email: string;
    password?: string;
    selectedLanguage: LanguageEnum;
    /** The member has accepted the End User Agreement (default is true) */
    hasAcceptedEUA: boolean;
    /** The member has accepted the Storage and Use of Personal Data Agreement */
    hasAcceptedSUPDA: boolean;
    /** The member has accepted has accepted notifications */
    hasAcceptedNotifications: boolean;
    /** Free storage for member specific data (preferably in JSON) */
    data?: string;
    tCKN?: string;
    officialName?: string;
    taxOffice?: string;
    taxNumber?: string;
    mERSISNo?: string;
}

/** Member information for retrieval and update */
export class MemberDTO implements IMemberDTO {
    rID?: number | undefined;
    memberID?: string;
    memberType?: MemberTypeEnum;
    /** True if the member is active */
    isActive?: boolean;
    isSMSVerified?: boolean;
    isEmailVerified?: boolean;
    isApproved?: boolean;
    createdOn?: moment.Moment | undefined;
    modifiedOn?: moment.Moment | undefined;
    /** First name of the member */
    firstName?: string;
    /** Last name of the member */
    lastName?: string;
    gSMNo?: string;
    email?: string;
    password?: string;
    selectedLanguage?: LanguageEnum;
    /** The member has accepted the End User Agreement (default is true) */
    hasAcceptedEUA?: boolean;
    /** The member has accepted the Storage and Use of Personal Data Agreement */
    hasAcceptedSUPDA?: boolean;
    /** The member has accepted has accepted notifications */
    hasAcceptedNotifications?: boolean;
    /** Free storage for member specific data (preferably in JSON) */
    data?: string;
    tCKN?: string;
    officialName?: string;
    taxOffice?: string;
    taxNumber?: string;
    mERSISNo?: string;

    constructor(data?: IMemberDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.hasAcceptedEUA = true;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rID = _data["RID"];
            this.memberID = _data["MemberID"];
            this.memberType = _data["MemberType"];
            this.isActive = _data["IsActive"];
            this.isSMSVerified = _data["IsSMSVerified"];
            this.isEmailVerified = _data["IsEmailVerified"];
            this.isApproved = _data["IsApproved"];
            this.createdOn = _data["CreatedOn"] ? moment(_data["CreatedOn"].toString()) : <any>undefined;
            this.modifiedOn = _data["ModifiedOn"] ? moment(_data["ModifiedOn"].toString()) : <any>undefined;
            this.firstName = _data["FirstName"];
            this.lastName = _data["LastName"];
            this.gSMNo = _data["GSMNo"];
            this.email = _data["Email"];
            this.password = _data["Password"];
            this.selectedLanguage = _data["SelectedLanguage"];
            this.hasAcceptedEUA = _data["HasAcceptedEUA"] !== undefined ? _data["HasAcceptedEUA"] : true;
            this.hasAcceptedSUPDA = _data["HasAcceptedSUPDA"];
            this.hasAcceptedNotifications = _data["HasAcceptedNotifications"];
            this.data = _data["Data"];
            this.tCKN = _data["TCKN"];
            this.officialName = _data["OfficialName"];
            this.taxOffice = _data["TaxOffice"];
            this.taxNumber = _data["TaxNumber"];
            this.mERSISNo = _data["MERSISNo"];
        }
    }

    static fromJS(data: any): MemberDTO {
        data = typeof data === 'object' ? data : {};
        let result = new MemberDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["RID"] = this.rID;
        data["MemberID"] = this.memberID;
        data["MemberType"] = this.memberType;
        data["IsActive"] = this.isActive;
        data["IsSMSVerified"] = this.isSMSVerified;
        data["IsEmailVerified"] = this.isEmailVerified;
        data["IsApproved"] = this.isApproved;
        data["CreatedOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["ModifiedOn"] = this.modifiedOn ? this.modifiedOn.toISOString() : <any>undefined;
        data["FirstName"] = this.firstName;
        data["LastName"] = this.lastName;
        data["GSMNo"] = this.gSMNo;
        data["Email"] = this.email;
        data["Password"] = this.password;
        data["SelectedLanguage"] = this.selectedLanguage;
        data["HasAcceptedEUA"] = this.hasAcceptedEUA;
        data["HasAcceptedSUPDA"] = this.hasAcceptedSUPDA;
        data["HasAcceptedNotifications"] = this.hasAcceptedNotifications;
        data["Data"] = this.data;
        data["TCKN"] = this.tCKN;
        data["OfficialName"] = this.officialName;
        data["TaxOffice"] = this.taxOffice;
        data["TaxNumber"] = this.taxNumber;
        data["MERSISNo"] = this.mERSISNo;
        return data;
    }
}

/** Member information for retrieval and update */
export interface IMemberDTO {
    rID?: number | undefined;
    memberID?: string;
    memberType?: MemberTypeEnum;
    /** True if the member is active */
    isActive?: boolean;
    isSMSVerified?: boolean;
    isEmailVerified?: boolean;
    isApproved?: boolean;
    createdOn?: moment.Moment | undefined;
    modifiedOn?: moment.Moment | undefined;
    /** First name of the member */
    firstName?: string;
    /** Last name of the member */
    lastName?: string;
    gSMNo?: string;
    email?: string;
    password?: string;
    selectedLanguage?: LanguageEnum;
    /** The member has accepted the End User Agreement (default is true) */
    hasAcceptedEUA?: boolean;
    /** The member has accepted the Storage and Use of Personal Data Agreement */
    hasAcceptedSUPDA?: boolean;
    /** The member has accepted has accepted notifications */
    hasAcceptedNotifications?: boolean;
    /** Free storage for member specific data (preferably in JSON) */
    data?: string;
    tCKN?: string;
    officialName?: string;
    taxOffice?: string;
    taxNumber?: string;
    mERSISNo?: string;
}

/** Member device */
export class MemberAddressDTO implements IMemberAddressDTO {
    rID?: number | undefined;
    name!: string;
    address1!: string;
    address2?: string;
    postalCode!: string;
    provinceRID!: number | undefined;
    districtRID!: number | undefined;

    constructor(data?: IMemberAddressDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rID = _data["RID"];
            this.name = _data["Name"];
            this.address1 = _data["Address1"];
            this.address2 = _data["Address2"];
            this.postalCode = _data["PostalCode"];
            this.provinceRID = _data["ProvinceRID"];
            this.districtRID = _data["DistrictRID"];
        }
    }

    static fromJS(data: any): MemberAddressDTO {
        data = typeof data === 'object' ? data : {};
        let result = new MemberAddressDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["RID"] = this.rID;
        data["Name"] = this.name;
        data["Address1"] = this.address1;
        data["Address2"] = this.address2;
        data["PostalCode"] = this.postalCode;
        data["ProvinceRID"] = this.provinceRID;
        data["DistrictRID"] = this.districtRID;
        return data;
    }
}

/** Member device */
export interface IMemberAddressDTO {
    rID?: number | undefined;
    name: string;
    address1: string;
    address2?: string;
    postalCode: string;
    provinceRID: number | undefined;
    districtRID: number | undefined;
}

/** Member bank account */
export class MemberBankAccountDTO implements IMemberBankAccountDTO {
    rID?: number | undefined;
    name!: string;
    iBANNo!: string;

    constructor(data?: IMemberBankAccountDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rID = _data["RID"];
            this.name = _data["Name"];
            this.iBANNo = _data["IBANNo"];
        }
    }

    static fromJS(data: any): MemberBankAccountDTO {
        data = typeof data === 'object' ? data : {};
        let result = new MemberBankAccountDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["RID"] = this.rID;
        data["Name"] = this.name;
        data["IBANNo"] = this.iBANNo;
        return data;
    }
}

/** Member bank account */
export interface IMemberBankAccountDTO {
    rID?: number | undefined;
    name: string;
    iBANNo: string;
}

/** Member device */
export class MemberDeviceDTO implements IMemberDeviceDTO {
    rID?: number | undefined;
    deviceID?: string;
    deviceType?: DeviceTypeEnum;
    fCMToken?: string;
    lastActiveTimeStamp?: moment.Moment | undefined;

    constructor(data?: IMemberDeviceDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rID = _data["RID"];
            this.deviceID = _data["DeviceID"];
            this.deviceType = _data["DeviceType"];
            this.fCMToken = _data["FCMToken"];
            this.lastActiveTimeStamp = _data["LastActiveTimeStamp"] ? moment(_data["LastActiveTimeStamp"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): MemberDeviceDTO {
        data = typeof data === 'object' ? data : {};
        let result = new MemberDeviceDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["RID"] = this.rID;
        data["DeviceID"] = this.deviceID;
        data["DeviceType"] = this.deviceType;
        data["FCMToken"] = this.fCMToken;
        data["LastActiveTimeStamp"] = this.lastActiveTimeStamp ? this.lastActiveTimeStamp.toISOString() : <any>undefined;
        return data;
    }
}

/** Member device */
export interface IMemberDeviceDTO {
    rID?: number | undefined;
    deviceID?: string;
    deviceType?: DeviceTypeEnum;
    fCMToken?: string;
    lastActiveTimeStamp?: moment.Moment | undefined;
}

/** Type of the vote */
export enum SymbolVoteEnum {
    Up = "Up",
    Down = "Down",
}

/** Member vote */
export class MemberVoteDTO implements IMemberVoteDTO {
    symbolRID?: number | undefined;
    symbolVote?: SymbolVoteEnum;

    constructor(data?: IMemberVoteDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.symbolRID = _data["SymbolRID"];
            this.symbolVote = _data["SymbolVote"];
        }
    }

    static fromJS(data: any): MemberVoteDTO {
        data = typeof data === 'object' ? data : {};
        let result = new MemberVoteDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["SymbolRID"] = this.symbolRID;
        data["SymbolVote"] = this.symbolVote;
        return data;
    }
}

/** Member vote */
export interface IMemberVoteDTO {
    symbolRID?: number | undefined;
    symbolVote?: SymbolVoteEnum;
}

/** Member comment */
export class MemberCommentDTO implements IMemberCommentDTO {
    symbolRID!: number | undefined;
    /** Comment */
    comment!: string;

    constructor(data?: IMemberCommentDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.symbolRID = _data["SymbolRID"];
            this.comment = _data["Comment"];
        }
    }

    static fromJS(data: any): MemberCommentDTO {
        data = typeof data === 'object' ? data : {};
        let result = new MemberCommentDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["SymbolRID"] = this.symbolRID;
        data["Comment"] = this.comment;
        return data;
    }
}

/** Member comment */
export interface IMemberCommentDTO {
    symbolRID: number | undefined;
    /** Comment */
    comment: string;
}

/** Full member comment */
export class FullMemberCommentDTO implements IFullMemberCommentDTO {
    timeStamp?: moment.Moment | undefined;
    /** Comment */
    poster?: string;
    /** Comment */
    comment?: string;

    constructor(data?: IFullMemberCommentDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.timeStamp = _data["TimeStamp"] ? moment(_data["TimeStamp"].toString()) : <any>undefined;
            this.poster = _data["Poster"];
            this.comment = _data["Comment"];
        }
    }

    static fromJS(data: any): FullMemberCommentDTO {
        data = typeof data === 'object' ? data : {};
        let result = new FullMemberCommentDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["TimeStamp"] = this.timeStamp ? this.timeStamp.toISOString() : <any>undefined;
        data["Poster"] = this.poster;
        data["Comment"] = this.comment;
        return data;
    }
}

/** Full member comment */
export interface IFullMemberCommentDTO {
    timeStamp?: moment.Moment | undefined;
    /** Comment */
    poster?: string;
    /** Comment */
    comment?: string;
}

/** Paginated comment list */
export class PaginatedMemberCommentListDTO implements IPaginatedMemberCommentListDTO {
    paginationInfo!: PaginationInfo;
    /** Zero or more comments */
    memberCommentList!: FullMemberCommentDTO[];

    constructor(data?: IPaginatedMemberCommentListDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.paginationInfo = new PaginationInfo();
            this.memberCommentList = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.paginationInfo = _data["PaginationInfo"] ? PaginationInfo.fromJS(_data["PaginationInfo"]) : new PaginationInfo();
            if (Array.isArray(_data["MemberCommentList"])) {
                this.memberCommentList = [] as any;
                for (let item of _data["MemberCommentList"])
                    this.memberCommentList!.push(FullMemberCommentDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PaginatedMemberCommentListDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedMemberCommentListDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["PaginationInfo"] = this.paginationInfo ? this.paginationInfo.toJSON() : <any>undefined;
        if (Array.isArray(this.memberCommentList)) {
            data["MemberCommentList"] = [];
            for (let item of this.memberCommentList)
                data["MemberCommentList"].push(item.toJSON());
        }
        return data;
    }
}

/** Paginated comment list */
export interface IPaginatedMemberCommentListDTO {
    paginationInfo: PaginationInfo;
    /** Zero or more comments */
    memberCommentList: FullMemberCommentDTO[];
}

/** Type of the member document */
export enum MemberDocumentTypeEnum {
    PersonalTCIDFront = "PersonalTCIDFront",
    PersonalTCIDBack = "PersonalTCIDBack",
    PersonalIkametgah = "PersonalIkametgah",
    CorporateImzaSirkuleri = "CorporateImzaSirkuleri",
    CorporateVergiLevhasi = "CorporateVergiLevhasi",
    CorporateSicilGazetesi = "CorporateSicilGazetesi",
    CorporateFaaliyetBelgesi = "CorporateFaaliyetBelgesi",
}

/** Document information */
export class MemberDocumentDTO implements IMemberDocumentDTO {
    memberDocumentType!: MemberDocumentTypeEnum;
    /** Base64 encoded document e.g. 'IUQxr2boxf1v9VcIYPY3/8AoOEU9XoNhzsAAAAASUVORK5CYII=' */
    document!: string;

    constructor(data?: IMemberDocumentDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberDocumentType = _data["MemberDocumentType"];
            this.document = _data["Document"];
        }
    }

    static fromJS(data: any): MemberDocumentDTO {
        data = typeof data === 'object' ? data : {};
        let result = new MemberDocumentDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["MemberDocumentType"] = this.memberDocumentType;
        data["Document"] = this.document;
        return data;
    }
}

/** Document information */
export interface IMemberDocumentDTO {
    memberDocumentType: MemberDocumentTypeEnum;
    /** Base64 encoded document e.g. 'IUQxr2boxf1v9VcIYPY3/8AoOEU9XoNhzsAAAAASUVORK5CYII=' */
    document: string;
}

/** Type of the complaint */
export enum ComplaintTypeEnum {
    Complaint = "Complaint",
    Suggestion = "Suggestion",
    PaymentProblem = "PaymentProblem",
    SellerProblem = "SellerProblem",
    RefundRequest = "RefundRequest",
}

/** Complaint information */
export class ComplaintDTO implements IComplaintDTO {
    complaintType!: ComplaintTypeEnum;
    /** Text of the complaint */
    complaintText!: string;

    constructor(data?: IComplaintDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.complaintType = _data["ComplaintType"];
            this.complaintText = _data["ComplaintText"];
        }
    }

    static fromJS(data: any): ComplaintDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ComplaintDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ComplaintType"] = this.complaintType;
        data["ComplaintText"] = this.complaintText;
        return data;
    }
}

/** Complaint information */
export interface IComplaintDTO {
    complaintType: ComplaintTypeEnum;
    /** Text of the complaint */
    complaintText: string;
}

/** Type of the symbol */
export enum SymbolTypeEnum {
    Forex = "Forex",
    Metal = "Metal",
    Index = "Index",
    Commodity = "Commodity",
    Future = "Future",
    Share = "Share",
    Crypto = "Crypto",
    Sarrafiye = "Sarrafiye",
}

/** Direction of the rate change */
export enum ChangeDirectionEnum {
    Up = "Up",
    Down = "Down",
    Constant = "Constant",
}

/** Symbol */
export class SymbolDTO implements ISymbolDTO {
    rID?: number | undefined;
    /** Symbol ISO Code */
    iSOCode?: string;
    /** Name of the symbol */
    name?: string;
    symbolType?: SymbolTypeEnum;
    /** Symbol currency sign */
    currencySign?: string;
    /** Is trading of the symbol enabled */
    isTradingEnabled?: boolean;
    /** Base64 encoded visual e.g. 'IUQxr2boxf1v9VcIYPY3/8AoOEU9XoNhzsAAAAASUVORK5CYII=' */
    visual?: string;

    constructor(data?: ISymbolDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rID = _data["RID"];
            this.iSOCode = _data["ISOCode"];
            this.name = _data["Name"];
            this.symbolType = _data["SymbolType"];
            this.currencySign = _data["CurrencySign"];
            this.isTradingEnabled = _data["IsTradingEnabled"];
            this.visual = _data["Visual"];
        }
    }

    static fromJS(data: any): SymbolDTO {
        data = typeof data === 'object' ? data : {};
        let result = new SymbolDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["RID"] = this.rID;
        data["ISOCode"] = this.iSOCode;
        data["Name"] = this.name;
        data["SymbolType"] = this.symbolType;
        data["CurrencySign"] = this.currencySign;
        data["IsTradingEnabled"] = this.isTradingEnabled;
        data["Visual"] = this.visual;
        return data;
    }
}

/** Symbol */
export interface ISymbolDTO {
    rID?: number | undefined;
    /** Symbol ISO Code */
    iSOCode?: string;
    /** Name of the symbol */
    name?: string;
    symbolType?: SymbolTypeEnum;
    /** Symbol currency sign */
    currencySign?: string;
    /** Is trading of the symbol enabled */
    isTradingEnabled?: boolean;
    /** Base64 encoded visual e.g. 'IUQxr2boxf1v9VcIYPY3/8AoOEU9XoNhzsAAAAASUVORK5CYII=' */
    visual?: string;
}

/** Symbol vote */
export class SymbolVoteDTO implements ISymbolVoteDTO {
    /** Has member voted for the symbol today */
    hasMemberVoted?: boolean;
    voteUpPercent?: number;
    voteDownPercent?: number;

    constructor(data?: ISymbolVoteDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasMemberVoted = _data["HasMemberVoted"];
            this.voteUpPercent = _data["VoteUpPercent"];
            this.voteDownPercent = _data["VoteDownPercent"];
        }
    }

    static fromJS(data: any): SymbolVoteDTO {
        data = typeof data === 'object' ? data : {};
        let result = new SymbolVoteDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["HasMemberVoted"] = this.hasMemberVoted;
        data["VoteUpPercent"] = this.voteUpPercent;
        data["VoteDownPercent"] = this.voteDownPercent;
        return data;
    }
}

/** Symbol vote */
export interface ISymbolVoteDTO {
    /** Has member voted for the symbol today */
    hasMemberVoted?: boolean;
    voteUpPercent?: number;
    voteDownPercent?: number;
}

/** Symbol rate */
export class SymbolRateDTO implements ISymbolRateDTO {
    symbolRID?: number | undefined;
    syncTimeStamp?: moment.Moment | undefined;
    rateTimeStamp?: moment.Moment | undefined;
    buyTRY?: number;
    sellTRY?: number;
    dailyChangePercent?: number;
    latestClosing?: number;
    latest?: number;
    difference?: number;
    minimum?: number;
    maximum?: number;
    changeDirection?: ChangeDirectionEnum;

    constructor(data?: ISymbolRateDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.symbolRID = _data["SymbolRID"];
            this.syncTimeStamp = _data["SyncTimeStamp"] ? moment(_data["SyncTimeStamp"].toString()) : <any>undefined;
            this.rateTimeStamp = _data["RateTimeStamp"] ? moment(_data["RateTimeStamp"].toString()) : <any>undefined;
            this.buyTRY = _data["BuyTRY"];
            this.sellTRY = _data["SellTRY"];
            this.dailyChangePercent = _data["DailyChangePercent"];
            this.latestClosing = _data["LatestClosing"];
            this.latest = _data["Latest"];
            this.difference = _data["Difference"];
            this.minimum = _data["Minimum"];
            this.maximum = _data["Maximum"];
            this.changeDirection = _data["ChangeDirection"];
        }
    }

    static fromJS(data: any): SymbolRateDTO {
        data = typeof data === 'object' ? data : {};
        let result = new SymbolRateDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["SymbolRID"] = this.symbolRID;
        data["SyncTimeStamp"] = this.syncTimeStamp ? this.syncTimeStamp.toISOString() : <any>undefined;
        data["RateTimeStamp"] = this.rateTimeStamp ? this.rateTimeStamp.toISOString() : <any>undefined;
        data["BuyTRY"] = this.buyTRY;
        data["SellTRY"] = this.sellTRY;
        data["DailyChangePercent"] = this.dailyChangePercent;
        data["LatestClosing"] = this.latestClosing;
        data["Latest"] = this.latest;
        data["Difference"] = this.difference;
        data["Minimum"] = this.minimum;
        data["Maximum"] = this.maximum;
        data["ChangeDirection"] = this.changeDirection;
        return data;
    }
}

/** Symbol rate */
export interface ISymbolRateDTO {
    symbolRID?: number | undefined;
    syncTimeStamp?: moment.Moment | undefined;
    rateTimeStamp?: moment.Moment | undefined;
    buyTRY?: number;
    sellTRY?: number;
    dailyChangePercent?: number;
    latestClosing?: number;
    latest?: number;
    difference?: number;
    minimum?: number;
    maximum?: number;
    changeDirection?: ChangeDirectionEnum;
}

/** Member information for retrieval and update */
export class PaginationInfo implements IPaginationInfo {
    /** Current page number */
    pageNo!: number;
    /** Maximum number of items per page */
    pageSize!: number;
    /** Total number of pages */
    totalPages!: number;
    /** Total number of items */
    totalItems!: number;

    constructor(data?: IPaginationInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageNo = _data["PageNo"];
            this.pageSize = _data["PageSize"];
            this.totalPages = _data["TotalPages"];
            this.totalItems = _data["TotalItems"];
        }
    }

    static fromJS(data: any): PaginationInfo {
        data = typeof data === 'object' ? data : {};
        let result = new PaginationInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["PageNo"] = this.pageNo;
        data["PageSize"] = this.pageSize;
        data["TotalPages"] = this.totalPages;
        data["TotalItems"] = this.totalItems;
        return data;
    }
}

/** Member information for retrieval and update */
export interface IPaginationInfo {
    /** Current page number */
    pageNo: number;
    /** Maximum number of items per page */
    pageSize: number;
    /** Total number of pages */
    totalPages: number;
    /** Total number of items */
    totalItems: number;
}

/** Province info */
export class ProvinceDTO implements IProvinceDTO {
    /** Unique integer ID for this Province */
    rID!: number;
    /** Province name */
    name!: string;

    constructor(data?: IProvinceDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rID = _data["RID"];
            this.name = _data["Name"];
        }
    }

    static fromJS(data: any): ProvinceDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ProvinceDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["RID"] = this.rID;
        data["Name"] = this.name;
        return data;
    }
}

/** Province info */
export interface IProvinceDTO {
    /** Unique integer ID for this Province */
    rID: number;
    /** Province name */
    name: string;
}

/** District info */
export class DistrictDTO implements IDistrictDTO {
    /** Unique integer ID for this District */
    rID!: number;
    /** District name */
    name!: string;

    constructor(data?: IDistrictDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rID = _data["RID"];
            this.name = _data["Name"];
        }
    }

    static fromJS(data: any): DistrictDTO {
        data = typeof data === 'object' ? data : {};
        let result = new DistrictDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["RID"] = this.rID;
        data["Name"] = this.name;
        return data;
    }
}

/** District info */
export interface IDistrictDTO {
    /** Unique integer ID for this District */
    rID: number;
    /** District name */
    name: string;
}

/** Result of the API operation */
export class APIResultDTO implements IAPIResultDTO {
    /** An integer code indicating the result of the operation */
    code!: number;
    /** A description of the result code */
    message!: string;
    /** Error list (if any) */
    errors?: string[];

    constructor(data?: IAPIResultDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["Code"];
            this.message = _data["Message"];
            if (Array.isArray(_data["Errors"])) {
                this.errors = [] as any;
                for (let item of _data["Errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): APIResultDTO {
        data = typeof data === 'object' ? data : {};
        let result = new APIResultDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Code"] = this.code;
        data["Message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["Errors"] = [];
            for (let item of this.errors)
                data["Errors"].push(item);
        }
        return data;
    }
}

/** Result of the API operation */
export interface IAPIResultDTO {
    /** An integer code indicating the result of the operation */
    code: number;
    /** A description of the result code */
    message: string;
    /** Error list (if any) */
    errors?: string[];
}

/** Ping result */
export class PingResultDTO implements IPingResultDTO {
    /** Server date and time in ISO 8601 format */
    serverDateTime!: moment.Moment;

    constructor(data?: IPingResultDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.serverDateTime = _data["ServerDateTime"] ? moment(_data["ServerDateTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): PingResultDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PingResultDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ServerDateTime"] = this.serverDateTime ? this.serverDateTime.toISOString() : <any>undefined;
        return data;
    }
}

/** Ping result */
export interface IPingResultDTO {
    /** Server date and time in ISO 8601 format */
    serverDateTime: moment.Moment;
}

export enum OTPTypeEnum {
    SMS = "SMS",
    Email = "Email",
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}